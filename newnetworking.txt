Abendstern Network Protocol

OVERVIEW
Abendstern's networking design operates as a peer-to-peer system over IPv4 or
IPv6 UDP. Unlike previous versions, this protocol primarily operates by
manipulation of byte arrays, removing the headaches associated with the older
event-driven designs.

All values are little-endian, unless otherwise noted. All structures are aligned
only to byte boundaries. In sub-byte structures, lower bits are listed before
higher. Floats are represented as IEEE 754-2008 single-precision values, in
little-endian byte order.

Strings are represented as NUL-terminated byte strings.

TOP-LEVEL
All packets begin with the following data:
  uint16        Sequence number
  uint16        Channel number
The sequence number is used to temporarily identify the packet, for purposes of
duplicate removal and acknowledgement. Sequence numbers in a connection start
from zero for both peers, and are incremented with every packet. Packets with
sequence numbers out of a certain range are silently ignored.

The channel number identifies the logical destination of the packet. A packet
directed to a channel that is not open is silently ignored.

Each channel can be bound to a "Gerät" (device best describes the concept, but
"network device" generally refers to the physical object) which handles the
actual payload of the packet. Initially, only channel 0 is open to the
Synchronous Command Gerät.

BLOCK GERÄTE
The majority of Geräte belong to a class called "block Geräte", which define a
structure lying on top of a byte array. The remote peer communicates by mutating
the block using the protocol described below. When a block Gerät is opened, the
array's contents are initially zero (but the object is considered uninitialised
until the first complete mutation operation).

Communicatino with a block Gerät is done via mutation operations. Since these
operations may be larger than 256 bytes, they are often split into multiple
packets. Therefore, this sub-protocol comes in two layers. The upper layer
prefixes fragments with the following structure:
  uint16        Operation sequence number
  uint16        Previous mutation this operation applies to
  uint16        Fragment index
  uint16        Number of fragments
  <payload>
The operation sequence number starts at 1; the first 0 is the implicit
initialisation of the block to zero. The second field allows proper sequencing
(and ignoring) of operations such that a consistent state is preserved.

An operation is not applied until all fragments have been received. When all
fragments are received, and if the operation is still applicable (has not been
obsoleted by another operation that depended on a mutation that came before the
one we are concerned with), the payloads are concatenated by order of fragment
index, and the result is interpreted as described below.

An operation is composed of a series of deltata; each delta has the following
high-level format:
  index-format
  offset (also called "start" below) from end of previous segment
  length
  byte[length] data

The index-format is a byte specifing the format of the indices:
  0     If set, the offset is embedded in bits 1-4, and the length in 5-7, in
        this byte. Otherwise, bits 1-7 specify format.
  1-3   If not embedded (see bit 1), determines the format of the indices
        following the format byte:
          0     4-4     (s=p[1]&0xF,                    l=(p[1]>>4)&0xF)
          1     6-2     (s=p[1]&0x3F,                   l=(p[1]>>6)&0x3)
          2     8-8     (s=p[1],                        l=p[2])
          3     12-4    (s=p[1]|((p[2]&0xF) << 8),      l=(p[2]>>4)&0xF)
          4     16-8    (s=p[1]|(p[2]<<8),              l=p[3])
          5     16-16   (s=p[1]|(p[2]<<8),              l=p[3]|(p[4]<<8))
          6     24-24   (similar)
          7     8-4     (s=p[1], l=p[0]>>4)
  4-7   In format 7, the length
The data that follow the indices are copied into the block at the given
location. Out-of-bounds indices are ignored.

CONNECTIONLESS PACKETS
When a peer receives a packet from a host it is not connected to, it interprets
the packet as a connectionless request, according to the first few bytes in the
packet.

00-00-00-00-02 Start Connection
This is technically a STX packet to the Synchronous Control Gerät, but must be
processed separately since no connection exists yet. See STX under the SCG for
more information.

"Abendsuch" Discover Game
No contents.
Requests a Game-Discovery packet as an answer. Peers participating in LAN games
should answer appropriately.

"Abendspiel" Game Discovery
Contents:
  uint32        Client number of overseer (see Peer Information Gerät)
  byte          Peer count
  byte          Zero if open, one if password-protected
  char[4]       Game mode

--- STANDARD GERÄTE ---
The Geräte below are used by the protocol, and are not specific to Abendstern.

SYNCHRONOUS COMMAND GERÄT
The SCG is used for controlling the protocol itself. The SCG does not have an
assigned number, and it is an error to close the channel is open on.

The SCG, as its name suggests, only allows one outstanding packet at a time,
using its own synchronous acknowledgement system, separate from the asynchronous
acknowledgement Gerät.

Communication works as follows: Whenever the local peer sends a packet needing
acknowledgement, it will not send any further packets until that packet has been
ACKed (ACK and EOT packets are exempt from this rule); if no ACK is received
after a time somewhat greater than the estimated round-trip time, the packet is
retransmitted. Whenever an ACK-needing packet is received, even if it is a
duplicate, an ACK is immediately sent for it. If the SCG has sent nothing for
one second, it sends a SYN packet to keep the connection open.

Each packet it sends is prefixed with a byte indicating the packet's purpose:
  0x02  STX     Start of transmission
  0x04  EOT     End of transmission
  0x06  ACK     Synchronous Acknowledgement
  0x22  SYN     Synchronous Idle
  0x11  XON     Open channel(s)
  0x13  XOF     Close channel(s)

Packet format for STX:
  byte[16]      Protocol version hash
  string        Application name ("Abendstern")
An STX requests to open two-way communication between peers. An STX is answered
with an ACK or an EOT, depending on whether the peers are compatible and willing
to talk to each other.

Packet format for EOT:
  string        Disconnect reason
  string        l10n entry for disconnect reason
A connection is considered closed after transmission of an EOT. EOTs are not
ACKed; rather, the EOT is sent several times to make delivery likely.

Packet format for ACK:
  uint16        Packet number being acknowledged
ACK indicates that the specified packet has been received successfully. An
ACK is assumed to reach the destination unless the acknowledged packet is
retransmitted. Every reception of an ACK-needing packet is to be answered with
exactly one ACK.

Packet format for SYN:
  empty
SYN is sent to indicate that the sender has nothing to send. It primarily serves
to give a distinction between loss of connectivity and a successful ACK. A SYN
is not replied to.

Packet format for XON (repeated for each channel to open):
  uint16        Gerät number
  uint16        Channel number
XON opens a Gerät on the given channel. It must be ACKed.

Packet format for XOF (repeated for each channel to open):
  uint16        Channel number
XOF closes the given channel and its Gerät. Closing Gerät zero effectively ends
the connection, since it terminates the ability for the SCG of the other peer
to communicate (no ACKs can be sent in reply).

LATENCY DISCOVERY GERÄT
Gerät number: 0
Number per connection: 0 or 1
Requires: none
The LDG, when open by both peers, allows calculating round-trip delay of
packets. It uses no acknowledgement system; packets which do not reach the
destination can be simply considered dropped. The first byte of a packet
identifies the type: 0 is PING and 1 is PONG. When a peer receives a PING, it
should immediately respond with a PONG containing the same payload data. The
payload data is implementation-, platform-, and build-specific.

ASYNCHRONOUS ACKNOWLEDGEMENT GERÄT
Gerät number: 1
Number per connection: 0 or 1 (effectively 1, since everything uses it)

The Asynchronous Acknowledgement Gerät provides delivery status notification to
those Geräte that use it (called an AAG-client hereonout).

Whenever a peer receives packets to be acknowledged, it stores the sequence
numbers in ascending order until all current packets have been processed, then
sends a packet with the following structure:
  uint16        Greatest sequence number acknowledged in the most recent
                acknowledgement sent.
  Repeating for the rest of the packet:
  byte          MSB of sequence numbers being acknowledged
  byte[8]       Bitset of sequence number LSBs being acknowledged
Each sequence number encoded is a positive acknowledgement of that packet; any
packets not listed that have a sequence number less than (modulo) the greatest
sequence number are considered dropped, and must be ignored by the peer after
the acknowledgement packet has been sent.

The initial sequence number allows the receiving peer to know the first sequence
number being negatively acknowledged, in case a prior acknowledgement packet was
not delivered.

It is not an error to acknowledge the same packet more than once; this will
happen, for example, if an acknowledgement is not acknowledged before the next
acknowledgement packet is sent.

The AAG is itself an AAG-client so that it can know whether its acknowledgements
reach the remote peer. It will retransmit its acknowledgement packets on
negative acknowledgement, or after a sufficient delay.

SEQUNTIAL TEXT GERÄT
Gerät number: 2
Number per connection: 0 or 1
Requires: AAG, acceptance (via PIG)

All packets from this Gerät have the following structure:
  uint64        Strong sequence number
  NTBS          payload

Sequence numbers start at zero, and are incremented on every outgoing packet.
STD packets are guaranteed too be processed in the order they are transmitted;
one is not processed until its sequence number is exactly what is expected.

TEXT MESSAGE GERÄT
Gerät number: 3
Number per connection: 0 or 1
Requires: AAG, acceptance (via PIG)

Packets have the following structure:
  NTBS          payload

This device passes user text messages, which do not need strong ordering (and
are handled quite differently from sequential text in Abendstern).

PEER INFORMATION GERÄT
Gerät number: 4
Number per connection: 1
Requires: AAG

Block structure:
  byte[4]       Internet IPv4 address
  uint16[8]     Internet IPv6 address
  uint16        Internet port
  byte[4]       LAN IPv4 address
  uint16[8]     LAN IPv6 address
  uint16        LAN port
  uint32        Client number (userid for Internet game, part of LAN IP address
                for LAN game)
  byte[32]      Authentication information (provided by Abendstern Network
                for Internet game, hash of game password for LAN game)
  char[4]       Expected game mode
  byte          Flags
    0           IP version; 0=IPv4, 1=IPv6
    1           Game type; 0=Internet, 1=LAN
    2           bool: ready for remote acceptance evaluation?
    3           bool: has the peer accepted the remote's information?

Only the addresses matching the IP version used are actually filled out.

In order to be considered part of a game, a Peer must pass acceptance with
all peers in the game. The process is as follows:
  1. Local peer fills out data
  2. Local peer sets the ready-for-acceptance bit
  3. Remote peer notices ready bit, evaluates information
  4. If accepted, remote peer sets accepted bit; otherwise, terminates
     connection

For Internet games, the Abendstern Network provides a base key to authenticate
with. For authentication, the local peer uses a SHA-256 hash of the following
text:
  <local-id><remote-id><base-key>
where local-id and remote-id are textual representations of the local and remote
global-unique IDs. The remote peer sends this hash, as well as the local and
remote IDs, to the Abendstern Network, allowing confirmation of the local peer.

For LAN games, every peer knows the plaintext password. Authentication works
similarly to Internet games, except the base-key is the plaintext password, and
peers can validate the authentication themselves.


--- Begin: Abendstern-Specific ---
ABENDSTERN OBJECTS
All Abendstern objects to be sent on the network are block devices. Channels for
objects are only created to remote peers if it is deemed necessary for them to
know about them. Non-transient objects, like Ships, are always considered
necessary (for radar, etc). Others, like weapons, are only created if within a
certain distance of any of the remote peer's ships, typically a radius of 8.
Some objects, like EnergyCharges, can be perfectly extrapolated after creation.
These objects do not have updates sent over the network, until their
destruction. Since many objects need to be altered before being destroyed, an
object channel is not closed until its final update operation has been con be
confirmed processed.

The structure for objects themselves is defined in  src/net/definition.tcl .
See src/net/generate.tcl for a formal description of the file's contents.
