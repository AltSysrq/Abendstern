
  /**
   * @file
   * @author src/net/generate.tcl
   * @brief Autogenerated. Do not edit!
   */

  #include <cstring>

  #include "../io.hxx"

  using namespace std;
  //These diagnostics will happen alot due to the way code is
  //generated; they are safe to ignore.
  #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
  #pragma GCC diagnostic ignored "-Wunused-variable"

  //These are defined to... something on windows
  #ifdef NEAR
  #undef NEAR
  #endif
  #ifdef FAR
  #undef FAR
  #endif



//MSVC++ doesn't handle inherited members accessed by friends correctly.
//This hack injects an appropriate friends list into GameObject
#ifdef WIN32
#define TclGameObject  TclGameObject;  friend class INO_EnergyCharge; friend class ENO_EnergyCharge; friend class INO_MagnetoBomb; friend class ENO_MagnetoBomb; friend class INO_SemiguidedBomb; friend class ENO_SemiguidedBomb; friend class INO_PlasmaBurst; friend class ENO_PlasmaBurst; friend class INO_Missile; friend class ENO_Missile; friend class INO_ParticleEmitter; friend class ENO_ParticleEmitter; friend class INO_MonophasicEnergyPulse; friend class ENO_MonophasicEnergyPulse; friend class INO_Ship; friend class ENO_Ship; friend class INO_Spectator; friend class ENO_Spectator
//MSVC++ can't handle fabs(int)
#define fabs(x) std::fabs((float)(x))
#endif
#include "xnetobj.hxx"


  #include <cassert>
  #include <typeinfo>
  #include "src/sim/game_object.hxx"
  #include "src/sim/blast.hxx"
  #include "src/ship/everything.hxx"
  #include "src/ship/ship_renderer.hxx"
  #include "src/weapon/energy_charge.hxx"
  #include "src/weapon/magneto_bomb.hxx"
  #include "src/weapon/plasma_burst.hxx"
  #include "src/weapon/semiguided_bomb.hxx"
  #include "src/weapon/missile.hxx"
  #include "src/weapon/monophasic_energy_pulse.hxx"
  #include "src/weapon/particle_beam.hxx"
  #include "src/weapon/explode_listener.hxx"
  #include "src/camera/spectator.hxx"
  #include "src/exit_conditions.hxx"
  #include "../ship_damage_geraet.hxx"

INO_EnergyCharge::INO_EnergyCharge(NetworkConnection* cxn_)
: ImportedGameObject(10, cxn_),
  cxn(cxn_) 
{ }

INO_EnergyCharge::~INO_EnergyCharge() {
  
}

const NetworkConnection::geraet_num INO_EnergyCharge::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_EnergyCharge::create(NetworkConnection* cxn) throw() {
  return new INO_EnergyCharge(cxn);
}

void INO_EnergyCharge::construct() throw() {
  object = decodeConstruct(state);
}

void INO_EnergyCharge::update() throw() {
  if (decodeUpdate(state, static_cast<EnergyCharge*>(object)))
    destroy(false);
}

EnergyCharge* INO_EnergyCharge::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { if (x) delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  EnergyCharge* X = NULL;
  float vx;
float vy;
float x;
float y;
unsigned char theta;
unsigned intensity;
bool exploded;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
io::read_c(&DATA[8+0], theta);
intensity = (DATA[9+0] >> 0) & 127;
exploded = (DATA[9+0] >> 7) & 1;
  
     X = new EnergyCharge(field, x, y, vx, vy,
                          theta*pi*2/255.0f, intensity/127.0f);
  
  
  
  return X;
  #undef DESTROY
}

bool INO_EnergyCharge::decodeUpdate(const std::vector<byte>& DATA, EnergyCharge* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
unsigned char theta;
unsigned intensity;
bool exploded;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
X->vx = vx;
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
X->vy = vy;
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
X->x = x;
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
X->y = y;
io::read_c(&DATA[8+0], theta);
intensity = (DATA[9+0] >> 0) & 127;
exploded = (DATA[9+0] >> 7) & 1;

      if (!X->exploded && exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  return false;
  #undef DESTROY
}

ENO_EnergyCharge::ENO_EnergyCharge(NetworkConnection* cxn, EnergyCharge* obj)
: ExportedGameObject(10, cxn, obj, clone(obj, cxn))
  
      ,explListener((EnergyCharge*)local.ref, this)
    
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
unsigned char theta;
unsigned intensity;
bool exploded;
   exploded = X->exploded; 
DATA[9+0] &= ~(1<<7); DATA[9+0] |= (exploded & 1) << 7;
 intensity = (byte)(127.0f*X->intensity); 
DATA[9+0] &= ~(127<<0); DATA[9+0] |= (intensity & 127) << 0;
 theta = (byte)(X->theta/2/pi*255.0f); 
io::write_c(&DATA[8+0], theta);
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef DATA
  #undef field
  #undef X
  dirty = true;
}

ENO_EnergyCharge::~ENO_EnergyCharge() {
  
}

void ENO_EnergyCharge::init() throw() {
  EnergyCharge*const X = (EnergyCharge*)local.ref;
  
}

EnergyCharge* ENO_EnergyCharge::clone(const EnergyCharge* src, NetworkConnection* cxn)
const throw() {
  #define X src
  #define field (&cxn->field)
  #define DESTROY(x) assert(!(x))
  #define LOCAL_CLONE
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
unsigned char theta;
unsigned intensity;
bool exploded;
   exploded = X->exploded; 
 intensity = (byte)(127.0f*X->intensity); 
 theta = (byte)(X->theta/2/pi*255.0f); 
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  EnergyCharge* dst;
  #define X dst
  
     X = new EnergyCharge(field, x, y, vx, vy,
                          theta*pi*2/255.0f, intensity/127.0f);
  
  
  #undef LOCAL_CLONE
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_EnergyCharge::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
unsigned char theta;
unsigned intensity;
bool exploded;
    S(const EnergyCharge* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
 theta = (byte)(X->theta/2/pi*255.0f); 
 intensity = (byte)(127.0f*X->intensity); 
 exploded = X->exploded; 
    }
  } x(static_cast<EnergyCharge*>(local.ref)), y(static_cast<EnergyCharge*>(remote));

   return false; 
{float d=fabs(x.vx-y.vx)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.vy-y.vy)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.x-y.x)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.y-y.y)*128;FAR+=d;NEAR+=d;}

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR*FAR > l_dist && l_dist >= 5*5) || (NEAR > 1 && l_dist < 5*5);
}

void ENO_EnergyCharge::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  EnergyCharge* l_local = static_cast<EnergyCharge*>(this->local.ref);
  EnergyCharge* l_remote = static_cast<EnergyCharge*>(this->remote);
  float vx;
float vy;
float x;
float y;
unsigned char theta;
unsigned intensity;
bool exploded;
  #define X l_local
   exploded = X->exploded; 
DATA[9+0] &= ~(1<<7); DATA[9+0] |= (exploded & 1) << 7;
 intensity = (byte)(127.0f*X->intensity); 
DATA[9+0] &= ~(127<<0); DATA[9+0] |= (intensity & 127) << 0;
 theta = (byte)(X->theta/2/pi*255.0f); 
io::write_c(&DATA[8+0], theta);
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;

      if (!X->exploded && exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}

      ENO_EnergyCharge::ExplListener::ExplListener(EnergyCharge* it, ENO_EnergyCharge* that_)
      : ExplodeListener<EnergyCharge>(it), that(that_) {}
    

INO_MagnetoBomb::INO_MagnetoBomb(NetworkConnection* cxn_)
: ImportedGameObject(23, cxn_),
  cxn(cxn_) 
{ }

INO_MagnetoBomb::~INO_MagnetoBomb() {
  
}

const NetworkConnection::geraet_num INO_MagnetoBomb::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_MagnetoBomb::create(NetworkConnection* cxn) throw() {
  return new INO_MagnetoBomb(cxn);
}

void INO_MagnetoBomb::construct() throw() {
  object = decodeConstruct(state);
}

void INO_MagnetoBomb::update() throw() {
  if (decodeUpdate(state, static_cast<MagnetoBomb*>(object)))
    destroy(false);
}

MagnetoBomb* INO_MagnetoBomb::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { if (x) delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  MagnetoBomb* X = NULL;
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
io::read_c(&DATA[8+0], ax);
if (ax != ax) ax = -1.0e9;
 else if (ax < -1.0e9) ax = -1.0e9;
 else if (ax > +1.0e9) ax = +1.0e9;
io::read_c(&DATA[12+0], ay);
if (ay != ay) ay = -1.0e9;
 else if (ay < -1.0e9) ay = -1.0e9;
 else if (ay > +1.0e9) ay = +1.0e9;
io::read_c(&DATA[16+0], power);
if (power != power) power = 0;
 else if (power < 0) power = 0;
 else if (power > +1.0e9) power = +1.0e9;
io::read_c(&DATA[20+0], timeAlive);
 timeAlive = max((short unsigned)0,timeAlive); 
exploded = (DATA[22+0] >> 0) & 1;
  
    X = new MagnetoBomb(field, x, y, vx, vy, power, NULL);
    X->isRemote = true;
    X->includeInCollisionDetection = false;
    X->decorative = true;
  
   X->ax = ax; 
 X->ay = ay; 
 X->timeAlive = timeAlive; 
  
  return X;
  #undef DESTROY
}

bool INO_MagnetoBomb::decodeUpdate(const std::vector<byte>& DATA, MagnetoBomb* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
X->vx = vx;
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
X->vy = vy;
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
X->x = x;
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
X->y = y;
io::read_c(&DATA[8+0], ax);
if (ax != ax) ax = -1.0e9;
 else if (ax < -1.0e9) ax = -1.0e9;
 else if (ax > +1.0e9) ax = +1.0e9;
X->ax = ax;
io::read_c(&DATA[12+0], ay);
if (ay != ay) ay = -1.0e9;
 else if (ay < -1.0e9) ay = -1.0e9;
 else if (ay > +1.0e9) ay = +1.0e9;
X->ay = ay;
io::read_c(&DATA[16+0], power);
if (power != power) power = 0;
 else if (power < 0) power = 0;
 else if (power > +1.0e9) power = +1.0e9;
X->power = power;
io::read_c(&DATA[20+0], timeAlive);
 timeAlive = max((short unsigned)0,timeAlive); 
X->timeAlive = timeAlive;
exploded = (DATA[22+0] >> 0) & 1;

      if (!X->exploded && exploded) {
        X->explode();
        DESTROY(false);
      }
    
  return false;
  #undef DESTROY
}

ENO_MagnetoBomb::ENO_MagnetoBomb(NetworkConnection* cxn, MagnetoBomb* obj)
: ExportedGameObject(23, cxn, obj, clone(obj, cxn))
  
      ,explListener((MagnetoBomb*)local.ref, this)
    
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
   exploded = X->exploded; 
DATA[22+0] &= ~(1<<0); DATA[22+0] |= (exploded & 1) << 0;
timeAlive = X->timeAlive;
io::write_c(&DATA[20+0], timeAlive);
power = X->power;
io::write_c(&DATA[16+0], power);
ay = X->ay;
io::write_c(&DATA[12+0], ay);
ax = X->ax;
io::write_c(&DATA[8+0], ax);
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef DATA
  #undef field
  #undef X
  dirty = true;
}

ENO_MagnetoBomb::~ENO_MagnetoBomb() {
  
}

void ENO_MagnetoBomb::init() throw() {
  MagnetoBomb*const X = (MagnetoBomb*)local.ref;
  
}

MagnetoBomb* ENO_MagnetoBomb::clone(const MagnetoBomb* src, NetworkConnection* cxn)
const throw() {
  #define X src
  #define field (&cxn->field)
  #define DESTROY(x) assert(!(x))
  #define LOCAL_CLONE
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
   exploded = X->exploded; 
timeAlive = X->timeAlive;
power = X->power;
ay = X->ay;
ax = X->ax;
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  MagnetoBomb* dst;
  #define X dst
  
    X = new MagnetoBomb(field, x, y, vx, vy, power, NULL);
    X->isRemote = true;
    X->includeInCollisionDetection = false;
    X->decorative = true;
  
   X->ax = ax; 
 X->ay = ay; 
 X->timeAlive = timeAlive; 
  #undef LOCAL_CLONE
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_MagnetoBomb::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
    S(const MagnetoBomb* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
ax = X->ax;
ay = X->ay;
power = X->power;
timeAlive = X->timeAlive;
 exploded = X->exploded; 
    }
  } x(static_cast<MagnetoBomb*>(local.ref)), y(static_cast<MagnetoBomb*>(remote));

  {float d=fabs(x.vx-y.vx)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.vy-y.vy)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.x-y.x)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.y-y.y)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.ax-y.ax)*0;FAR+=d;NEAR+=d;}
{float d=fabs(x.ay-y.ay)*0;FAR+=d;NEAR+=d;}
{float d=fabs(x.power-y.power)*0;FAR+=d;NEAR+=d;}
{float d=fabs(x.timeAlive-y.timeAlive)*0;FAR+=d;NEAR+=d;}

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR*FAR > l_dist && l_dist >= 5*5) || (NEAR > 1 && l_dist < 5*5);
}

void ENO_MagnetoBomb::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  MagnetoBomb* l_local = static_cast<MagnetoBomb*>(this->local.ref);
  MagnetoBomb* l_remote = static_cast<MagnetoBomb*>(this->remote);
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  #define X l_local
   exploded = X->exploded; 
DATA[22+0] &= ~(1<<0); DATA[22+0] |= (exploded & 1) << 0;
timeAlive = X->timeAlive;
io::write_c(&DATA[20+0], timeAlive);
power = X->power;
io::write_c(&DATA[16+0], power);
ay = X->ay;
io::write_c(&DATA[12+0], ay);
ax = X->ax;
io::write_c(&DATA[8+0], ax);
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
X->ax = ax;
X->ay = ay;
X->power = power;
X->timeAlive = timeAlive;

      if (!X->exploded && exploded) {
        X->explode();
        DESTROY(false);
      }
    
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}

      ENO_MagnetoBomb::ExplListener::ExplListener(MagnetoBomb* it, ENO_MagnetoBomb* that_)
      : ExplodeListener<MagnetoBomb>(it), that(that_) {}
    

INO_SemiguidedBomb::INO_SemiguidedBomb(NetworkConnection* cxn_)
: ImportedGameObject(23, cxn_),
  cxn(cxn_) 
{ }

INO_SemiguidedBomb::~INO_SemiguidedBomb() {
  
}

const NetworkConnection::geraet_num INO_SemiguidedBomb::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_SemiguidedBomb::create(NetworkConnection* cxn) throw() {
  return new INO_SemiguidedBomb(cxn);
}

void INO_SemiguidedBomb::construct() throw() {
  object = decodeConstruct(state);
}

void INO_SemiguidedBomb::update() throw() {
  if (decodeUpdate(state, static_cast<SemiguidedBomb*>(object)))
    destroy(false);
}

SemiguidedBomb* INO_SemiguidedBomb::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { if (x) delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  SemiguidedBomb* X = NULL;
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
io::read_c(&DATA[8+0], ax);
if (ax != ax) ax = -1.0e9;
 else if (ax < -1.0e9) ax = -1.0e9;
 else if (ax > +1.0e9) ax = +1.0e9;
io::read_c(&DATA[12+0], ay);
if (ay != ay) ay = -1.0e9;
 else if (ay < -1.0e9) ay = -1.0e9;
 else if (ay > +1.0e9) ay = +1.0e9;
io::read_c(&DATA[16+0], power);
if (power != power) power = 0;
 else if (power < 0) power = 0;
 else if (power > +1.0e9) power = +1.0e9;
io::read_c(&DATA[20+0], timeAlive);
 timeAlive = max((short unsigned)0,timeAlive); 
exploded = (DATA[22+0] >> 0) & 1;
  
    X = new SemiguidedBomb(field, x, y, vx, vy, power, NULL);
    X->isRemote = true;
    X->includeInCollisionDetection = false;
    X->decorative = true;
  
   X->ax = ax; 
 X->ay = ay; 
 X->timeAlive = timeAlive; 
  
  return X;
  #undef DESTROY
}

bool INO_SemiguidedBomb::decodeUpdate(const std::vector<byte>& DATA, SemiguidedBomb* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
X->vx = vx;
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
X->vy = vy;
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
X->x = x;
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
X->y = y;
io::read_c(&DATA[8+0], ax);
if (ax != ax) ax = -1.0e9;
 else if (ax < -1.0e9) ax = -1.0e9;
 else if (ax > +1.0e9) ax = +1.0e9;
X->ax = ax;
io::read_c(&DATA[12+0], ay);
if (ay != ay) ay = -1.0e9;
 else if (ay < -1.0e9) ay = -1.0e9;
 else if (ay > +1.0e9) ay = +1.0e9;
X->ay = ay;
io::read_c(&DATA[16+0], power);
if (power != power) power = 0;
 else if (power < 0) power = 0;
 else if (power > +1.0e9) power = +1.0e9;
X->power = power;
io::read_c(&DATA[20+0], timeAlive);
 timeAlive = max((short unsigned)0,timeAlive); 
X->timeAlive = timeAlive;
exploded = (DATA[22+0] >> 0) & 1;

      if (!X->exploded && exploded) {
        X->explode();
        DESTROY(false);
      }
    
  return false;
  #undef DESTROY
}

ENO_SemiguidedBomb::ENO_SemiguidedBomb(NetworkConnection* cxn, SemiguidedBomb* obj)
: ExportedGameObject(23, cxn, obj, clone(obj, cxn))
  
      ,explListener((MagnetoBomb*)local.ref, this)
    
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
   exploded = X->exploded; 
DATA[22+0] &= ~(1<<0); DATA[22+0] |= (exploded & 1) << 0;
timeAlive = X->timeAlive;
io::write_c(&DATA[20+0], timeAlive);
power = X->power;
io::write_c(&DATA[16+0], power);
ay = X->ay;
io::write_c(&DATA[12+0], ay);
ax = X->ax;
io::write_c(&DATA[8+0], ax);
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef DATA
  #undef field
  #undef X
  dirty = true;
}

ENO_SemiguidedBomb::~ENO_SemiguidedBomb() {
  
}

void ENO_SemiguidedBomb::init() throw() {
  SemiguidedBomb*const X = (SemiguidedBomb*)local.ref;
  
}

SemiguidedBomb* ENO_SemiguidedBomb::clone(const SemiguidedBomb* src, NetworkConnection* cxn)
const throw() {
  #define X src
  #define field (&cxn->field)
  #define DESTROY(x) assert(!(x))
  #define LOCAL_CLONE
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
   exploded = X->exploded; 
timeAlive = X->timeAlive;
power = X->power;
ay = X->ay;
ax = X->ax;
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  SemiguidedBomb* dst;
  #define X dst
  
    X = new SemiguidedBomb(field, x, y, vx, vy, power, NULL);
    X->isRemote = true;
    X->includeInCollisionDetection = false;
    X->decorative = true;
  
   X->ax = ax; 
 X->ay = ay; 
 X->timeAlive = timeAlive; 
  #undef LOCAL_CLONE
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_SemiguidedBomb::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
    S(const SemiguidedBomb* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
ax = X->ax;
ay = X->ay;
power = X->power;
timeAlive = X->timeAlive;
 exploded = X->exploded; 
    }
  } x(static_cast<SemiguidedBomb*>(local.ref)), y(static_cast<SemiguidedBomb*>(remote));

  {float d=fabs(x.vx-y.vx)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.vy-y.vy)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.x-y.x)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.y-y.y)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.ax-y.ax)*0;FAR+=d;NEAR+=d;}
{float d=fabs(x.ay-y.ay)*0;FAR+=d;NEAR+=d;}
{float d=fabs(x.power-y.power)*0;FAR+=d;NEAR+=d;}
{float d=fabs(x.timeAlive-y.timeAlive)*0;FAR+=d;NEAR+=d;}

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR*FAR > l_dist && l_dist >= 5*5) || (NEAR > 1 && l_dist < 5*5);
}

void ENO_SemiguidedBomb::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  SemiguidedBomb* l_local = static_cast<SemiguidedBomb*>(this->local.ref);
  SemiguidedBomb* l_remote = static_cast<SemiguidedBomb*>(this->remote);
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  #define X l_local
   exploded = X->exploded; 
DATA[22+0] &= ~(1<<0); DATA[22+0] |= (exploded & 1) << 0;
timeAlive = X->timeAlive;
io::write_c(&DATA[20+0], timeAlive);
power = X->power;
io::write_c(&DATA[16+0], power);
ay = X->ay;
io::write_c(&DATA[12+0], ay);
ax = X->ax;
io::write_c(&DATA[8+0], ax);
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
X->ax = ax;
X->ay = ay;
X->power = power;
X->timeAlive = timeAlive;

      if (!X->exploded && exploded) {
        X->explode();
        DESTROY(false);
      }
    
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}

      ENO_SemiguidedBomb::ExplListener::ExplListener(MagnetoBomb* it, ENO_SemiguidedBomb* that_)
      : ExplodeListener<MagnetoBomb>(it), that(that_) {}
    

INO_PlasmaBurst::INO_PlasmaBurst(NetworkConnection* cxn_)
: ImportedGameObject(10, cxn_),
  cxn(cxn_) 
{ }

INO_PlasmaBurst::~INO_PlasmaBurst() {
  
}

const NetworkConnection::geraet_num INO_PlasmaBurst::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_PlasmaBurst::create(NetworkConnection* cxn) throw() {
  return new INO_PlasmaBurst(cxn);
}

void INO_PlasmaBurst::construct() throw() {
  object = decodeConstruct(state);
}

void INO_PlasmaBurst::update() throw() {
  if (decodeUpdate(state, static_cast<PlasmaBurst*>(object)))
    destroy(false);
}

PlasmaBurst* INO_PlasmaBurst::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { if (x) delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  PlasmaBurst* X = NULL;
  float vx;
float vy;
float x;
float y;
unsigned char direction;
unsigned mass;
unsigned exploded;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
io::read_c(&DATA[8+0], direction);
mass = (DATA[9+0] >> 0) & 127;
 if (mass > 100) mass = 100; 
exploded = (DATA[9+0] >> 7) & 1;
  
    X = new PlasmaBurst(field, x, y, vx, vy, direction*pi*2/255.0f, mass);
  
  
  
  return X;
  #undef DESTROY
}

bool INO_PlasmaBurst::decodeUpdate(const std::vector<byte>& DATA, PlasmaBurst* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
unsigned char direction;
unsigned mass;
unsigned exploded;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
X->vx = vx;
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
X->vy = vy;
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
X->x = x;
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
X->y = y;
io::read_c(&DATA[8+0], direction);
mass = (DATA[9+0] >> 0) & 127;
 if (mass > 100) mass = 100; 
X->mass = mass;
exploded = (DATA[9+0] >> 7) & 1;

      if (exploded && !X->exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  return false;
  #undef DESTROY
}

ENO_PlasmaBurst::ENO_PlasmaBurst(NetworkConnection* cxn, PlasmaBurst* obj)
: ExportedGameObject(10, cxn, obj, clone(obj, cxn))
  
      ,explListener((PlasmaBurst*)local.ref, this)
    
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
unsigned char direction;
unsigned mass;
unsigned exploded;
  
      exploded = X->exploded;
    
DATA[9+0] &= ~(1<<7); DATA[9+0] |= (exploded & 1) << 7;
mass = X->mass;
DATA[9+0] &= ~(127<<0); DATA[9+0] |= (mass & 127) << 0;

      direction = (byte)(255.0f*X->direction/2/pi);
    
io::write_c(&DATA[8+0], direction);
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef DATA
  #undef field
  #undef X
  dirty = true;
}

ENO_PlasmaBurst::~ENO_PlasmaBurst() {
  
}

void ENO_PlasmaBurst::init() throw() {
  PlasmaBurst*const X = (PlasmaBurst*)local.ref;
  
}

PlasmaBurst* ENO_PlasmaBurst::clone(const PlasmaBurst* src, NetworkConnection* cxn)
const throw() {
  #define X src
  #define field (&cxn->field)
  #define DESTROY(x) assert(!(x))
  #define LOCAL_CLONE
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
unsigned char direction;
unsigned mass;
unsigned exploded;
  
      exploded = X->exploded;
    
mass = X->mass;

      direction = (byte)(255.0f*X->direction/2/pi);
    
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  PlasmaBurst* dst;
  #define X dst
  
    X = new PlasmaBurst(field, x, y, vx, vy, direction*pi*2/255.0f, mass);
  
  
  #undef LOCAL_CLONE
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_PlasmaBurst::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
unsigned char direction;
unsigned mass;
unsigned exploded;
    S(const PlasmaBurst* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;

      direction = (byte)(255.0f*X->direction/2/pi);
    
mass = X->mass;

      exploded = X->exploded;
    
    }
  } x(static_cast<PlasmaBurst*>(local.ref)), y(static_cast<PlasmaBurst*>(remote));

  {float d=fabs(x.vx-y.vx)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.vy-y.vy)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.x-y.x)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.y-y.y)*128;FAR+=d;NEAR+=d;}
 return false; 
{float d=fabs(x.mass-y.mass)*0;FAR+=d;NEAR+=d;}

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR*FAR > l_dist && l_dist >= 5*5) || (NEAR > 1 && l_dist < 5*5);
}

void ENO_PlasmaBurst::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  PlasmaBurst* l_local = static_cast<PlasmaBurst*>(this->local.ref);
  PlasmaBurst* l_remote = static_cast<PlasmaBurst*>(this->remote);
  float vx;
float vy;
float x;
float y;
unsigned char direction;
unsigned mass;
unsigned exploded;
  #define X l_local
  
      exploded = X->exploded;
    
DATA[9+0] &= ~(1<<7); DATA[9+0] |= (exploded & 1) << 7;
mass = X->mass;
DATA[9+0] &= ~(127<<0); DATA[9+0] |= (mass & 127) << 0;

      direction = (byte)(255.0f*X->direction/2/pi);
    
io::write_c(&DATA[8+0], direction);
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
X->mass = mass;

      if (exploded && !X->exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}

      ENO_PlasmaBurst::ExplListener::ExplListener(PlasmaBurst* it, ENO_PlasmaBurst* that_)
      : ExplodeListener<PlasmaBurst>(it), that(that_) {}
    

INO_Missile::INO_Missile(NetworkConnection* cxn_)
: ImportedGameObject(18, cxn_),
  cxn(cxn_) 
{ }

INO_Missile::~INO_Missile() {
  
}

const NetworkConnection::geraet_num INO_Missile::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_Missile::create(NetworkConnection* cxn) throw() {
  return new INO_Missile(cxn);
}

void INO_Missile::construct() throw() {
  object = decodeConstruct(state);
}

void INO_Missile::update() throw() {
  if (decodeUpdate(state, static_cast<Missile*>(object)))
    destroy(false);
}

Missile* INO_Missile::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { if (x) delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  Missile* X = NULL;
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float xdir;
float ydir;
unsigned level;
unsigned exploded;
unsigned char timeAlive;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
{signed short _ax;
    io::read_c(&DATA[8+0],_ax);
    ax=_ax*2.0e-6f/0x7FFF;
   }
{signed short _ay;
    io::read_c(&DATA[10+0],_ay);
    ay=_ay*2.0e-6f/0x7FFF;
   }
{signed short _xdir;
    io::read_c(&DATA[12+0],_xdir);
    xdir=_xdir*2.0e-6f/0x7FFF;
   }
{signed short _ydir;
    io::read_c(&DATA[14+0],_ydir);
    ydir=_ydir*2.0e-6f/0x7FFF;
   }
level = (DATA[16+0] >> 0) & 15;
exploded = (DATA[16+0] >> 4) & 1;
io::read_c(&DATA[17+0], timeAlive);
  
    X = new Missile(field, level, x, y, vx, vy, ax, ay, timeAlive);
  
   X->ax = ax; 
 X->ay = ay; 
 X->xdir = xdir; 
 X->ydir = ydir; 
  
  return X;
  #undef DESTROY
}

bool INO_Missile::decodeUpdate(const std::vector<byte>& DATA, Missile* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float xdir;
float ydir;
unsigned level;
unsigned exploded;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
X->vx = vx;
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
X->vy = vy;
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
X->x = x;
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
X->y = y;
{signed short _ax;
    io::read_c(&DATA[8+0],_ax);
    ax=_ax*2.0e-6f/0x7FFF;
   }
X->ax = ax;
{signed short _ay;
    io::read_c(&DATA[10+0],_ay);
    ay=_ay*2.0e-6f/0x7FFF;
   }
X->ay = ay;
{signed short _xdir;
    io::read_c(&DATA[12+0],_xdir);
    xdir=_xdir*2.0e-6f/0x7FFF;
   }
X->xdir = xdir;
{signed short _ydir;
    io::read_c(&DATA[14+0],_ydir);
    ydir=_ydir*2.0e-6f/0x7FFF;
   }
X->ydir = ydir;
level = (DATA[16+0] >> 0) & 15;
 X->level = min(10u,max(1u,level)); 
exploded = (DATA[16+0] >> 4) & 1;

      if (exploded && !X->exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  return false;
  #undef DESTROY
}

ENO_Missile::ENO_Missile(NetworkConnection* cxn, Missile* obj)
: ExportedGameObject(18, cxn, obj, clone(obj, cxn))
  
      ,explListener((Missile*)local.ref, this)
    
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float xdir;
float ydir;
unsigned level;
unsigned exploded;
unsigned char timeAlive;
  
      timeAlive = X->timeAlive/12;
    
io::write_c(&DATA[17+0], timeAlive);
 exploded = X->exploded; 
DATA[16+0] &= ~(1<<4); DATA[16+0] |= (exploded & 1) << 4;
 level = X->level; 
DATA[16+0] &= ~(15<<0); DATA[16+0] |= (level & 15) << 0;
ydir = X->ydir;
{signed short _ydir = ydir/2.0e-6f*0x7FFF; io::write_c(&DATA[14+0],_ydir);}
xdir = X->xdir;
{signed short _xdir = xdir/2.0e-6f*0x7FFF; io::write_c(&DATA[12+0],_xdir);}
ay = X->ay;
{signed short _ay = ay/2.0e-6f*0x7FFF; io::write_c(&DATA[10+0],_ay);}
ax = X->ax;
{signed short _ax = ax/2.0e-6f*0x7FFF; io::write_c(&DATA[8+0],_ax);}
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef DATA
  #undef field
  #undef X
  dirty = true;
}

ENO_Missile::~ENO_Missile() {
  
}

void ENO_Missile::init() throw() {
  Missile*const X = (Missile*)local.ref;
  
}

Missile* ENO_Missile::clone(const Missile* src, NetworkConnection* cxn)
const throw() {
  #define X src
  #define field (&cxn->field)
  #define DESTROY(x) assert(!(x))
  #define LOCAL_CLONE
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float xdir;
float ydir;
unsigned level;
unsigned exploded;
unsigned char timeAlive;
  
      timeAlive = X->timeAlive/12;
    
 exploded = X->exploded; 
 level = X->level; 
ydir = X->ydir;
xdir = X->xdir;
ay = X->ay;
ax = X->ax;
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  Missile* dst;
  #define X dst
  
    X = new Missile(field, level, x, y, vx, vy, ax, ay, timeAlive);
  
   X->ax = ax; 
 X->ay = ay; 
 X->xdir = xdir; 
 X->ydir = ydir; 
  #undef LOCAL_CLONE
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_Missile::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
float ax;
float ay;
float xdir;
float ydir;
unsigned level;
unsigned exploded;
    S(const Missile* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
ax = X->ax;
ay = X->ay;
xdir = X->xdir;
ydir = X->ydir;
 level = X->level; 
 exploded = X->exploded; 
    }
  } x(static_cast<Missile*>(local.ref)), y(static_cast<Missile*>(remote));

  {float d=fabs(x.vx-y.vx)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.vy-y.vy)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.x-y.x)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.y-y.y)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.ax-y.ax)*1.0e6f;FAR+=d;NEAR+=d;}
{float d=fabs(x.ay-y.ay)*1.0e6f;FAR+=d;NEAR+=d;}
{float d=fabs(x.xdir-y.xdir)*0;FAR+=d;NEAR+=d;}
{float d=fabs(x.ydir-y.ydir)*0;FAR+=d;NEAR+=d;}

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR*FAR > l_dist && l_dist >= 5*5) || (NEAR > 1 && l_dist < 5*5);
}

void ENO_Missile::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  Missile* l_local = static_cast<Missile*>(this->local.ref);
  Missile* l_remote = static_cast<Missile*>(this->remote);
  float vx;
float vy;
float x;
float y;
float ax;
float ay;
float xdir;
float ydir;
unsigned level;
unsigned exploded;
  #define X l_local
   exploded = X->exploded; 
DATA[16+0] &= ~(1<<4); DATA[16+0] |= (exploded & 1) << 4;
 level = X->level; 
DATA[16+0] &= ~(15<<0); DATA[16+0] |= (level & 15) << 0;
ydir = X->ydir;
{signed short _ydir = ydir/2.0e-6f*0x7FFF; io::write_c(&DATA[14+0],_ydir);}
xdir = X->xdir;
{signed short _xdir = xdir/2.0e-6f*0x7FFF; io::write_c(&DATA[12+0],_xdir);}
ay = X->ay;
{signed short _ay = ay/2.0e-6f*0x7FFF; io::write_c(&DATA[10+0],_ay);}
ax = X->ax;
{signed short _ax = ax/2.0e-6f*0x7FFF; io::write_c(&DATA[8+0],_ax);}
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
X->ax = ax;
X->ay = ay;
X->xdir = xdir;
X->ydir = ydir;
 X->level = min(10u,max(1u,level)); 

      if (exploded && !X->exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}

      ENO_Missile::ExplListener::ExplListener(Missile* it, ENO_Missile* that_)
      : ExplodeListener<Missile>(it), that(that_) {}
    

INO_ParticleEmitter::INO_ParticleEmitter(NetworkConnection* cxn_)
: ImportedGameObject(20, cxn_),
  cxn(cxn_) 
{ }

INO_ParticleEmitter::~INO_ParticleEmitter() {
  
}

const NetworkConnection::geraet_num INO_ParticleEmitter::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_ParticleEmitter::create(NetworkConnection* cxn) throw() {
  return new INO_ParticleEmitter(cxn);
}

void INO_ParticleEmitter::construct() throw() {
  object = decodeConstruct(state);
}

void INO_ParticleEmitter::update() throw() {
  if (decodeUpdate(state, static_cast<ParticleEmitter*>(object)))
    destroy(false);
}

ParticleEmitter* INO_ParticleEmitter::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { if (x) delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  ParticleEmitter* X = NULL;
  float vx;
float vy;
float x;
float y;
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
type = (DATA[8+0] >> 0) & 3;
rmajor = (DATA[8+0] >> 2) & 7;
rminor = (DATA[8+0] >> 5) & 7;
io::read_c(&DATA[9+0], timeAlive);
memcpy(r, &DATA[11+0], 8);
io::read_c(&DATA[19+0], blame);
  
    X = new ParticleEmitter(field, (ParticleBeamType)type,
                            0xFFFFFF, //TODO: Translate to local blame
                            x, y, vx, vy,
                            r, rmajor, rminor,
                            timeAlive);
  
  
  
  return X;
  #undef DESTROY
}

bool INO_ParticleEmitter::decodeUpdate(const std::vector<byte>& DATA, ParticleEmitter* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
X->vx = vx;
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
X->vy = vy;
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
X->x = x;
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
X->y = y;
type = (DATA[8+0] >> 0) & 3;
rmajor = (DATA[8+0] >> 2) & 7;
X->rmajor = rmajor;
rminor = (DATA[8+0] >> 5) & 7;
X->rminor = rminor;
io::read_c(&DATA[9+0], timeAlive);
X->timeAlive = timeAlive;
memcpy(r, &DATA[11+0], 8);
  memcpy(X->r, r, sizeof(r)); 
io::read_c(&DATA[19+0], blame);
X->blame = blame;
  return false;
  #undef DESTROY
}

ENO_ParticleEmitter::ENO_ParticleEmitter(NetworkConnection* cxn, ParticleEmitter* obj)
: ExportedGameObject(20, cxn, obj, clone(obj, cxn))
  
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
  blame = X->blame;
io::write_c(&DATA[19+0], blame);
 memcpy(r, X->r, sizeof(r)); 
memcpy(&DATA[11+0], r, 8);
timeAlive = X->timeAlive;
io::write_c(&DATA[9+0], timeAlive);
rminor = X->rminor;
DATA[8+0] &= ~(7<<5); DATA[8+0] |= (rminor & 7) << 5;
rmajor = X->rmajor;
DATA[8+0] &= ~(7<<2); DATA[8+0] |= (rmajor & 7) << 2;
 type = (unsigned)X->type; 
DATA[8+0] &= ~(3<<0); DATA[8+0] |= (type & 3) << 0;
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef DATA
  #undef field
  #undef X
  dirty = true;
}

ENO_ParticleEmitter::~ENO_ParticleEmitter() {
  
}

void ENO_ParticleEmitter::init() throw() {
  ParticleEmitter*const X = (ParticleEmitter*)local.ref;
  
}

ParticleEmitter* ENO_ParticleEmitter::clone(const ParticleEmitter* src, NetworkConnection* cxn)
const throw() {
  #define X src
  #define field (&cxn->field)
  #define DESTROY(x) assert(!(x))
  #define LOCAL_CLONE
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
  blame = X->blame;
 memcpy(r, X->r, sizeof(r)); 
timeAlive = X->timeAlive;
rminor = X->rminor;
rmajor = X->rmajor;
 type = (unsigned)X->type; 
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  ParticleEmitter* dst;
  #define X dst
  
    X = new ParticleEmitter(field, (ParticleBeamType)type,
                            0xFFFFFF, //TODO: Translate to local blame
                            x, y, vx, vy,
                            r, rmajor, rminor,
                            timeAlive);
  
  
  #undef LOCAL_CLONE
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_ParticleEmitter::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
    S(const ParticleEmitter* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
 type = (unsigned)X->type; 
rmajor = X->rmajor;
rminor = X->rminor;
timeAlive = X->timeAlive;
 memcpy(r, X->r, sizeof(r)); 
blame = X->blame;
    }
  } x(static_cast<ParticleEmitter*>(local.ref)), y(static_cast<ParticleEmitter*>(remote));

  {float d=fabs(x.vx-y.vx)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.vy-y.vy)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.x-y.x)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.y-y.y)*128;FAR+=d;NEAR+=d;}
 return false; 
{float d=fabs(x.rmajor-y.rmajor)*0;FAR+=d;NEAR+=d;}
{float d=fabs(x.rminor-y.rminor)*0;FAR+=d;NEAR+=d;}
{float d=fabs(x.timeAlive-y.timeAlive)*0;FAR+=d;NEAR+=d;}
{float d=fabs(x.blame-y.blame)*0;FAR+=d;NEAR+=d;}

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR*FAR > l_dist && l_dist >= 5*5) || (NEAR > 1 && l_dist < 5*5);
}

void ENO_ParticleEmitter::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  ParticleEmitter* l_local = static_cast<ParticleEmitter*>(this->local.ref);
  ParticleEmitter* l_remote = static_cast<ParticleEmitter*>(this->remote);
  float vx;
float vy;
float x;
float y;
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
  #define X l_local
  blame = X->blame;
io::write_c(&DATA[19+0], blame);
 memcpy(r, X->r, sizeof(r)); 
memcpy(&DATA[11+0], r, 8);
timeAlive = X->timeAlive;
io::write_c(&DATA[9+0], timeAlive);
rminor = X->rminor;
DATA[8+0] &= ~(7<<5); DATA[8+0] |= (rminor & 7) << 5;
rmajor = X->rmajor;
DATA[8+0] &= ~(7<<2); DATA[8+0] |= (rmajor & 7) << 2;
 type = (unsigned)X->type; 
DATA[8+0] &= ~(3<<0); DATA[8+0] |= (type & 3) << 0;
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
X->rmajor = rmajor;
X->rminor = rminor;
X->timeAlive = timeAlive;
  memcpy(X->r, r, sizeof(r)); 
X->blame = blame;
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}


INO_MonophasicEnergyPulse::INO_MonophasicEnergyPulse(NetworkConnection* cxn_)
: ImportedGameObject(11, cxn_),
  cxn(cxn_) 
{ }

INO_MonophasicEnergyPulse::~INO_MonophasicEnergyPulse() {
  
}

const NetworkConnection::geraet_num INO_MonophasicEnergyPulse::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_MonophasicEnergyPulse::create(NetworkConnection* cxn) throw() {
  return new INO_MonophasicEnergyPulse(cxn);
}

void INO_MonophasicEnergyPulse::construct() throw() {
  object = decodeConstruct(state);
}

void INO_MonophasicEnergyPulse::update() throw() {
  if (decodeUpdate(state, static_cast<MonophasicEnergyPulse*>(object)))
    destroy(false);
}

MonophasicEnergyPulse* INO_MonophasicEnergyPulse::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { if (x) delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  MonophasicEnergyPulse* X = NULL;
  float vx;
float vy;
float x;
float y;
unsigned exploded;
unsigned power;
unsigned short timeAlive;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
exploded = (DATA[8+0] >> 0) & 1;
power = (DATA[8+0] >> 1) & 127;
io::read_c(&DATA[9+0], timeAlive);
  
    X = new MonophasicEnergyPulse(field, x, y, vx, vy, (float)power, timeAlive);
  
  
  
  return X;
  #undef DESTROY
}

bool INO_MonophasicEnergyPulse::decodeUpdate(const std::vector<byte>& DATA, MonophasicEnergyPulse* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
unsigned exploded;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
X->vx = vx;
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
X->vy = vy;
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
X->x = x;
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
X->y = y;
exploded = (DATA[8+0] >> 0) & 1;

      if (exploded && !X->exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  return false;
  #undef DESTROY
}

ENO_MonophasicEnergyPulse::ENO_MonophasicEnergyPulse(NetworkConnection* cxn, MonophasicEnergyPulse* obj)
: ExportedGameObject(11, cxn, obj, clone(obj, cxn))
  
      ,explListener((MonophasicEnergyPulse*)local.ref, this)
    
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
unsigned exploded;
unsigned power;
unsigned short timeAlive;
  timeAlive = X->timeAlive;
io::write_c(&DATA[9+0], timeAlive);
power = X->power;
DATA[8+0] &= ~(127<<1); DATA[8+0] |= (power & 127) << 1;
 exploded = X->exploded; 
DATA[8+0] &= ~(1<<0); DATA[8+0] |= (exploded & 1) << 0;
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef DATA
  #undef field
  #undef X
  dirty = true;
}

ENO_MonophasicEnergyPulse::~ENO_MonophasicEnergyPulse() {
  
}

void ENO_MonophasicEnergyPulse::init() throw() {
  MonophasicEnergyPulse*const X = (MonophasicEnergyPulse*)local.ref;
  
}

MonophasicEnergyPulse* ENO_MonophasicEnergyPulse::clone(const MonophasicEnergyPulse* src, NetworkConnection* cxn)
const throw() {
  #define X src
  #define field (&cxn->field)
  #define DESTROY(x) assert(!(x))
  #define LOCAL_CLONE
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
unsigned exploded;
unsigned power;
unsigned short timeAlive;
  timeAlive = X->timeAlive;
power = X->power;
 exploded = X->exploded; 
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  MonophasicEnergyPulse* dst;
  #define X dst
  
    X = new MonophasicEnergyPulse(field, x, y, vx, vy, (float)power, timeAlive);
  
  
  #undef LOCAL_CLONE
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_MonophasicEnergyPulse::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
unsigned exploded;
    S(const MonophasicEnergyPulse* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
 exploded = X->exploded; 
    }
  } x(static_cast<MonophasicEnergyPulse*>(local.ref)), y(static_cast<MonophasicEnergyPulse*>(remote));

  {float d=fabs(x.vx-y.vx)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.vy-y.vy)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.x-y.x)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.y-y.y)*128;FAR+=d;NEAR+=d;}

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR*FAR > l_dist && l_dist >= 5*5) || (NEAR > 1 && l_dist < 5*5);
}

void ENO_MonophasicEnergyPulse::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  MonophasicEnergyPulse* l_local = static_cast<MonophasicEnergyPulse*>(this->local.ref);
  MonophasicEnergyPulse* l_remote = static_cast<MonophasicEnergyPulse*>(this->remote);
  float vx;
float vy;
float x;
float y;
unsigned exploded;
  #define X l_local
   exploded = X->exploded; 
DATA[8+0] &= ~(1<<0); DATA[8+0] |= (exploded & 1) << 0;
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;

      if (exploded && !X->exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}

      ENO_MonophasicEnergyPulse::ExplListener::ExplListener(MonophasicEnergyPulse* it, ENO_MonophasicEnergyPulse* that_)
      : ExplodeListener<MonophasicEnergyPulse>(it), that(that_) {}
    

INO_Spectator::INO_Spectator(NetworkConnection* cxn_)
: ImportedGameObject(8, cxn_),
  cxn(cxn_) 
{ }

INO_Spectator::~INO_Spectator() {
  
}

const NetworkConnection::geraet_num INO_Spectator::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_Spectator::create(NetworkConnection* cxn) throw() {
  return new INO_Spectator(cxn);
}

void INO_Spectator::construct() throw() {
  object = decodeConstruct(state);
}

void INO_Spectator::update() throw() {
  if (decodeUpdate(state, static_cast<Spectator*>(object)))
    destroy(false);
}

Spectator* INO_Spectator::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { if (x) delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  Spectator* X = NULL;
  float vx;
float vy;
float x;
float y;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
  
    X = new Spectator(field, x, y, vx, vy);
  
  
   cxn->setReference(X); 
  return X;
  #undef DESTROY
}

bool INO_Spectator::decodeUpdate(const std::vector<byte>& DATA, Spectator* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
X->vx = vx;
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
X->vy = vy;
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
X->x = x;
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
X->y = y;
  return false;
  #undef DESTROY
}

ENO_Spectator::ENO_Spectator(NetworkConnection* cxn, Spectator* obj)
: ExportedGameObject(8, cxn, obj, clone(obj, cxn))
  
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
  y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef DATA
  #undef field
  #undef X
  dirty = true;
}

ENO_Spectator::~ENO_Spectator() {
  
}

void ENO_Spectator::init() throw() {
  Spectator*const X = (Spectator*)local.ref;
  
}

Spectator* ENO_Spectator::clone(const Spectator* src, NetworkConnection* cxn)
const throw() {
  #define X src
  #define field (&cxn->field)
  #define DESTROY(x) assert(!(x))
  #define LOCAL_CLONE
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
  y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  Spectator* dst;
  #define X dst
  
    X = new Spectator(field, x, y, vx, vy);
  
  
  #undef LOCAL_CLONE
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_Spectator::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
    S(const Spectator* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
    }
  } x(static_cast<Spectator*>(local.ref)), y(static_cast<Spectator*>(remote));

  {float d=fabs(x.vx-y.vx)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.vy-y.vy)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.x-y.x)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.y-y.y)*128;FAR+=d;NEAR+=d;}

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR*FAR > l_dist && l_dist >= 5*5) || (NEAR > 1 && l_dist < 5*5);
}

void ENO_Spectator::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  Spectator* l_local = static_cast<Spectator*>(this->local.ref);
  Spectator* l_remote = static_cast<Spectator*>(this->remote);
  float vx;
float vy;
float x;
float y;
  #define X l_local
  y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}



  #define SQUARE_CELL 0
  #define CIRCLE_CELL 1
  #define EQUT_CELL 2
  #define RIGHTT_CELL 3

  enum ShipSystemCode {
    SSCAntimatterPower=0,
    SSCCloakingDevice,
    SSCDispersionShield,
    SSCGatlingPlasmaBurstLauncher,
    SSCMissileLauncher,
    SSCMonophasicEnergyEmitter,
    SSCParticleBeamLauncher,
    SSCRelIonAccelerator,

    SSCBussardRamjet,
    SSCFusionPower,
    SSCHeatsink,
    SSCMiniGravwaveDriveMKII,
    SSCPlasmaBurstLauncher,
    SSCSemiguidedBombLauncher,
    SSCShieldGenerator,
    SSCSuperParticleAccelerator,

    SSCCapacitor,
    SSCEnergyChargeLauncher,
    SSCFissionPower,
    SSCMagnetoBombLauncher,
    SSCMiniGravwaveDrive,
    SSCParticleAccelerator,
    SSCPowerCell,
    SSCReinforcementBulkhead,
    SSCSelfDestructCharge
  };

  //Uses the SYS(name) macro to handle every known ship system type.
  #define HANDLE_SYSTEMS  SYS(AntimatterPower)  SYS(CloakingDevice)  SYS(DispersionShield)  SYS(GatlingPlasmaBurstLauncher)  SYS(MissileLauncher)  SYS(MonophasicEnergyEmitter)  SYS(ParticleBeamLauncher)  SYS(RelIonAccelerator)  SYS(BussardRamjet)  SYS(FusionPower)  SYS(Heatsink)  SYS(MiniGravwaveDriveMKII)  SYS(PlasmaBurstLauncher)  SYS(SemiguidedBombLauncher)  SYS(ShieldGenerator)  SYS(SuperParticleAccelerator)  SYS(Capacitor)  SYS(EnergyChargeLauncher)  SYS(FissionPower)  SYS(MagnetoBombLauncher)  SYS(MiniGravwaveDrive)  SYS(ParticleAccelerator)  SYS(PowerCell)  SYS(ReinforcementBulkhead)  SYS(SelfDestructCharge)

  #define SHGEN(ix) ((ix) < X->networkCells.size()?  getShieldGenerator(X->networkCells[(ix)]) : NULL)

  //ShipSystem constructor helper
  template<typename T>
  struct ShipSystemConstructor {
    inline
    static T* construct(Ship* ship, unsigned cellix, unsigned sysix,
                        unsigned capacitance, bool gatPlasmaTurbo,
                        float shieldRad, unsigned shieldStrength)
    throw() {
      return new T(ship);
    }
  };

  template<>
  struct ShipSystemConstructor<Capacitor> {
    inline
    static Capacitor* construct(Ship* ship, unsigned cellix, unsigned sysix,
                                unsigned capacitance, bool gatPlasmaTurbo,
                                float shieldRad, unsigned shieldStrength)
    throw() {
      return new Capacitor(ship, capacitance);
    }
  };

  template<>
  struct ShipSystemConstructor<GatlingPlasmaBurstLauncher> {
    inline static GatlingPlasmaBurstLauncher*
    construct(Ship* ship, unsigned cellix, unsigned sysix,
              unsigned capacitance, bool gatPlasmaTurbo,
              float shieldRad, unsigned shieldStrength)
    throw() {
      return new GatlingPlasmaBurstLauncher(ship, gatPlasmaTurbo);
    }
  };

  template<>
  struct ShipSystemConstructor<ShieldGenerator> {
    inline static ShieldGenerator*
    construct(Ship* ship, unsigned cellix, unsigned sysix,
              unsigned capacitance, bool gatPlasmaTurbo,
              float shieldRad, unsigned shieldStrength)
    throw() {
      return new ShieldGenerator(ship, shieldStrength, shieldRad);
    }
  };

INO_Ship::INO_Ship(NetworkConnection* cxn_)
: ImportedGameObject(80645, cxn_),
  cxn(cxn_) 
{ }

INO_Ship::~INO_Ship() {
  
}

const NetworkConnection::geraet_num INO_Ship::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_Ship::create(NetworkConnection* cxn) throw() {
  return new INO_Ship(cxn);
}

void INO_Ship::construct() throw() {
  object = decodeConstruct(state);
}

void INO_Ship::update() throw() {
  if (decodeUpdate(state, static_cast<Ship*>(object)))
    destroy(false);
}

Ship* INO_Ship::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { if (x) delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  Ship* X = NULL;
  float vx;
float vy;
float x;
float y;
float vtheta;
unsigned char theta;
char tag[128];
char target[128];
float colourR;
float colourG;
float colourB;
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
unsigned char neighboursBits03[16376];
unsigned char neighboursBits47[16376];
unsigned char neighboursBits8B[16376];
unsigned int neighbours[16376];
unsigned char cellType[4096];
 bool destruction; 
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    unsigned char orientation, type;
  } systemInfo[8188];
unsigned char capacitors[8188];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
bool gatPlasmaTurbo[4096];
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
{signed short _vtheta;
    io::read_c(&DATA[8+0],_vtheta);
    vtheta=_vtheta*32.0e-3f/0x7FFF;
   }
io::read_c(&DATA[10+0], theta);
strncpy(tag, (const char*)&DATA[11+0], 128-1); tag[128-1]=0;
strncpy(target, (const char*)&DATA[139+0], 128-1); target[128-1]=0;
io::read_c(&DATA[267+0], colourR);
if (colourR != colourR) colourR = 0;
 else if (colourR < 0) colourR = 0;
 else if (colourR > 1) colourR = 1;
io::read_c(&DATA[271+0], colourG);
if (colourG != colourG) colourG = 0;
 else if (colourG < 0) colourG = 0;
 else if (colourG > 1) colourG = 1;
io::read_c(&DATA[275+0], colourB);
if (colourB != colourB) colourB = 0;
 else if (colourB < 0) colourB = 0;
 else if (colourB > 1) colourB = 1;
io::read_c(&DATA[279+0], thrustPercent);
if (thrustPercent != thrustPercent) thrustPercent = 0;
 else if (thrustPercent < 0) thrustPercent = 0;
 else if (thrustPercent > 1) thrustPercent = 1;
io::read_c(&DATA[283+0], reinforcement);
if (reinforcement != reinforcement) reinforcement = 0;
 else if (reinforcement < 0) reinforcement = 0;
 else if (reinforcement > 32) reinforcement = 32;
io::read_c(&DATA[287+0], currentCapacitancePercent);
io::read_c(&DATA[288+0], insignia);
isFragment = (DATA[296+0] >> 0) & 1;
thrustOn = (DATA[296+0] >> 1) & 1;
brakeOn = (DATA[296+0] >> 2) & 1;
shieldsDeactivated = (DATA[296+0] >> 3) & 1;
stealthMode = (DATA[296+0] >> 4) & 1;
rootIsBridge = (DATA[296+0] >> 5) & 1;
io::read_c(&DATA[297+0], rootTheta);
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
neighboursBits03[0+ARRAY_OFFSET] = ((&DATA[0]+299+ARRAY_OFFSET*1/2)[0+0] >> 0) & 15;
neighboursBits03[1+ARRAY_OFFSET] = ((&DATA[0]+299+ARRAY_OFFSET*1/2)[0+0] >> 4) & 15;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
neighboursBits47[0+ARRAY_OFFSET] = ((&DATA[0]+8487+ARRAY_OFFSET*1/2)[0+0] >> 0) & 15;
neighboursBits47[1+ARRAY_OFFSET] = ((&DATA[0]+8487+ARRAY_OFFSET*1/2)[0+0] >> 4) & 15;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
neighboursBits8B[0+ARRAY_OFFSET] = ((&DATA[0]+16675+ARRAY_OFFSET*1/2)[0+0] >> 0) & 15;
neighboursBits8B[1+ARRAY_OFFSET] = ((&DATA[0]+16675+ARRAY_OFFSET*1/2)[0+0] >> 4) & 15;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=1) {

        neighbours[0+ARRAY_OFFSET] = (neighboursBits03[(0+ARRAY_OFFSET)] << 0)
             | (neighboursBits47[(0+ARRAY_OFFSET)] << 4)
             | (neighboursBits8B[(0+ARRAY_OFFSET)] << 8);
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=4) {
cellType[0+ARRAY_OFFSET] = ((&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] >> 0) & 3;
cellType[1+ARRAY_OFFSET] = ((&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] >> 2) & 3;
cellType[2+ARRAY_OFFSET] = ((&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] >> 4) & 3;
cellType[3+ARRAY_OFFSET] = ((&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] >> 6) & 3;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::read_c(&(&DATA[0]+25887+ARRAY_OFFSET*1/1)[0+0], cellDamage[0+ARRAY_OFFSET]);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {
systemExist[0+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 0) & 1;
systemExist[1+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 1) & 1;
systemExist[2+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 2) & 1;
systemExist[3+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 3) & 1;
systemExist[4+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 4) & 1;
systemExist[5+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 5) & 1;
systemExist[6+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 6) & 1;
systemExist[7+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 7) & 1;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {
systemInfo[0+ARRAY_OFFSET].orientation = ((&DATA[0]+31005+ARRAY_OFFSET*1/1)[0+0] >> 0) & 3;
systemInfo[0+ARRAY_OFFSET].type = ((&DATA[0]+31005+ARRAY_OFFSET*1/1)[0+0] >> 2) & 63;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {
io::read_c(&(&DATA[0]+39193+ARRAY_OFFSET*1/1)[0+0], capacitors[0+ARRAY_OFFSET]);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {

        capacitors[0+ARRAY_OFFSET] = min((unsigned char)CAPACITOR_MAX, max((unsigned char)1, capacitors[0+ARRAY_OFFSET]));
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::read_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[0+0], shields[0+ARRAY_OFFSET].radius);
io::read_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[4+0], shields[0+ARRAY_OFFSET].maxStrength);
io::read_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[5+0], shields[0+ARRAY_OFFSET].currStrengthPercent);
io::read_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[6+0], shields[0+ARRAY_OFFSET].currStability);
io::read_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[7+0], shields[0+ARRAY_OFFSET].currAlpha);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
if (shields[0+ARRAY_OFFSET].radius != shields[0+ARRAY_OFFSET].radius) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MIN_SHIELD_RAD;
 else if (shields[0+ARRAY_OFFSET].radius < STD_CELL_SZ*MIN_SHIELD_RAD) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MIN_SHIELD_RAD;
 else if (shields[0+ARRAY_OFFSET].radius > STD_CELL_SZ*MAX_SHIELD_RAD) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MAX_SHIELD_RAD;
 shields[0+ARRAY_OFFSET].maxStrength = min((byte)MAX_SHIELD_STR,
                                        max((byte)MIN_SHIELD_STR,
                                            shields[0+ARRAY_OFFSET].maxStrength));
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=8) {
gatPlasmaTurbo[0+ARRAY_OFFSET] = ((&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] >> 0) & 1;
gatPlasmaTurbo[1+ARRAY_OFFSET] = ((&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] >> 1) & 1;
gatPlasmaTurbo[2+ARRAY_OFFSET] = ((&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] >> 2) & 1;
gatPlasmaTurbo[3+ARRAY_OFFSET] = ((&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] >> 3) & 1;
gatPlasmaTurbo[4+ARRAY_OFFSET] = ((&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] >> 4) & 1;
gatPlasmaTurbo[5+ARRAY_OFFSET] = ((&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] >> 5) & 1;
gatPlasmaTurbo[6+ARRAY_OFFSET] = ((&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] >> 6) & 1;
gatPlasmaTurbo[7+ARRAY_OFFSET] = ((&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] >> 7) & 1;
}
  
    X = new Ship(field);
    //Set fields from GameObject
    X->x = x;
    X->y = y;
    X->vx = vx;
    X->vy = vy;
    X->isRemote = true;

    //Count the number of cell slots used
    //The last cell with non-zero health is the last index we must store,
    //so the length is one plus that index.
    unsigned cellCount = lenof(cellDamage);
    while (cellCount > 0 && !cellDamage[cellCount-1]) --cellCount;

    X->networkCells.resize(cellCount, NULL);

    if (!cellDamage[0]) {
      #ifdef DEBUG
      cerr << "Warning: Ignoring ship with nonexistent root." << endl;
      #endif
      DESTROY(true);
    }

    if (rootIsBridge && rootTheta != 0) {
      #ifdef DEBUG
      cerr << "Warning: Ignoring ship with rotated bridge." << endl;
      #endif
      DESTROY(true);
    }

    //Initialise living cells
    for (unsigned i = 0; i < cellCount; ++i) {
      if (cellDamage[i]) {
        Cell* c;
        switch (cellType[i]) {
          case SQUARE_CELL:
            c = new SquareCell(X);
            break;

          case CIRCLE_CELL:
            c = new CircleCell(X);
            break;

          case EQUT_CELL:
            c = new EquTCell(X);
            break;

          default: //RIGHTT_CELL
            assert(cellType[i] == RIGHTT_CELL);
            if (i == 0 && rootIsBridge) {
              #ifdef DEBUG
              cerr << "Warning: Attempt to make right triangle bridge." << endl;
              #endif
              DESTROY(true);
            }
            c = new RightTCell(X);
            break;
        }
        //Wait with applying damage until ready to do physics

        //Add cell to ship
        X->cells.push_back(c);
        X->networkCells[i] = c;
        c->netIndex = i;
        if (i == 0 && rootIsBridge)
          c->usage = CellBridge;
      }
    }

    //Link cells to each other
    for (unsigned i=0; i < cellCount; ++i) {
      if (cellDamage[i]) {
        unsigned numNeighbours = (cellType[i] <= CIRCLE_CELL? 4 : 3);
        for (unsigned n = 0; n < numNeighbours; ++n) {
          if (unsigned nix = neighbours[i*4+n]) {
            //There is a linkage to this neighbour
            Cell* neighbour;
            if (nix == 1) {
              //Special case: EmptyCell
              neighbour = new EmptyCell(X, X->networkCells[i]);
              X->cells.push_back(neighbour);
            } else if (nix-2 < cellCount) {
              //General case
              neighbour = X->networkCells[nix-2];
            } else {
              #ifdef DEBUG
              cerr << "Warning: Neighbour index out of bounds: " << (nix-2)
                   << endl;
              #endif
              neighbour = NULL;
            }

            if (!neighbour) {
              #ifdef DEBUG
              cerr << "Warning: Nonexistent neighbour." << endl;
              #endif
              DESTROY(true);
            }

            X->networkCells[i]->neighbours[n] = neighbour;
          }
        }
      }
    }

    //Verify that all cells have bidirectional linkage
    for (unsigned i=0; i < X->cells.size(); ++i) {
      Cell* c = X->cells[i];
      for (unsigned n=0; n < 4; ++n) {
        if (c->neighbours[n]) {
          Cell* d = c->neighbours[n];
          for (unsigned m = 0; m < 4; ++m) {
            if (d->neighbours[m] == c)
              goto nextN;
          }

          //Shouldn't get here if all linkage is valid
          #ifdef DEBUG
          cerr << "Warning: Ignoring ship with monodirectional linkage." <<endl;
          #endif
          DESTROY(true);
        }
        nextN:;
      }
    }

    //Orient the cells
    X->cells[0]->orient(rootTheta);

    //Add systems
    for (unsigned i=0; i<cellCount; ++i) if (cellDamage[i]) {
      if (i==0 && rootIsBridge) continue; //Bridge has no systems

      unsigned syscount = (cellType[i] <= CIRCLE_CELL? 2:1);
      for (unsigned s=0; s<syscount; ++s) if (systemExist[i*2+s]) {
        ShipSystem* ss;
        #define SYS(systype)  case (unsigned)SSC##systype:  ss = ShipSystemConstructor<systype>::construct(  X, i, s, capacitors[i*2+s], gatPlasmaTurbo[i],  shields[i].radius, shields[i].maxStrength);  break;
        switch (systemInfo[i*2+s].type) {
          HANDLE_SYSTEMS
          default:
            #ifdef DEBUG
            cerr << "Warning: Ignoring unknown ship system type: "
                 << systemInfo[i*2+s].type << endl;
            #endif
            continue;
        }
        #undef SYS

        assert(ss);

        //Add system to ship
        X->networkCells[i]->systems[s] = ss;
        ss->container = X->networkCells[i];

        //Configure system and ensure it is happy there
        const char* error;
        if ((error = ss->setOrientation(systemInfo[i*2+s].orientation))
        &&  !isFragment) {
          #ifdef DEBUG
          cerr << "Warning: Rejecting ship system with bad orientation: "
               << error << endl;
          #endif
          DESTROY(true);
        }
      }
    }

    //Ensure ship is valid
    if (const char* error = verify(X)) {
      #ifdef DEBUG
      cerr << "Warning: Discarding invalid ship: " << error << endl;
      #endif
      DESTROY(true);
    }

    //Register with SDG
    #ifndef LOCAL_CLONE
    X->shipDamageGeraet = cxn->sdg;
    cxn->sdg->addRemoteShip(X, inputChannel);
    #endif /* LOCAL_CLONE */
  
   X->vtheta = vtheta; 
 X->theta = theta/255.0f*pi*2 + vtheta*T; 

      X->cosTheta = cos(X->theta);
      X->sinTheta = sin(X->theta);
    
 if (!X->ignoreNetworkTag) X->tag = tag; 

      X->setColour(colourR, colourG, colourB);
    

      X->setReinforcement(reinforcement);
    

      X->insignia = insignia;
    

      if (isFragment) {
        X->isFragment = true;
      }
    

      X->setStealthMode(stealthMode);
    

      X->configureEngines(thrustOn, brakeOn, thrustPercent);
    
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStrength(shields[0+ARRAY_OFFSET].currStrengthPercent/255.0f *
                                   gen->getStrength());
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStability(shields[0+ARRAY_OFFSET].currStability/255.0f);
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldAlpha(shields[0+ARRAY_OFFSET].currAlpha/255.0f);
        }
      
}
   if (!X->isFragment) cxn->setReference(X); 
  return X;
  #undef DESTROY
}

bool INO_Ship::decodeUpdate(const std::vector<byte>& DATA, Ship* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
float vtheta;
unsigned char theta;
char tag[128];
char target[128];
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
 bool destruction; 
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
  {signed short _vx;
    io::read_c(&DATA[0+0],_vx);
    vx=_vx*32.0e-3f/0x7FFF;
   }
X->vx = vx;
{signed short _vy;
    io::read_c(&DATA[2+0],_vy);
    vy=_vy*32.0e-3f/0x7FFF;
   }
X->vy = vy;
{unsigned short _x;
    io::read_c(&DATA[4+0],_x);
    x=_x*128.0f/0xFFFF;
   }

      x = max(0.0f, min(field->width-0.0001f, x + T*vx));
    
X->x = x;
{unsigned short _y;
    io::read_c(&DATA[6+0],_y);
    y=_y*128.0f/0xFFFF;
   }

      y = max(0.0f, min(field->height-0.0001f, y + T*vy));
    
X->y = y;
{signed short _vtheta;
    io::read_c(&DATA[8+0],_vtheta);
    vtheta=_vtheta*32.0e-3f/0x7FFF;
   }
X->vtheta = vtheta;
io::read_c(&DATA[10+0], theta);
 X->theta = theta/255.0f*pi*2 + vtheta*T; 

      X->cosTheta = cos(X->theta);
      X->sinTheta = sin(X->theta);
    
strncpy(tag, (const char*)&DATA[11+0], 128-1); tag[128-1]=0;
 if (!X->ignoreNetworkTag) X->tag = tag; 
strncpy(target, (const char*)&DATA[139+0], 128-1); target[128-1]=0;

      if (target[0]) {
        //Stop immediately if no change
        if (X->target.ref
        &&  0 == strcmp(target, X->target.ref->tag.c_str()))
          goto targetFound;

        //Seacrh the field for such a ship
        {
          GameField::iterator it = field->begin(), end = field->end();
          for (; it != end; ++it) {
            GameObject* go = *it;
            if (go->getClassification() == GameObject::ClassShip) {
              Ship* s = (Ship*)go;
              if (s->hasPower()
              &&  Allies != getAlliance(X->insignia, s->insignia)
              &&  0 == strcmp(target, s->tag.c_str())) {
                //Found
                X->target.assign(s);
                goto targetFound;
              }
            }
          }
        }

        //Not found
        X->target.assign(NULL);

        targetFound:;
      } else {
        X->target.assign(NULL);
      }
    
io::read_c(&DATA[279+0], thrustPercent);
if (thrustPercent != thrustPercent) thrustPercent = 0;
 else if (thrustPercent < 0) thrustPercent = 0;
 else if (thrustPercent > 1) thrustPercent = 1;

io::read_c(&DATA[283+0], reinforcement);
if (reinforcement != reinforcement) reinforcement = 0;
 else if (reinforcement < 0) reinforcement = 0;
 else if (reinforcement > 32) reinforcement = 32;

io::read_c(&DATA[287+0], currentCapacitancePercent);

      X->physicsRequire(PHYS_SHIP_CAPAC_BIT);
      X->currentCapacitance=X->totalCapacitance*
                            currentCapacitancePercent/255.0f;
    
io::read_c(&DATA[288+0], insignia);
X->insignia = insignia;
isFragment = (DATA[296+0] >> 0) & 1;

      if (isFragment && !X->isFragment) {
        X->isFragment = true;
        cxn->unsetReference(X);
      }
    
thrustOn = (DATA[296+0] >> 1) & 1;

brakeOn = (DATA[296+0] >> 2) & 1;

shieldsDeactivated = (DATA[296+0] >> 3) & 1;

      if (shieldsDeactivated && X->shieldsDeactivated) {
        shield_deactivate(X);
        X->shieldsDeactivated=true;
        //Clear all cell power bits that have shields
        X->physicsRequire(PHYS_SHIP_SHIELD_INVENTORY_BIT);
        for (unsigned i=0; i<X->shields.size(); ++i)
          X->shields[i]->getParent()->physicsClear(PHYS_CELL_POWER_BITS
                                                  |PHYS_CELL_POWER_PROD_BITS);
        X->shields.clear();
      }
    
stealthMode = (DATA[296+0] >> 4) & 1;

      X->setStealthMode(stealthMode);
    
rootIsBridge = (DATA[296+0] >> 5) & 1;

      X->configureEngines(thrustOn, brakeOn, thrustPercent);
    
io::read_c(&DATA[297+0], rootTheta);
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::read_c(&(&DATA[0]+25887+ARRAY_OFFSET*1/1)[0+0], cellDamage[0+ARRAY_OFFSET]);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        if (!cellDamage[0+ARRAY_OFFSET] && !(0+ARRAY_OFFSET)) {
          //Illegal attempt to destroy root; ignore
          #ifdef DEBUG
          cerr << "Warning: Ignoring illegal attempt to destroy Ship root!"
               << endl;
          #endif
          DESTROY(true);
        }
        if (!cellDamage[0+ARRAY_OFFSET]) {
          destruction = true;
          X->physicsRequire(PHYS_SHIP_DS_INVENTORY_BIT
                           |PHYS_CELL_DS_NEAREST_BIT);
          //Delink the cell from its neighbours, spawning PlasmaFires
          //if appropriate.
          //Empty neighbours will cease to exist.
          for (unsigned n = 0; n < 4; ++n) {
            if (c->neighbours[n]) {
              if (c->neighbours[n]->isEmpty) {
                X->removeCell(c->neighbours[n]);
                delete c->neighbours[n];
              } else {
                unsigned ret = c->neighbours[n]->getNeighbour(c);
                EmptyCell* ec = new EmptyCell(X, c->neighbours[n]);
                c->neighbours[n]->neighbours[ret] = ec;
                X->cells.push_back(ec);
                if (highQuality && !isFragment)
                  field->add(new PlasmaFire(ec));
                X->physicsClear(PHYS_CELL_LOCATION_PROPERTIES_BITS
                               |PHYS_SHIP_COORDS_BITS);
              }
            }
          }

          //Spawn fragments if appropriate
          pair<float,float> coord = X->cellCoord(X, c);
          Blast blast(field, 0, coord.first, coord.second,
                      STD_CELL_SZ/2, c->getMaxDamage()-c->getCurrDamage(),
                      true, STD_CELL_SZ/16, false, true, false);
          CellFragment::spawn(c, &blast);

          //Destroy systems within cell
          if (c->systems[0]) c->systems[0]->destroy(0xFFFFFF);
          if (c->systems[1]) c->systems[1]->destroy(0xFFFFFF);
          //Remove cell from ship
          X->preremove(c);
          #ifndef AB_OPENGL_14
          if (X->renderer)
            X->renderer->cellRemoved(c);
          #endif
          X->removeCell(c);
          X->networkCells[(0+ARRAY_OFFSET)] = NULL;

          //Free
          delete c;

          if (X->cells.empty()) {
            #ifdef DEBUG
            cerr << "Warning: Discarding ship with no cells." << endl;
            #endif
            DESTROY(true);
          }
        } else {
          //Damage the cell by the appropriate amount
          float newdmg = 1.0f - cellDamage[0+ARRAY_OFFSET]/255.0f;
          newdmg *= c->getMaxDamage();
          float olddmg = c->getCurrDamage();
          if (newdmg > olddmg) {
            #ifndef NDEBUG
            bool intact =
            #endif
            c->applyDamage(newdmg-olddmg, 0xFFFFFF);
            assert(intact);
            X->cellDamaged(c);
          }
        }
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {
systemExist[0+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 0) & 1;
systemExist[1+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 1) & 1;
systemExist[2+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 2) & 1;
systemExist[3+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 3) & 1;
systemExist[4+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 4) & 1;
systemExist[5+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 5) & 1;
systemExist[6+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 6) & 1;
systemExist[7+ARRAY_OFFSET] = ((&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] >> 7) & 1;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[0+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[1+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[2+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[3+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[4+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[5+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[6+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[7+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::read_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[0+0], shields[0+ARRAY_OFFSET].radius);
io::read_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[4+0], shields[0+ARRAY_OFFSET].maxStrength);
io::read_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[5+0], shields[0+ARRAY_OFFSET].currStrengthPercent);
io::read_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[6+0], shields[0+ARRAY_OFFSET].currStability);
io::read_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[7+0], shields[0+ARRAY_OFFSET].currAlpha);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
if (shields[0+ARRAY_OFFSET].radius != shields[0+ARRAY_OFFSET].radius) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MIN_SHIELD_RAD;
 else if (shields[0+ARRAY_OFFSET].radius < STD_CELL_SZ*MIN_SHIELD_RAD) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MIN_SHIELD_RAD;
 else if (shields[0+ARRAY_OFFSET].radius > STD_CELL_SZ*MAX_SHIELD_RAD) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MAX_SHIELD_RAD;
 shields[0+ARRAY_OFFSET].maxStrength = min((byte)MAX_SHIELD_STR,
                                        max((byte)MIN_SHIELD_STR,
                                            shields[0+ARRAY_OFFSET].maxStrength));
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStrength(shields[0+ARRAY_OFFSET].currStrengthPercent/255.0f *
                                   gen->getStrength());
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStability(shields[0+ARRAY_OFFSET].currStability/255.0f);
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldAlpha(shields[0+ARRAY_OFFSET].currAlpha/255.0f);
        }
      
}
  return false;
  #undef DESTROY
}

ENO_Ship::ENO_Ship(NetworkConnection* cxn, Ship* obj)
: ExportedGameObject(80645, cxn, obj, clone(obj, cxn))
  
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
float vtheta;
unsigned char theta;
char tag[128];
char target[128];
float colourR;
float colourG;
float colourB;
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
unsigned char neighboursBits03[16376];
unsigned char neighboursBits47[16376];
unsigned char neighboursBits8B[16376];
unsigned int neighbours[16376];
unsigned char cellType[4096];
 bool destruction; 
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    unsigned char orientation, type;
  } systemInfo[8188];
unsigned char capacitors[8188];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
bool gatPlasmaTurbo[4096];
  
      if (X->networkCells.empty()) {
        for (unsigned i = 0; i < X->cells.size(); ++i) {
          if (!X->cells[i]->isEmpty) {
            X->cells[i]->netIndex = X->networkCells.size();
            const_cast<Ship*>(X)->networkCells.push_back(X->cells[i]);
          }
        }
      }
    
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=8) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(0+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = false;
        }
      }
    

      if ((1+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(1+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(1+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = false;
        }
      }
    

      if ((2+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(2+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(2+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = false;
        }
      }
    

      if ((3+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(3+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(3+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = false;
        }
      }
    

      if ((4+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(4+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(4+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = false;
        }
      }
    

      if ((5+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(5+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(5+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = false;
        }
      }
    

      if ((6+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(6+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(6+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = false;
        }
      }
    

      if ((7+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(7+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(7+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = false;
        }
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=8) {
(&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<0); (&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] |= (gatPlasmaTurbo[0+ARRAY_OFFSET] & 1) << 0;
(&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<1); (&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] |= (gatPlasmaTurbo[1+ARRAY_OFFSET] & 1) << 1;
(&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<2); (&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] |= (gatPlasmaTurbo[2+ARRAY_OFFSET] & 1) << 2;
(&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<3); (&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] |= (gatPlasmaTurbo[3+ARRAY_OFFSET] & 1) << 3;
(&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<4); (&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] |= (gatPlasmaTurbo[4+ARRAY_OFFSET] & 1) << 4;
(&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<5); (&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] |= (gatPlasmaTurbo[5+ARRAY_OFFSET] & 1) << 5;
(&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<6); (&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] |= (gatPlasmaTurbo[6+ARRAY_OFFSET] & 1) << 6;
(&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<7); (&DATA[0]+80133+ARRAY_OFFSET*1/8)[0+0] |= (gatPlasmaTurbo[7+ARRAY_OFFSET] & 1) << 7;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].radius = gen->getRadius();
          else
            shields[0+ARRAY_OFFSET].radius = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].maxStrength = (byte)gen->getStrength();
          else
            shields[0+ARRAY_OFFSET].maxStrength = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStrengthPercent =
              (byte)(255*min(1.0f,gen->getShieldStrength())/gen->getStrength());
          else
            shields[0+ARRAY_OFFSET].currStrengthPercent = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStability =
                (byte)(255.0f*min(1.0f,gen->getShieldStability()));
          else
            shields[0+ARRAY_OFFSET].currStability = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currAlpha = (byte)(255.0f * max(0.0f,gen->getShieldAlpha()));
          else
            shields[0+ARRAY_OFFSET].currAlpha = 0;
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::write_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[0+0], shields[0+ARRAY_OFFSET].radius);
io::write_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[4+0], shields[0+ARRAY_OFFSET].maxStrength);
io::write_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[5+0], shields[0+ARRAY_OFFSET].currStrengthPercent);
io::write_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[6+0], shields[0+ARRAY_OFFSET].currStability);
io::write_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[7+0], shields[0+ARRAY_OFFSET].currAlpha);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
          if (cellix < X->networkCells.size()
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]
          &&  typeid(*X->networkCells[cellix]->systems[sysix]) ==
              typeid(Capacitor))
            capacitors[0+ARRAY_OFFSET] = ((Capacitor*)X->networkCells[cellix]->systems[sysix])->
                   getCapacity();
          else
            capacitors[0+ARRAY_OFFSET] = 0;
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {
io::write_c(&(&DATA[0]+39193+ARRAY_OFFSET*1/1)[0+0], capacitors[0+ARRAY_OFFSET]);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {

        unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
        if (cellix < X->networkCells.size()
        &&  X->networkCells[cellix]
        &&  X->networkCells[cellix]->systems[sysix]) {
          systemInfo[0+ARRAY_OFFSET].orientation =
            X->networkCells[cellix]->systems[sysix]->getOrientation();
        } else {
          systemInfo[0+ARRAY_OFFSET].orientation = 0;
        }
      

        {
          #define SYS(clazz)  if (typeid(*sys) == typeid(clazz))  systemInfo[0+ARRAY_OFFSET].type = (unsigned char)SSC##clazz;  else

          unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
          if (cellix < X->networkCells.size()
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            ShipSystem*const sys = X->networkCells[cellix]->systems[sysix];
            HANDLE_SYSTEMS
            /* else */ {
              cerr << "FATAL: Unexpected ShipSystem type: "
                  << typeid(*sys).name() << endl;
              exit(EXIT_PROGRAM_BUG);
            }
          } else {
            systemInfo[0+ARRAY_OFFSET].type = 0;
          }

          #undef SYS
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {
(&DATA[0]+31005+ARRAY_OFFSET*1/1)[0+0] &= ~(3<<0); (&DATA[0]+31005+ARRAY_OFFSET*1/1)[0+0] |= (systemInfo[0+ARRAY_OFFSET].orientation & 3) << 0;
(&DATA[0]+31005+ARRAY_OFFSET*1/1)[0+0] &= ~(63<<2); (&DATA[0]+31005+ARRAY_OFFSET*1/1)[0+0] |= (systemInfo[0+ARRAY_OFFSET].type & 63) << 2;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          systemExist[0+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          systemExist[1+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          systemExist[2+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          systemExist[3+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          systemExist[4+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          systemExist[5+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          systemExist[6+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          systemExist[7+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<0); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[0+ARRAY_OFFSET] & 1) << 0;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<1); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[1+ARRAY_OFFSET] & 1) << 1;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<2); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[2+ARRAY_OFFSET] & 1) << 2;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<3); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[3+ARRAY_OFFSET] & 1) << 3;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<4); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[4+ARRAY_OFFSET] & 1) << 4;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<5); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[5+ARRAY_OFFSET] & 1) << 5;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<6); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[6+ARRAY_OFFSET] & 1) << 6;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<7); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[7+ARRAY_OFFSET] & 1) << 7;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        cellDamage[0+ARRAY_OFFSET] = max((byte)1,
                   (byte)(255 - 255*c->getCurrDamage()/c->getMaxDamage()));
      } else {
        cellDamage[0+ARRAY_OFFSET] = 0; //Nonexistent
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::write_c(&(&DATA[0]+25887+ARRAY_OFFSET*1/1)[0+0], cellDamage[0+ARRAY_OFFSET]);
}
 destruction = false; 
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=4) {

      if (X->networkCells.size() > (0+ARRAY_OFFSET) && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(0+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[0+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[0+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[0+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[0+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      } else {
        cellType[0+ARRAY_OFFSET] = 0;
      }
    

      if (X->networkCells.size() > (1+ARRAY_OFFSET) && X->networkCells[(1+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(1+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[1+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[1+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[1+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[1+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      } else {
        cellType[1+ARRAY_OFFSET] = 0;
      }
    

      if (X->networkCells.size() > (2+ARRAY_OFFSET) && X->networkCells[(2+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(2+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[2+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[2+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[2+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[2+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      } else {
        cellType[2+ARRAY_OFFSET] = 0;
      }
    

      if (X->networkCells.size() > (3+ARRAY_OFFSET) && X->networkCells[(3+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(3+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[3+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[3+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[3+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[3+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      } else {
        cellType[3+ARRAY_OFFSET] = 0;
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=4) {
(&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] &= ~(3<<0); (&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] |= (cellType[0+ARRAY_OFFSET] & 3) << 0;
(&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] &= ~(3<<2); (&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] |= (cellType[1+ARRAY_OFFSET] & 3) << 2;
(&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] &= ~(3<<4); (&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] |= (cellType[2+ARRAY_OFFSET] & 3) << 4;
(&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] &= ~(3<<6); (&DATA[0]+24863+ARRAY_OFFSET*1/4)[0+0] |= (cellType[3+ARRAY_OFFSET] & 3) << 6;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=1) {

        {
          const unsigned neigh = (0+ARRAY_OFFSET)&3;
          const unsigned cellix = (0+ARRAY_OFFSET)>>2;
          if (X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->neighbours[neigh]) {
            //Exists, but EmptyCells are encoded specially
            if (X->networkCells[cellix]->neighbours[neigh]->isEmpty) {
              //Special value: 1
              neighbours[0+ARRAY_OFFSET] = 1;
            } else {
              //Generic
              neighbours[0+ARRAY_OFFSET] = 2 + X->networkCells[cellix]->neighbours[neigh]->netIndex;
            }
          } else {
            //Nonexistent
            neighbours[0+ARRAY_OFFSET] = 0;
          }
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=1) {

        neighboursBits03[(0+ARRAY_OFFSET)] = neighbours[0+ARRAY_OFFSET] & 15;
        neighboursBits47[(0+ARRAY_OFFSET)] = (neighbours[0+ARRAY_OFFSET] >> 4) & 15;
        neighboursBits8B[(0+ARRAY_OFFSET)] = neighbours[0+ARRAY_OFFSET] >> 8;
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
(&DATA[0]+16675+ARRAY_OFFSET*1/2)[0+0] &= ~(15<<0); (&DATA[0]+16675+ARRAY_OFFSET*1/2)[0+0] |= (neighboursBits8B[0+ARRAY_OFFSET] & 15) << 0;
(&DATA[0]+16675+ARRAY_OFFSET*1/2)[0+0] &= ~(15<<4); (&DATA[0]+16675+ARRAY_OFFSET*1/2)[0+0] |= (neighboursBits8B[1+ARRAY_OFFSET] & 15) << 4;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
(&DATA[0]+8487+ARRAY_OFFSET*1/2)[0+0] &= ~(15<<0); (&DATA[0]+8487+ARRAY_OFFSET*1/2)[0+0] |= (neighboursBits47[0+ARRAY_OFFSET] & 15) << 0;
(&DATA[0]+8487+ARRAY_OFFSET*1/2)[0+0] &= ~(15<<4); (&DATA[0]+8487+ARRAY_OFFSET*1/2)[0+0] |= (neighboursBits47[1+ARRAY_OFFSET] & 15) << 4;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
(&DATA[0]+299+ARRAY_OFFSET*1/2)[0+0] &= ~(15<<0); (&DATA[0]+299+ARRAY_OFFSET*1/2)[0+0] |= (neighboursBits03[0+ARRAY_OFFSET] & 15) << 0;
(&DATA[0]+299+ARRAY_OFFSET*1/2)[0+0] &= ~(15<<4); (&DATA[0]+299+ARRAY_OFFSET*1/2)[0+0] |= (neighboursBits03[1+ARRAY_OFFSET] & 15) << 4;
}

      rootTheta = X->cells[0]->getT();
    
io::write_c(&DATA[297+0], rootTheta);

      rootIsBridge = (X->cells[0]->usage == CellBridge);
    
DATA[296+0] &= ~(1<<5); DATA[296+0] |= (rootIsBridge & 1) << 5;
stealthMode = X->stealthMode;
DATA[296+0] &= ~(1<<4); DATA[296+0] |= (stealthMode & 1) << 4;
shieldsDeactivated = X->shieldsDeactivated;
DATA[296+0] &= ~(1<<3); DATA[296+0] |= (shieldsDeactivated & 1) << 3;
brakeOn = X->brakeOn;
DATA[296+0] &= ~(1<<2); DATA[296+0] |= (brakeOn & 1) << 2;
thrustOn = X->thrustOn;
DATA[296+0] &= ~(1<<1); DATA[296+0] |= (thrustOn & 1) << 1;

      isFragment = X->isFragment;
    
DATA[296+0] &= ~(1<<0); DATA[296+0] |= (isFragment & 1) << 0;
insignia = X->insignia;
io::write_c(&DATA[288+0], insignia);

      currentCapacitancePercent = 255*X->getCapacitancePercent();
    
io::write_c(&DATA[287+0], currentCapacitancePercent);
reinforcement = X->reinforcement;
io::write_c(&DATA[283+0], reinforcement);
thrustPercent = X->thrustPercent;
io::write_c(&DATA[279+0], thrustPercent);
colourB = X->colourB;
io::write_c(&DATA[275+0], colourB);
colourG = X->colourG;
io::write_c(&DATA[271+0], colourG);
colourR = X->colourR;
io::write_c(&DATA[267+0], colourR);

      if (X->target.ref)
        strncpy(target, X->target.ref->tag.c_str(), 128);
      else
        memset(target, 0, sizeof(target));
    
strncpy((char*)&DATA[139+0], target, 128);
 strncpy(tag, X->tag.c_str(), sizeof(tag)); 
strncpy((char*)&DATA[11+0], tag, 128);
 theta = (byte)(X->theta*255.0f/pi/2); 
io::write_c(&DATA[10+0], theta);
vtheta = X->vtheta;
{signed short _vtheta = vtheta/32.0e-3f*0x7FFF; io::write_c(&DATA[8+0],_vtheta);}
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef DATA
  #undef field
  #undef X
  dirty = true;
}

ENO_Ship::~ENO_Ship() {
  
      cxn->sdg->delLocalShip(channel);
    
}

void ENO_Ship::init() throw() {
  Ship*const X = (Ship*)local.ref;
  
      cxn->sdg->addLocalShip(channel, X);
    
}

Ship* ENO_Ship::clone(const Ship* src, NetworkConnection* cxn)
const throw() {
  #define X src
  #define field (&cxn->field)
  #define DESTROY(x) assert(!(x))
  #define LOCAL_CLONE
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
float vtheta;
unsigned char theta;
char tag[128];
char target[128];
float colourR;
float colourG;
float colourB;
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
unsigned char neighboursBits03[16376];
unsigned char neighboursBits47[16376];
unsigned char neighboursBits8B[16376];
unsigned int neighbours[16376];
unsigned char cellType[4096];
 bool destruction; 
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    unsigned char orientation, type;
  } systemInfo[8188];
unsigned char capacitors[8188];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
bool gatPlasmaTurbo[4096];
  
      if (X->networkCells.empty()) {
        for (unsigned i = 0; i < X->cells.size(); ++i) {
          if (!X->cells[i]->isEmpty) {
            X->cells[i]->netIndex = X->networkCells.size();
            const_cast<Ship*>(X)->networkCells.push_back(X->cells[i]);
          }
        }
      }
    
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=8) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(0+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = false;
        }
      }
    

      if ((1+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(1+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(1+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = false;
        }
      }
    

      if ((2+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(2+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(2+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = false;
        }
      }
    

      if ((3+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(3+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(3+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = false;
        }
      }
    

      if ((4+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(4+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(4+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = false;
        }
      }
    

      if ((5+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(5+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(5+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = false;
        }
      }
    

      if ((6+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(6+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(6+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = false;
        }
      }
    

      if ((7+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(7+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(7+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = false;
        }
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].radius = gen->getRadius();
          else
            shields[0+ARRAY_OFFSET].radius = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].maxStrength = (byte)gen->getStrength();
          else
            shields[0+ARRAY_OFFSET].maxStrength = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStrengthPercent =
              (byte)(255*min(1.0f,gen->getShieldStrength())/gen->getStrength());
          else
            shields[0+ARRAY_OFFSET].currStrengthPercent = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStability =
                (byte)(255.0f*min(1.0f,gen->getShieldStability()));
          else
            shields[0+ARRAY_OFFSET].currStability = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currAlpha = (byte)(255.0f * max(0.0f,gen->getShieldAlpha()));
          else
            shields[0+ARRAY_OFFSET].currAlpha = 0;
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
          if (cellix < X->networkCells.size()
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]
          &&  typeid(*X->networkCells[cellix]->systems[sysix]) ==
              typeid(Capacitor))
            capacitors[0+ARRAY_OFFSET] = ((Capacitor*)X->networkCells[cellix]->systems[sysix])->
                   getCapacity();
          else
            capacitors[0+ARRAY_OFFSET] = 0;
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {

        unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
        if (cellix < X->networkCells.size()
        &&  X->networkCells[cellix]
        &&  X->networkCells[cellix]->systems[sysix]) {
          systemInfo[0+ARRAY_OFFSET].orientation =
            X->networkCells[cellix]->systems[sysix]->getOrientation();
        } else {
          systemInfo[0+ARRAY_OFFSET].orientation = 0;
        }
      

        {
          #define SYS(clazz)  if (typeid(*sys) == typeid(clazz))  systemInfo[0+ARRAY_OFFSET].type = (unsigned char)SSC##clazz;  else

          unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
          if (cellix < X->networkCells.size()
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            ShipSystem*const sys = X->networkCells[cellix]->systems[sysix];
            HANDLE_SYSTEMS
            /* else */ {
              cerr << "FATAL: Unexpected ShipSystem type: "
                  << typeid(*sys).name() << endl;
              exit(EXIT_PROGRAM_BUG);
            }
          } else {
            systemInfo[0+ARRAY_OFFSET].type = 0;
          }

          #undef SYS
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          systemExist[0+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          systemExist[1+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          systemExist[2+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          systemExist[3+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          systemExist[4+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          systemExist[5+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          systemExist[6+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          systemExist[7+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        cellDamage[0+ARRAY_OFFSET] = max((byte)1,
                   (byte)(255 - 255*c->getCurrDamage()/c->getMaxDamage()));
      } else {
        cellDamage[0+ARRAY_OFFSET] = 0; //Nonexistent
      }
    
}
 destruction = false; 
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=4) {

      if (X->networkCells.size() > (0+ARRAY_OFFSET) && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(0+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[0+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[0+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[0+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[0+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      } else {
        cellType[0+ARRAY_OFFSET] = 0;
      }
    

      if (X->networkCells.size() > (1+ARRAY_OFFSET) && X->networkCells[(1+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(1+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[1+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[1+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[1+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[1+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      } else {
        cellType[1+ARRAY_OFFSET] = 0;
      }
    

      if (X->networkCells.size() > (2+ARRAY_OFFSET) && X->networkCells[(2+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(2+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[2+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[2+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[2+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[2+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      } else {
        cellType[2+ARRAY_OFFSET] = 0;
      }
    

      if (X->networkCells.size() > (3+ARRAY_OFFSET) && X->networkCells[(3+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(3+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[3+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[3+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[3+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[3+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      } else {
        cellType[3+ARRAY_OFFSET] = 0;
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=1) {

        {
          const unsigned neigh = (0+ARRAY_OFFSET)&3;
          const unsigned cellix = (0+ARRAY_OFFSET)>>2;
          if (X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->neighbours[neigh]) {
            //Exists, but EmptyCells are encoded specially
            if (X->networkCells[cellix]->neighbours[neigh]->isEmpty) {
              //Special value: 1
              neighbours[0+ARRAY_OFFSET] = 1;
            } else {
              //Generic
              neighbours[0+ARRAY_OFFSET] = 2 + X->networkCells[cellix]->neighbours[neigh]->netIndex;
            }
          } else {
            //Nonexistent
            neighbours[0+ARRAY_OFFSET] = 0;
          }
        }
      
}

      rootTheta = X->cells[0]->getT();
    

      rootIsBridge = (X->cells[0]->usage == CellBridge);
    
stealthMode = X->stealthMode;
shieldsDeactivated = X->shieldsDeactivated;
brakeOn = X->brakeOn;
thrustOn = X->thrustOn;

      isFragment = X->isFragment;
    
insignia = X->insignia;

      currentCapacitancePercent = 255*X->getCapacitancePercent();
    
reinforcement = X->reinforcement;
thrustPercent = X->thrustPercent;
colourB = X->colourB;
colourG = X->colourG;
colourR = X->colourR;

      if (X->target.ref)
        strncpy(target, X->target.ref->tag.c_str(), 128);
      else
        memset(target, 0, sizeof(target));
    
 strncpy(tag, X->tag.c_str(), sizeof(tag)); 
 theta = (byte)(X->theta*255.0f/pi/2); 
vtheta = X->vtheta;
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  Ship* dst;
  #define X dst
  
    X = new Ship(field);
    //Set fields from GameObject
    X->x = x;
    X->y = y;
    X->vx = vx;
    X->vy = vy;
    X->isRemote = true;

    //Count the number of cell slots used
    //The last cell with non-zero health is the last index we must store,
    //so the length is one plus that index.
    unsigned cellCount = lenof(cellDamage);
    while (cellCount > 0 && !cellDamage[cellCount-1]) --cellCount;

    X->networkCells.resize(cellCount, NULL);

    if (!cellDamage[0]) {
      #ifdef DEBUG
      cerr << "Warning: Ignoring ship with nonexistent root." << endl;
      #endif
      DESTROY(true);
    }

    if (rootIsBridge && rootTheta != 0) {
      #ifdef DEBUG
      cerr << "Warning: Ignoring ship with rotated bridge." << endl;
      #endif
      DESTROY(true);
    }

    //Initialise living cells
    for (unsigned i = 0; i < cellCount; ++i) {
      if (cellDamage[i]) {
        Cell* c;
        switch (cellType[i]) {
          case SQUARE_CELL:
            c = new SquareCell(X);
            break;

          case CIRCLE_CELL:
            c = new CircleCell(X);
            break;

          case EQUT_CELL:
            c = new EquTCell(X);
            break;

          default: //RIGHTT_CELL
            assert(cellType[i] == RIGHTT_CELL);
            if (i == 0 && rootIsBridge) {
              #ifdef DEBUG
              cerr << "Warning: Attempt to make right triangle bridge." << endl;
              #endif
              DESTROY(true);
            }
            c = new RightTCell(X);
            break;
        }
        //Wait with applying damage until ready to do physics

        //Add cell to ship
        X->cells.push_back(c);
        X->networkCells[i] = c;
        c->netIndex = i;
        if (i == 0 && rootIsBridge)
          c->usage = CellBridge;
      }
    }

    //Link cells to each other
    for (unsigned i=0; i < cellCount; ++i) {
      if (cellDamage[i]) {
        unsigned numNeighbours = (cellType[i] <= CIRCLE_CELL? 4 : 3);
        for (unsigned n = 0; n < numNeighbours; ++n) {
          if (unsigned nix = neighbours[i*4+n]) {
            //There is a linkage to this neighbour
            Cell* neighbour;
            if (nix == 1) {
              //Special case: EmptyCell
              neighbour = new EmptyCell(X, X->networkCells[i]);
              X->cells.push_back(neighbour);
            } else if (nix-2 < cellCount) {
              //General case
              neighbour = X->networkCells[nix-2];
            } else {
              #ifdef DEBUG
              cerr << "Warning: Neighbour index out of bounds: " << (nix-2)
                   << endl;
              #endif
              neighbour = NULL;
            }

            if (!neighbour) {
              #ifdef DEBUG
              cerr << "Warning: Nonexistent neighbour." << endl;
              #endif
              DESTROY(true);
            }

            X->networkCells[i]->neighbours[n] = neighbour;
          }
        }
      }
    }

    //Verify that all cells have bidirectional linkage
    for (unsigned i=0; i < X->cells.size(); ++i) {
      Cell* c = X->cells[i];
      for (unsigned n=0; n < 4; ++n) {
        if (c->neighbours[n]) {
          Cell* d = c->neighbours[n];
          for (unsigned m = 0; m < 4; ++m) {
            if (d->neighbours[m] == c)
              goto nextN;
          }

          //Shouldn't get here if all linkage is valid
          #ifdef DEBUG
          cerr << "Warning: Ignoring ship with monodirectional linkage." <<endl;
          #endif
          DESTROY(true);
        }
        nextN:;
      }
    }

    //Orient the cells
    X->cells[0]->orient(rootTheta);

    //Add systems
    for (unsigned i=0; i<cellCount; ++i) if (cellDamage[i]) {
      if (i==0 && rootIsBridge) continue; //Bridge has no systems

      unsigned syscount = (cellType[i] <= CIRCLE_CELL? 2:1);
      for (unsigned s=0; s<syscount; ++s) if (systemExist[i*2+s]) {
        ShipSystem* ss;
        #define SYS(systype)  case (unsigned)SSC##systype:  ss = ShipSystemConstructor<systype>::construct(  X, i, s, capacitors[i*2+s], gatPlasmaTurbo[i],  shields[i].radius, shields[i].maxStrength);  break;
        switch (systemInfo[i*2+s].type) {
          HANDLE_SYSTEMS
          default:
            #ifdef DEBUG
            cerr << "Warning: Ignoring unknown ship system type: "
                 << systemInfo[i*2+s].type << endl;
            #endif
            continue;
        }
        #undef SYS

        assert(ss);

        //Add system to ship
        X->networkCells[i]->systems[s] = ss;
        ss->container = X->networkCells[i];

        //Configure system and ensure it is happy there
        const char* error;
        if ((error = ss->setOrientation(systemInfo[i*2+s].orientation))
        &&  !isFragment) {
          #ifdef DEBUG
          cerr << "Warning: Rejecting ship system with bad orientation: "
               << error << endl;
          #endif
          DESTROY(true);
        }
      }
    }

    //Ensure ship is valid
    if (const char* error = verify(X)) {
      #ifdef DEBUG
      cerr << "Warning: Discarding invalid ship: " << error << endl;
      #endif
      DESTROY(true);
    }

    //Register with SDG
    #ifndef LOCAL_CLONE
    X->shipDamageGeraet = cxn->sdg;
    cxn->sdg->addRemoteShip(X, inputChannel);
    #endif /* LOCAL_CLONE */
  
   X->vtheta = vtheta; 
 X->theta = theta/255.0f*pi*2 + vtheta*T; 

      X->cosTheta = cos(X->theta);
      X->sinTheta = sin(X->theta);
    
 if (!X->ignoreNetworkTag) X->tag = tag; 

      X->setColour(colourR, colourG, colourB);
    

      X->setReinforcement(reinforcement);
    

      X->insignia = insignia;
    

      if (isFragment) {
        X->isFragment = true;
      }
    

      X->setStealthMode(stealthMode);
    

      X->configureEngines(thrustOn, brakeOn, thrustPercent);
    
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStrength(shields[0+ARRAY_OFFSET].currStrengthPercent/255.0f *
                                   gen->getStrength());
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStability(shields[0+ARRAY_OFFSET].currStability/255.0f);
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldAlpha(shields[0+ARRAY_OFFSET].currAlpha/255.0f);
        }
      
}
  #undef LOCAL_CLONE
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_Ship::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
float vtheta;
unsigned char theta;
char tag[128];
char target[128];
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
 bool destruction; 
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
    S(const Ship* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
vtheta = X->vtheta;
 theta = (byte)(X->theta*255.0f/pi/2); 
 strncpy(tag, X->tag.c_str(), sizeof(tag)); 

      if (X->target.ref)
        strncpy(target, X->target.ref->tag.c_str(), 128);
      else
        memset(target, 0, sizeof(target));
    
thrustPercent = X->thrustPercent;
reinforcement = X->reinforcement;

      currentCapacitancePercent = 255*X->getCapacitancePercent();
    
insignia = X->insignia;

      isFragment = X->isFragment;
    
thrustOn = X->thrustOn;
brakeOn = X->brakeOn;
shieldsDeactivated = X->shieldsDeactivated;
stealthMode = X->stealthMode;

      rootIsBridge = (X->cells[0]->usage == CellBridge);
    

      rootTheta = X->cells[0]->getT();
    
 destruction = false; 
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        cellDamage[0+ARRAY_OFFSET] = max((byte)1,
                   (byte)(255 - 255*c->getCurrDamage()/c->getMaxDamage()));
      } else {
        cellDamage[0+ARRAY_OFFSET] = 0; //Nonexistent
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          systemExist[0+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          systemExist[1+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          systemExist[2+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          systemExist[3+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          systemExist[4+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          systemExist[5+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          systemExist[6+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          systemExist[7+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].radius = gen->getRadius();
          else
            shields[0+ARRAY_OFFSET].radius = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].maxStrength = (byte)gen->getStrength();
          else
            shields[0+ARRAY_OFFSET].maxStrength = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStrengthPercent =
              (byte)(255*min(1.0f,gen->getShieldStrength())/gen->getStrength());
          else
            shields[0+ARRAY_OFFSET].currStrengthPercent = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStability =
                (byte)(255.0f*min(1.0f,gen->getShieldStability()));
          else
            shields[0+ARRAY_OFFSET].currStability = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currAlpha = (byte)(255.0f * max(0.0f,gen->getShieldAlpha()));
          else
            shields[0+ARRAY_OFFSET].currAlpha = 0;
        }
      
}

      if (X->networkCells.empty()) {
        for (unsigned i = 0; i < X->cells.size(); ++i) {
          if (!X->cells[i]->isEmpty) {
            X->cells[i]->netIndex = X->networkCells.size();
            const_cast<Ship*>(X)->networkCells.push_back(X->cells[i]);
          }
        }
      }
    
    }
  } x(static_cast<Ship*>(local.ref)), y(static_cast<Ship*>(remote));

  {float d=fabs(x.vx-y.vx)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.vy-y.vy)*10000;FAR+=d;NEAR+=d;}
{float d=fabs(x.x-y.x)*128;FAR+=d;NEAR+=d;}
{float d=fabs(x.y-y.y)*128;FAR+=d;NEAR+=d;}

      NEAR += 1000*fabs(x.vtheta-y.vtheta);
    

      NEAR += fabs((((float)x.theta) - ((float)y.theta))/6.0f);
      FAR +=  fabs((((float)x.theta) - ((float)y.theta))/48.0f);
    

      if (strcmp(x.tag, y.tag)) return true; //Must send update
    

      //Only prioritise updating the target if near
      if (strcmp(x.target, y.target))
        NEAR += 100;
    
{float d=fabs(x.thrustPercent-y.thrustPercent)*10;FAR+=d;NEAR+=d;}
{float d=fabs(x.reinforcement-y.reinforcement)*0;FAR+=d;NEAR+=d;}
{float d=fabs(x.insignia-y.insignia)*100;FAR+=d;NEAR+=d;}

      if (x.isFragment != y.isFragment)
        return true; //MUST update
    
{float d=fabs(x.thrustOn-y.thrustOn)*1;FAR+=d;NEAR+=d;}
{float d=fabs(x.brakeOn-y.brakeOn)*1;FAR+=d;NEAR+=d;}
{float d=fabs(x.shieldsDeactivated-y.shieldsDeactivated)*1;FAR+=d;NEAR+=d;}
{float d=fabs(x.stealthMode-y.stealthMode)*10000;FAR+=d;NEAR+=d;}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      //If one is zero and the other not, we must send an update
      if ((x.cellDamage[0+ARRAY_OFFSET] == 0) != (y.cellDamage[0+ARRAY_OFFSET] == 0))
        return true;

      //Consider 10% difference worth it at close range; don't care at far
      NEAR += fabs((x.cellDamage[0+ARRAY_OFFSET]-y.cellDamage[0+ARRAY_OFFSET])/25.6f);
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        //Usually send updates for differences when near
        NEAR +=
          fabs((float)x.shields[0+ARRAY_OFFSET].currStrengthPercent - y.shields[0+ARRAY_OFFSET].currStrengthPercent);
      

        NEAR += fabs((float)x.shields[0+ARRAY_OFFSET].currStability - y.shields[0+ARRAY_OFFSET].currStability);
      

        NEAR += fabs((float)x.shields[0+ARRAY_OFFSET].currAlpha - y.shields[0+ARRAY_OFFSET].currAlpha);
      
}

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR*FAR > l_dist && l_dist >= 5*5) || (NEAR > 1 && l_dist < 5*5);
}

void ENO_Ship::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  Ship* l_local = static_cast<Ship*>(this->local.ref);
  Ship* l_remote = static_cast<Ship*>(this->remote);
  float vx;
float vy;
float x;
float y;
float vtheta;
unsigned char theta;
char tag[128];
char target[128];
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
 bool destruction; 
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
  #define X l_local
  
      if (X->networkCells.empty()) {
        for (unsigned i = 0; i < X->cells.size(); ++i) {
          if (!X->cells[i]->isEmpty) {
            X->cells[i]->netIndex = X->networkCells.size();
            const_cast<Ship*>(X)->networkCells.push_back(X->cells[i]);
          }
        }
      }
    
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].radius = gen->getRadius();
          else
            shields[0+ARRAY_OFFSET].radius = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].maxStrength = (byte)gen->getStrength();
          else
            shields[0+ARRAY_OFFSET].maxStrength = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStrengthPercent =
              (byte)(255*min(1.0f,gen->getShieldStrength())/gen->getStrength());
          else
            shields[0+ARRAY_OFFSET].currStrengthPercent = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStability =
                (byte)(255.0f*min(1.0f,gen->getShieldStability()));
          else
            shields[0+ARRAY_OFFSET].currStability = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currAlpha = (byte)(255.0f * max(0.0f,gen->getShieldAlpha()));
          else
            shields[0+ARRAY_OFFSET].currAlpha = 0;
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::write_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[0+0], shields[0+ARRAY_OFFSET].radius);
io::write_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[4+0], shields[0+ARRAY_OFFSET].maxStrength);
io::write_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[5+0], shields[0+ARRAY_OFFSET].currStrengthPercent);
io::write_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[6+0], shields[0+ARRAY_OFFSET].currStability);
io::write_c(&(&DATA[0]+47381+ARRAY_OFFSET*8/1)[7+0], shields[0+ARRAY_OFFSET].currAlpha);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          systemExist[0+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          systemExist[1+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          systemExist[2+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          systemExist[3+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          systemExist[4+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          systemExist[5+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          systemExist[6+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          systemExist[7+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<0); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[0+ARRAY_OFFSET] & 1) << 0;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<1); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[1+ARRAY_OFFSET] & 1) << 1;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<2); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[2+ARRAY_OFFSET] & 1) << 2;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<3); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[3+ARRAY_OFFSET] & 1) << 3;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<4); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[4+ARRAY_OFFSET] & 1) << 4;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<5); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[5+ARRAY_OFFSET] & 1) << 5;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<6); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[6+ARRAY_OFFSET] & 1) << 6;
(&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] &= ~(1<<7); (&DATA[0]+29981+ARRAY_OFFSET*1/8)[0+0] |= (systemExist[7+ARRAY_OFFSET] & 1) << 7;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        cellDamage[0+ARRAY_OFFSET] = max((byte)1,
                   (byte)(255 - 255*c->getCurrDamage()/c->getMaxDamage()));
      } else {
        cellDamage[0+ARRAY_OFFSET] = 0; //Nonexistent
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::write_c(&(&DATA[0]+25887+ARRAY_OFFSET*1/1)[0+0], cellDamage[0+ARRAY_OFFSET]);
}
 destruction = false; 

      rootTheta = X->cells[0]->getT();
    
io::write_c(&DATA[297+0], rootTheta);

      rootIsBridge = (X->cells[0]->usage == CellBridge);
    
DATA[296+0] &= ~(1<<5); DATA[296+0] |= (rootIsBridge & 1) << 5;
stealthMode = X->stealthMode;
DATA[296+0] &= ~(1<<4); DATA[296+0] |= (stealthMode & 1) << 4;
shieldsDeactivated = X->shieldsDeactivated;
DATA[296+0] &= ~(1<<3); DATA[296+0] |= (shieldsDeactivated & 1) << 3;
brakeOn = X->brakeOn;
DATA[296+0] &= ~(1<<2); DATA[296+0] |= (brakeOn & 1) << 2;
thrustOn = X->thrustOn;
DATA[296+0] &= ~(1<<1); DATA[296+0] |= (thrustOn & 1) << 1;

      isFragment = X->isFragment;
    
DATA[296+0] &= ~(1<<0); DATA[296+0] |= (isFragment & 1) << 0;
insignia = X->insignia;
io::write_c(&DATA[288+0], insignia);

      currentCapacitancePercent = 255*X->getCapacitancePercent();
    
io::write_c(&DATA[287+0], currentCapacitancePercent);
reinforcement = X->reinforcement;
io::write_c(&DATA[283+0], reinforcement);
thrustPercent = X->thrustPercent;
io::write_c(&DATA[279+0], thrustPercent);

      if (X->target.ref)
        strncpy(target, X->target.ref->tag.c_str(), 128);
      else
        memset(target, 0, sizeof(target));
    
strncpy((char*)&DATA[139+0], target, 128);
 strncpy(tag, X->tag.c_str(), sizeof(tag)); 
strncpy((char*)&DATA[11+0], tag, 128);
 theta = (byte)(X->theta*255.0f/pi/2); 
io::write_c(&DATA[10+0], theta);
vtheta = X->vtheta;
{signed short _vtheta = vtheta/32.0e-3f*0x7FFF; io::write_c(&DATA[8+0],_vtheta);}
y = X->y;
{unsigned short _y = y/128.0f*0xFFFF; io::write_c(&DATA[6+0],_y);}
x = X->x;
{unsigned short _x = x/128.0f*0xFFFF; io::write_c(&DATA[4+0],_x);}
vy = X->vy;
{signed short _vy = vy/32.0e-3f*0x7FFF; io::write_c(&DATA[2+0],_vy);}
vx = X->vx;
{signed short _vx = vx/32.0e-3f*0x7FFF; io::write_c(&DATA[0+0],_vx);}
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
X->vtheta = vtheta;
 X->theta = theta/255.0f*pi*2 + vtheta*T; 

      X->cosTheta = cos(X->theta);
      X->sinTheta = sin(X->theta);
    
 if (!X->ignoreNetworkTag) X->tag = tag; 

      if (target[0]) {
        //Stop immediately if no change
        if (X->target.ref
        &&  0 == strcmp(target, X->target.ref->tag.c_str()))
          goto targetFound;

        //Seacrh the field for such a ship
        {
          GameField::iterator it = field->begin(), end = field->end();
          for (; it != end; ++it) {
            GameObject* go = *it;
            if (go->getClassification() == GameObject::ClassShip) {
              Ship* s = (Ship*)go;
              if (s->hasPower()
              &&  Allies != getAlliance(X->insignia, s->insignia)
              &&  0 == strcmp(target, s->tag.c_str())) {
                //Found
                X->target.assign(s);
                goto targetFound;
              }
            }
          }
        }

        //Not found
        X->target.assign(NULL);

        targetFound:;
      } else {
        X->target.assign(NULL);
      }
    



      X->physicsRequire(PHYS_SHIP_CAPAC_BIT);
      X->currentCapacitance=X->totalCapacitance*
                            currentCapacitancePercent/255.0f;
    
X->insignia = insignia;

      if (isFragment && !X->isFragment) {
        X->isFragment = true;
        cxn->unsetReference(X);
      }
    



      if (shieldsDeactivated && X->shieldsDeactivated) {
        shield_deactivate(X);
        X->shieldsDeactivated=true;
        //Clear all cell power bits that have shields
        X->physicsRequire(PHYS_SHIP_SHIELD_INVENTORY_BIT);
        for (unsigned i=0; i<X->shields.size(); ++i)
          X->shields[i]->getParent()->physicsClear(PHYS_CELL_POWER_BITS
                                                  |PHYS_CELL_POWER_PROD_BITS);
        X->shields.clear();
      }
    

      X->setStealthMode(stealthMode);
    

      X->configureEngines(thrustOn, brakeOn, thrustPercent);
    
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        if (!cellDamage[0+ARRAY_OFFSET] && !(0+ARRAY_OFFSET)) {
          //Illegal attempt to destroy root; ignore
          #ifdef DEBUG
          cerr << "Warning: Ignoring illegal attempt to destroy Ship root!"
               << endl;
          #endif
          DESTROY(true);
        }
        if (!cellDamage[0+ARRAY_OFFSET]) {
          destruction = true;
          X->physicsRequire(PHYS_SHIP_DS_INVENTORY_BIT
                           |PHYS_CELL_DS_NEAREST_BIT);
          //Delink the cell from its neighbours, spawning PlasmaFires
          //if appropriate.
          //Empty neighbours will cease to exist.
          for (unsigned n = 0; n < 4; ++n) {
            if (c->neighbours[n]) {
              if (c->neighbours[n]->isEmpty) {
                X->removeCell(c->neighbours[n]);
                delete c->neighbours[n];
              } else {
                unsigned ret = c->neighbours[n]->getNeighbour(c);
                EmptyCell* ec = new EmptyCell(X, c->neighbours[n]);
                c->neighbours[n]->neighbours[ret] = ec;
                X->cells.push_back(ec);
                if (highQuality && !isFragment)
                  field->add(new PlasmaFire(ec));
                X->physicsClear(PHYS_CELL_LOCATION_PROPERTIES_BITS
                               |PHYS_SHIP_COORDS_BITS);
              }
            }
          }

          //Spawn fragments if appropriate
          pair<float,float> coord = X->cellCoord(X, c);
          Blast blast(field, 0, coord.first, coord.second,
                      STD_CELL_SZ/2, c->getMaxDamage()-c->getCurrDamage(),
                      true, STD_CELL_SZ/16, false, true, false);
          CellFragment::spawn(c, &blast);

          //Destroy systems within cell
          if (c->systems[0]) c->systems[0]->destroy(0xFFFFFF);
          if (c->systems[1]) c->systems[1]->destroy(0xFFFFFF);
          //Remove cell from ship
          X->preremove(c);
          #ifndef AB_OPENGL_14
          if (X->renderer)
            X->renderer->cellRemoved(c);
          #endif
          X->removeCell(c);
          X->networkCells[(0+ARRAY_OFFSET)] = NULL;

          //Free
          delete c;

          if (X->cells.empty()) {
            #ifdef DEBUG
            cerr << "Warning: Discarding ship with no cells." << endl;
            #endif
            DESTROY(true);
          }
        } else {
          //Damage the cell by the appropriate amount
          float newdmg = 1.0f - cellDamage[0+ARRAY_OFFSET]/255.0f;
          newdmg *= c->getMaxDamage();
          float olddmg = c->getCurrDamage();
          if (newdmg > olddmg) {
            #ifndef NDEBUG
            bool intact =
            #endif
            c->applyDamage(newdmg-olddmg, 0xFFFFFF);
            assert(intact);
            X->cellDamaged(c);
          }
        }
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[0+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[1+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[2+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[3+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[4+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[5+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[6+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[7+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStrength(shields[0+ARRAY_OFFSET].currStrengthPercent/255.0f *
                                   gen->getStrength());
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStability(shields[0+ARRAY_OFFSET].currStability/255.0f);
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldAlpha(shields[0+ARRAY_OFFSET].currAlpha/255.0f);
        }
      
}
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}

      ShieldGenerator* INO_Ship::getShieldGenerator(const Cell* c) throw() {
        if (!c) return NULL;
        if (c->systems[0]
        &&  c->systems[0]->clazz == Classification_Shield)
          return static_cast<ShieldGenerator*>(c->systems[0]);
        if (c->systems[1]
        &&  c->systems[1]->clazz == Classification_Shield)
          return static_cast<ShieldGenerator*>(c->systems[1]);
        return NULL;
      }
    


  #include "../synchronous_control_geraet.hxx"
  #include "../anticipatory_channels.hxx"
  ExportedGameObject* createObjectExport(NetworkConnection* cxn,
                                         GameObject* object)
  throw() {
    ExportedGameObject* ego;
    NetworkConnection::geraet_num num;

if (typeid(*object) == typeid(EnergyCharge))
  ego = new ENO_EnergyCharge(cxn, (EnergyCharge*)object),
  num = INO_EnergyCharge::num;
else
if (typeid(*object) == typeid(MagnetoBomb))
  ego = new ENO_MagnetoBomb(cxn, (MagnetoBomb*)object),
  num = INO_MagnetoBomb::num;
else
if (typeid(*object) == typeid(SemiguidedBomb))
  ego = new ENO_SemiguidedBomb(cxn, (SemiguidedBomb*)object),
  num = INO_SemiguidedBomb::num;
else
if (typeid(*object) == typeid(PlasmaBurst))
  ego = new ENO_PlasmaBurst(cxn, (PlasmaBurst*)object),
  num = INO_PlasmaBurst::num;
else
if (typeid(*object) == typeid(Missile))
  ego = new ENO_Missile(cxn, (Missile*)object),
  num = INO_Missile::num;
else
if (typeid(*object) == typeid(ParticleEmitter))
  ego = new ENO_ParticleEmitter(cxn, (ParticleEmitter*)object),
  num = INO_ParticleEmitter::num;
else
if (typeid(*object) == typeid(MonophasicEnergyPulse))
  ego = new ENO_MonophasicEnergyPulse(cxn, (MonophasicEnergyPulse*)object),
  num = INO_MonophasicEnergyPulse::num;
else
if (typeid(*object) == typeid(Spectator))
  ego = new ENO_Spectator(cxn, (Spectator*)object),
  num = INO_Spectator::num;
else
if (typeid(*object) == typeid(Ship))
  ego = new ENO_Ship(cxn, (Ship*)object),
  num = INO_Ship::num;
else

  {
    cerr << "FATAL: Unknown object type to export: "
         << typeid(*object).name() << endl;
    assert(false);
    exit(EXIT_PROGRAM_BUG);
  }

  assert(ego);
  cxn->anticipation->openChannel(ego, num);
  ego->init();
  return ego;
}
