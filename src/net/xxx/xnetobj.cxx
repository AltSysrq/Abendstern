
  /**
   * @file
   * @author src/net/generate.tcl
   * @brief Autogenerated. Do not edit!
   */

  #include <cstring>

  #include "../io.hxx"

  using namespace std;
  //These diagnostics will happen alot due to the way code is
  //generated; they are safe to ignore.
  #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
  #pragma GCC diagnostic ignored "-Wunused-variable"

  //These are defined to... something on windows
  #ifdef NEAR
  #undef NEAR
  #endif
  #ifdef FAR
  #undef FAR
  #endif



//MSVC++ doesn't handle inherited members accessed by friends correctly.
//This hack injects an appropriate friends list into GameObject
#ifdef WIN32
#define TclGameObject  TclGameObject;  friend class INO_EnergyCharge; friend class ENO_EnergyCharge; friend class INO_MagnetoBomb; friend class ENO_MagnetoBomb; friend class INO_SemiguidedBomb; friend class ENO_SemiguidedBomb; friend class INO_PlasmaBurst; friend class ENO_PlasmaBurst; friend class INO_Missile; friend class ENO_Missile; friend class INO_ParticleEmitter; friend class ENO_ParticleEmitter; friend class INO_Ship; friend class ENO_Ship; friend class INO_Spectator; friend class ENO_Spectator
#endif

#include "xnetobj.hxx"


  #include <cassert>
  #include <typeinfo>
  #include "src/sim/game_object.hxx"
  #include "src/sim/blast.hxx"
  #include "src/ship/everything.hxx"
  #include "src/ship/ship_renderer.hxx"
  #include "src/weapon/energy_charge.hxx"
  #include "src/weapon/magneto_bomb.hxx"
  #include "src/weapon/plasma_burst.hxx"
  #include "src/weapon/semiguided_bomb.hxx"
  #include "src/weapon/missile.hxx"
  #include "src/weapon/monophasic_energy_pulse.hxx"
  #include "src/weapon/particle_beam.hxx"
  #include "src/camera/spectator.hxx"
  #include "src/exit_conditions.hxx"

INO_EnergyCharge::INO_EnergyCharge(NetworkConnection* cxn_)
: ImportedGameObject(153, cxn_),
  cxn(cxn_)
{ }

const NetworkConnection::geraet_num INO_EnergyCharge::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_EnergyCharge::create(NetworkConnection* cxn) throw() {
  return new INO_EnergyCharge(cxn);
}

void INO_EnergyCharge::construct() throw() {
  object = decodeConstruct(state);
}

void INO_EnergyCharge::update() throw() {
  if (decodeUpdate(state, static_cast<EnergyCharge*>(object)))
    destroy(false);
}

EnergyCharge* INO_EnergyCharge::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float intensity;
float theta;
bool exploded;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
io::read_c(&DATA[144+0], intensity);
if (intensity != intensity) intensity = 0;
 else if (intensity < 0) intensity = 0;
 else if (intensity > 1) intensity = 1;
io::read_c(&DATA[148+0], theta);
if (theta != theta) theta = -1.0e9;
 else if (theta < -1.0e9) theta = -1.0e9;
 else if (theta > +1.0e9) theta = +1.0e9;
exploded = (DATA[152+0] >> 0) & 1;
  EnergyCharge* X;
  
     X = new EnergyCharge(field, x, y, vx, vy, theta, intensity);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
  
  return X;
  #undef DESTROY
}

bool INO_EnergyCharge::decodeUpdate(const std::vector<byte>& DATA, EnergyCharge* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float intensity;
float theta;
bool exploded;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
X->vx = vx;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
X->vy = vy;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
X->x = x;
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
X->y = y;
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
 if (!X->ignoreNetworkTag) X->tag = tag; 
io::read_c(&DATA[144+0], intensity);
if (intensity != intensity) intensity = 0;
 else if (intensity < 0) intensity = 0;
 else if (intensity > 1) intensity = 1;
X->intensity = intensity;
io::read_c(&DATA[148+0], theta);
if (theta != theta) theta = -1.0e9;
 else if (theta < -1.0e9) theta = -1.0e9;
 else if (theta > +1.0e9) theta = +1.0e9;
exploded = (DATA[152+0] >> 0) & 1;

      if (!X->exploded && exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  return false;
  #undef DESTROY
}

ENO_EnergyCharge::ENO_EnergyCharge(NetworkConnection* cxn, EnergyCharge* obj)
: ExportedGameObject(153, cxn, obj, clone(obj))
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
char tag[128];
float intensity;
float theta;
bool exploded;
   exploded = X->exploded; 
DATA[152+0] &= ~(1<<0); DATA[152+0] |= (exploded & 1) << 0;
 theta = X->theta; 
io::write_c(&DATA[148+0], theta);
intensity = X->intensity;
io::write_c(&DATA[144+0], intensity);
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef DATA
  #undef field
  #undef X
}

EnergyCharge* ENO_EnergyCharge::clone(const EnergyCharge* src) const throw() {
  #define X src
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float intensity;
float theta;
bool exploded;
   exploded = X->exploded; 
 theta = X->theta; 
intensity = X->intensity;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  EnergyCharge* dst;
  #define X dst
  
     X = new EnergyCharge(field, x, y, vx, vy, theta, intensity);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_EnergyCharge::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
char tag[128];
float intensity;
float theta;
bool exploded;
    S(const EnergyCharge* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
intensity = X->intensity;
 theta = X->theta; 
 exploded = X->exploded; 
    }
  } x(static_cast<EnergyCharge*>(local.ref)), y(static_cast<EnergyCharge*>(remote));

   return false; 

      if (strcmp(x.tag, y.tag)) return true; //Must send update
    

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR > l_dist) || (NEAR > 1 && l_dist < 5);
}

void ENO_EnergyCharge::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  EnergyCharge* l_local = static_cast<EnergyCharge*>(this->local.ref);
  EnergyCharge* l_remote = static_cast<EnergyCharge*>(this->remote);
  float vx;
float vy;
float x;
float y;
char tag[128];
float intensity;
float theta;
bool exploded;
  #define X l_local
   exploded = X->exploded; 
DATA[152+0] &= ~(1<<0); DATA[152+0] |= (exploded & 1) << 0;
 theta = X->theta; 
io::write_c(&DATA[148+0], theta);
intensity = X->intensity;
io::write_c(&DATA[144+0], intensity);
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
 if (!X->ignoreNetworkTag) X->tag = tag; 
X->intensity = intensity;

      if (!X->exploded && exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}


INO_MagnetoBomb::INO_MagnetoBomb(NetworkConnection* cxn_)
: ImportedGameObject(159, cxn_),
  cxn(cxn_)
{ }

const NetworkConnection::geraet_num INO_MagnetoBomb::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_MagnetoBomb::create(NetworkConnection* cxn) throw() {
  return new INO_MagnetoBomb(cxn);
}

void INO_MagnetoBomb::construct() throw() {
  object = decodeConstruct(state);
}

void INO_MagnetoBomb::update() throw() {
  if (decodeUpdate(state, static_cast<MagnetoBomb*>(object)))
    destroy(false);
}

MagnetoBomb* INO_MagnetoBomb::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
io::read_c(&DATA[144+0], ax);
if (ax != ax) ax = -1.0e9;
 else if (ax < -1.0e9) ax = -1.0e9;
 else if (ax > +1.0e9) ax = +1.0e9;
io::read_c(&DATA[148+0], ay);
if (ay != ay) ay = -1.0e9;
 else if (ay < -1.0e9) ay = -1.0e9;
 else if (ay > +1.0e9) ay = +1.0e9;
io::read_c(&DATA[152+0], power);
if (power != power) power = 0;
 else if (power < 0) power = 0;
 else if (power > +1.0e9) power = +1.0e9;
io::read_c(&DATA[156+0], timeAlive);
 timeAlive = max((short unsigned)0,timeAlive); 
exploded = (DATA[158+0] >> 0) & 1;
  MagnetoBomb* X;
  
    X = new MagnetoBomb(field, x, y, vx, vy, power, NULL);
    X->isRemote = true;
    X->includeInCollisionDetection = false;
    X->decorative = true;
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
 X->ax = ax; 
 X->ay = ay; 
 X->timeAlive = timeAlive; 
  
  return X;
  #undef DESTROY
}

bool INO_MagnetoBomb::decodeUpdate(const std::vector<byte>& DATA, MagnetoBomb* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
X->vx = vx;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
X->vy = vy;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
X->x = x;
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
X->y = y;
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
 if (!X->ignoreNetworkTag) X->tag = tag; 
io::read_c(&DATA[144+0], ax);
if (ax != ax) ax = -1.0e9;
 else if (ax < -1.0e9) ax = -1.0e9;
 else if (ax > +1.0e9) ax = +1.0e9;
X->ax = ax;
io::read_c(&DATA[148+0], ay);
if (ay != ay) ay = -1.0e9;
 else if (ay < -1.0e9) ay = -1.0e9;
 else if (ay > +1.0e9) ay = +1.0e9;
X->ay = ay;
io::read_c(&DATA[152+0], power);
if (power != power) power = 0;
 else if (power < 0) power = 0;
 else if (power > +1.0e9) power = +1.0e9;
X->power = power;
io::read_c(&DATA[156+0], timeAlive);
 timeAlive = max((short unsigned)0,timeAlive); 
X->timeAlive = timeAlive;
exploded = (DATA[158+0] >> 0) & 1;

      if (!X->exploded && exploded) {
        X->explode();
        DESTROY(false);
      }
    
  return false;
  #undef DESTROY
}

ENO_MagnetoBomb::ENO_MagnetoBomb(NetworkConnection* cxn, MagnetoBomb* obj)
: ExportedGameObject(159, cxn, obj, clone(obj))
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
   exploded = X->exploded; 
DATA[158+0] &= ~(1<<0); DATA[158+0] |= (exploded & 1) << 0;
timeAlive = X->timeAlive;
io::write_c(&DATA[156+0], timeAlive);
power = X->power;
io::write_c(&DATA[152+0], power);
ay = X->ay;
io::write_c(&DATA[148+0], ay);
ax = X->ax;
io::write_c(&DATA[144+0], ax);
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef DATA
  #undef field
  #undef X
}

MagnetoBomb* ENO_MagnetoBomb::clone(const MagnetoBomb* src) const throw() {
  #define X src
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
   exploded = X->exploded; 
timeAlive = X->timeAlive;
power = X->power;
ay = X->ay;
ax = X->ax;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  MagnetoBomb* dst;
  #define X dst
  
    X = new MagnetoBomb(field, x, y, vx, vy, power, NULL);
    X->isRemote = true;
    X->includeInCollisionDetection = false;
    X->decorative = true;
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
 X->ax = ax; 
 X->ay = ay; 
 X->timeAlive = timeAlive; 
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_MagnetoBomb::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
    S(const MagnetoBomb* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
ax = X->ax;
ay = X->ay;
power = X->power;
timeAlive = X->timeAlive;
 exploded = X->exploded; 
    }
  } x(static_cast<MagnetoBomb*>(local.ref)), y(static_cast<MagnetoBomb*>(remote));

  
      if (strcmp(x.tag, y.tag)) return true; //Must send update
    

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR > l_dist) || (NEAR > 1 && l_dist < 5);
}

void ENO_MagnetoBomb::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  MagnetoBomb* l_local = static_cast<MagnetoBomb*>(this->local.ref);
  MagnetoBomb* l_remote = static_cast<MagnetoBomb*>(this->remote);
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  #define X l_local
   exploded = X->exploded; 
DATA[158+0] &= ~(1<<0); DATA[158+0] |= (exploded & 1) << 0;
timeAlive = X->timeAlive;
io::write_c(&DATA[156+0], timeAlive);
power = X->power;
io::write_c(&DATA[152+0], power);
ay = X->ay;
io::write_c(&DATA[148+0], ay);
ax = X->ax;
io::write_c(&DATA[144+0], ax);
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
 if (!X->ignoreNetworkTag) X->tag = tag; 
X->ax = ax;
X->ay = ay;
X->power = power;
X->timeAlive = timeAlive;

      if (!X->exploded && exploded) {
        X->explode();
        DESTROY(false);
      }
    
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}


INO_SemiguidedBomb::INO_SemiguidedBomb(NetworkConnection* cxn_)
: ImportedGameObject(159, cxn_),
  cxn(cxn_)
{ }

const NetworkConnection::geraet_num INO_SemiguidedBomb::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_SemiguidedBomb::create(NetworkConnection* cxn) throw() {
  return new INO_SemiguidedBomb(cxn);
}

void INO_SemiguidedBomb::construct() throw() {
  object = decodeConstruct(state);
}

void INO_SemiguidedBomb::update() throw() {
  if (decodeUpdate(state, static_cast<SemiguidedBomb*>(object)))
    destroy(false);
}

SemiguidedBomb* INO_SemiguidedBomb::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
io::read_c(&DATA[144+0], ax);
if (ax != ax) ax = -1.0e9;
 else if (ax < -1.0e9) ax = -1.0e9;
 else if (ax > +1.0e9) ax = +1.0e9;
io::read_c(&DATA[148+0], ay);
if (ay != ay) ay = -1.0e9;
 else if (ay < -1.0e9) ay = -1.0e9;
 else if (ay > +1.0e9) ay = +1.0e9;
io::read_c(&DATA[152+0], power);
if (power != power) power = 0;
 else if (power < 0) power = 0;
 else if (power > +1.0e9) power = +1.0e9;
io::read_c(&DATA[156+0], timeAlive);
 timeAlive = max((short unsigned)0,timeAlive); 
exploded = (DATA[158+0] >> 0) & 1;
  SemiguidedBomb* X;
  
    X = new SemiguidedBomb(field, x, y, vx, vy, power, NULL);
    X->isRemote = true;
    X->includeInCollisionDetection = false;
    X->decorative = true;
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
 X->ax = ax; 
 X->ay = ay; 
 X->timeAlive = timeAlive; 
  
  return X;
  #undef DESTROY
}

bool INO_SemiguidedBomb::decodeUpdate(const std::vector<byte>& DATA, SemiguidedBomb* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
X->vx = vx;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
X->vy = vy;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
X->x = x;
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
X->y = y;
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
 if (!X->ignoreNetworkTag) X->tag = tag; 
io::read_c(&DATA[144+0], ax);
if (ax != ax) ax = -1.0e9;
 else if (ax < -1.0e9) ax = -1.0e9;
 else if (ax > +1.0e9) ax = +1.0e9;
X->ax = ax;
io::read_c(&DATA[148+0], ay);
if (ay != ay) ay = -1.0e9;
 else if (ay < -1.0e9) ay = -1.0e9;
 else if (ay > +1.0e9) ay = +1.0e9;
X->ay = ay;
io::read_c(&DATA[152+0], power);
if (power != power) power = 0;
 else if (power < 0) power = 0;
 else if (power > +1.0e9) power = +1.0e9;
X->power = power;
io::read_c(&DATA[156+0], timeAlive);
 timeAlive = max((short unsigned)0,timeAlive); 
X->timeAlive = timeAlive;
exploded = (DATA[158+0] >> 0) & 1;

      if (!X->exploded && exploded) {
        X->explode();
        DESTROY(false);
      }
    
  return false;
  #undef DESTROY
}

ENO_SemiguidedBomb::ENO_SemiguidedBomb(NetworkConnection* cxn, SemiguidedBomb* obj)
: ExportedGameObject(159, cxn, obj, clone(obj))
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
   exploded = X->exploded; 
DATA[158+0] &= ~(1<<0); DATA[158+0] |= (exploded & 1) << 0;
timeAlive = X->timeAlive;
io::write_c(&DATA[156+0], timeAlive);
power = X->power;
io::write_c(&DATA[152+0], power);
ay = X->ay;
io::write_c(&DATA[148+0], ay);
ax = X->ax;
io::write_c(&DATA[144+0], ax);
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef DATA
  #undef field
  #undef X
}

SemiguidedBomb* ENO_SemiguidedBomb::clone(const SemiguidedBomb* src) const throw() {
  #define X src
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
   exploded = X->exploded; 
timeAlive = X->timeAlive;
power = X->power;
ay = X->ay;
ax = X->ax;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  SemiguidedBomb* dst;
  #define X dst
  
    X = new SemiguidedBomb(field, x, y, vx, vy, power, NULL);
    X->isRemote = true;
    X->includeInCollisionDetection = false;
    X->decorative = true;
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
 X->ax = ax; 
 X->ay = ay; 
 X->timeAlive = timeAlive; 
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_SemiguidedBomb::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
    S(const SemiguidedBomb* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
ax = X->ax;
ay = X->ay;
power = X->power;
timeAlive = X->timeAlive;
 exploded = X->exploded; 
    }
  } x(static_cast<SemiguidedBomb*>(local.ref)), y(static_cast<SemiguidedBomb*>(remote));

  
      if (strcmp(x.tag, y.tag)) return true; //Must send update
    

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR > l_dist) || (NEAR > 1 && l_dist < 5);
}

void ENO_SemiguidedBomb::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  SemiguidedBomb* l_local = static_cast<SemiguidedBomb*>(this->local.ref);
  SemiguidedBomb* l_remote = static_cast<SemiguidedBomb*>(this->remote);
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
float power;
unsigned short timeAlive;
bool exploded;
  #define X l_local
   exploded = X->exploded; 
DATA[158+0] &= ~(1<<0); DATA[158+0] |= (exploded & 1) << 0;
timeAlive = X->timeAlive;
io::write_c(&DATA[156+0], timeAlive);
power = X->power;
io::write_c(&DATA[152+0], power);
ay = X->ay;
io::write_c(&DATA[148+0], ay);
ax = X->ax;
io::write_c(&DATA[144+0], ax);
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
 if (!X->ignoreNetworkTag) X->tag = tag; 
X->ax = ax;
X->ay = ay;
X->power = power;
X->timeAlive = timeAlive;

      if (!X->exploded && exploded) {
        X->explode();
        DESTROY(false);
      }
    
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}


INO_PlasmaBurst::INO_PlasmaBurst(NetworkConnection* cxn_)
: ImportedGameObject(153, cxn_),
  cxn(cxn_)
{ }

const NetworkConnection::geraet_num INO_PlasmaBurst::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_PlasmaBurst::create(NetworkConnection* cxn) throw() {
  return new INO_PlasmaBurst(cxn);
}

void INO_PlasmaBurst::construct() throw() {
  object = decodeConstruct(state);
}

void INO_PlasmaBurst::update() throw() {
  if (decodeUpdate(state, static_cast<PlasmaBurst*>(object)))
    destroy(false);
}

PlasmaBurst* INO_PlasmaBurst::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float mass;
float direction;
unsigned exploded;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
io::read_c(&DATA[144+0], mass);
if (mass != mass) mass = 0;
 else if (mass < 0) mass = 0;
 else if (mass > 100) mass = 100;
io::read_c(&DATA[148+0], direction);
if (direction != direction) direction = -1.0e9;
 else if (direction < -1.0e9) direction = -1.0e9;
 else if (direction > +1.0e9) direction = +1.0e9;
exploded = (DATA[152+0] >> 0) & 1;
  PlasmaBurst* X;
  
    X = new PlasmaBurst(field, x, y, vx, vy, direction, mass);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
  
  return X;
  #undef DESTROY
}

bool INO_PlasmaBurst::decodeUpdate(const std::vector<byte>& DATA, PlasmaBurst* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float mass;
float direction;
unsigned exploded;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
X->vx = vx;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
X->vy = vy;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
X->x = x;
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
X->y = y;
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
 if (!X->ignoreNetworkTag) X->tag = tag; 
io::read_c(&DATA[144+0], mass);
if (mass != mass) mass = 0;
 else if (mass < 0) mass = 0;
 else if (mass > 100) mass = 100;
X->mass = mass;
io::read_c(&DATA[148+0], direction);
if (direction != direction) direction = -1.0e9;
 else if (direction < -1.0e9) direction = -1.0e9;
 else if (direction > +1.0e9) direction = +1.0e9;
X->direction = direction;
exploded = (DATA[152+0] >> 0) & 1;

      if (exploded && !X->exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  return false;
  #undef DESTROY
}

ENO_PlasmaBurst::ENO_PlasmaBurst(NetworkConnection* cxn, PlasmaBurst* obj)
: ExportedGameObject(153, cxn, obj, clone(obj))
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
char tag[128];
float mass;
float direction;
unsigned exploded;
  
      exploded = X->exploded;
    
DATA[152+0] &= ~(1<<0); DATA[152+0] |= (exploded & 1) << 0;
direction = X->direction;
io::write_c(&DATA[148+0], direction);
mass = X->mass;
io::write_c(&DATA[144+0], mass);
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef DATA
  #undef field
  #undef X
}

PlasmaBurst* ENO_PlasmaBurst::clone(const PlasmaBurst* src) const throw() {
  #define X src
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float mass;
float direction;
unsigned exploded;
  
      exploded = X->exploded;
    
direction = X->direction;
mass = X->mass;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  PlasmaBurst* dst;
  #define X dst
  
    X = new PlasmaBurst(field, x, y, vx, vy, direction, mass);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_PlasmaBurst::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
char tag[128];
float mass;
float direction;
unsigned exploded;
    S(const PlasmaBurst* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
mass = X->mass;
direction = X->direction;

      exploded = X->exploded;
    
    }
  } x(static_cast<PlasmaBurst*>(local.ref)), y(static_cast<PlasmaBurst*>(remote));

  
      if (strcmp(x.tag, y.tag)) return true; //Must send update
    
 return false; 

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR > l_dist) || (NEAR > 1 && l_dist < 5);
}

void ENO_PlasmaBurst::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  PlasmaBurst* l_local = static_cast<PlasmaBurst*>(this->local.ref);
  PlasmaBurst* l_remote = static_cast<PlasmaBurst*>(this->remote);
  float vx;
float vy;
float x;
float y;
char tag[128];
float mass;
float direction;
unsigned exploded;
  #define X l_local
  
      exploded = X->exploded;
    
DATA[152+0] &= ~(1<<0); DATA[152+0] |= (exploded & 1) << 0;
direction = X->direction;
io::write_c(&DATA[148+0], direction);
mass = X->mass;
io::write_c(&DATA[144+0], mass);
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
 if (!X->ignoreNetworkTag) X->tag = tag; 
X->mass = mass;
X->direction = direction;

      if (exploded && !X->exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}


INO_Missile::INO_Missile(NetworkConnection* cxn_)
: ImportedGameObject(155, cxn_),
  cxn(cxn_)
{ }

const NetworkConnection::geraet_num INO_Missile::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_Missile::create(NetworkConnection* cxn) throw() {
  return new INO_Missile(cxn);
}

void INO_Missile::construct() throw() {
  object = decodeConstruct(state);
}

void INO_Missile::update() throw() {
  if (decodeUpdate(state, static_cast<Missile*>(object)))
    destroy(false);
}

Missile* INO_Missile::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
unsigned short timeAlive;
unsigned level;
unsigned exploded;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
io::read_c(&DATA[144+0], ax);
if (ax != ax) ax = -2.0e-6f;
 else if (ax < -2.0e-6f) ax = -2.0e-6f;
 else if (ax > +2.0e-6f) ax = +2.0e-6f;
io::read_c(&DATA[148+0], ay);
if (ay != ay) ay = -2.0e-6f;
 else if (ay < -2.0e-6f) ay = -2.0e-6f;
 else if (ay > +2.0e-6f) ay = +2.0e-6f;
io::read_c(&DATA[152+0], timeAlive);
level = (DATA[154+0] >> 0) & 15;
exploded = (DATA[154+0] >> 4) & 1;
  Missile* X;
  
    X = new Missile(field, level, x, y, vx, vy, ax, ay, timeAlive);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
  
  return X;
  #undef DESTROY
}

bool INO_Missile::decodeUpdate(const std::vector<byte>& DATA, Missile* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
unsigned short timeAlive;
unsigned level;
unsigned exploded;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
X->vx = vx;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
X->vy = vy;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
X->x = x;
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
X->y = y;
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
 if (!X->ignoreNetworkTag) X->tag = tag; 
io::read_c(&DATA[144+0], ax);
if (ax != ax) ax = -2.0e-6f;
 else if (ax < -2.0e-6f) ax = -2.0e-6f;
 else if (ax > +2.0e-6f) ax = +2.0e-6f;
X->ax = ax;
io::read_c(&DATA[148+0], ay);
if (ay != ay) ay = -2.0e-6f;
 else if (ay < -2.0e-6f) ay = -2.0e-6f;
 else if (ay > +2.0e-6f) ay = +2.0e-6f;
X->ay = ay;
io::read_c(&DATA[152+0], timeAlive);
X->timeAlive = timeAlive;
level = (DATA[154+0] >> 0) & 15;
 X->level = min(10u,max(1u,level)); 
exploded = (DATA[154+0] >> 4) & 1;

      if (exploded && !X->exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  return false;
  #undef DESTROY
}

ENO_Missile::ENO_Missile(NetworkConnection* cxn, Missile* obj)
: ExportedGameObject(155, cxn, obj, clone(obj))
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
unsigned short timeAlive;
unsigned level;
unsigned exploded;
   exploded = X->exploded; 
DATA[154+0] &= ~(1<<4); DATA[154+0] |= (exploded & 1) << 4;
 level = X->level; 
DATA[154+0] &= ~(15<<0); DATA[154+0] |= (level & 15) << 0;
timeAlive = X->timeAlive;
io::write_c(&DATA[152+0], timeAlive);
ay = X->ay;
io::write_c(&DATA[148+0], ay);
ax = X->ax;
io::write_c(&DATA[144+0], ax);
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef DATA
  #undef field
  #undef X
}

Missile* ENO_Missile::clone(const Missile* src) const throw() {
  #define X src
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
unsigned short timeAlive;
unsigned level;
unsigned exploded;
   exploded = X->exploded; 
 level = X->level; 
timeAlive = X->timeAlive;
ay = X->ay;
ax = X->ax;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  Missile* dst;
  #define X dst
  
    X = new Missile(field, level, x, y, vx, vy, ax, ay, timeAlive);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_Missile::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
unsigned short timeAlive;
unsigned level;
unsigned exploded;
    S(const Missile* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
ax = X->ax;
ay = X->ay;
timeAlive = X->timeAlive;
 level = X->level; 
 exploded = X->exploded; 
    }
  } x(static_cast<Missile*>(local.ref)), y(static_cast<Missile*>(remote));

  
      if (strcmp(x.tag, y.tag)) return true; //Must send update
    

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR > l_dist) || (NEAR > 1 && l_dist < 5);
}

void ENO_Missile::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  Missile* l_local = static_cast<Missile*>(this->local.ref);
  Missile* l_remote = static_cast<Missile*>(this->remote);
  float vx;
float vy;
float x;
float y;
char tag[128];
float ax;
float ay;
unsigned short timeAlive;
unsigned level;
unsigned exploded;
  #define X l_local
   exploded = X->exploded; 
DATA[154+0] &= ~(1<<4); DATA[154+0] |= (exploded & 1) << 4;
 level = X->level; 
DATA[154+0] &= ~(15<<0); DATA[154+0] |= (level & 15) << 0;
timeAlive = X->timeAlive;
io::write_c(&DATA[152+0], timeAlive);
ay = X->ay;
io::write_c(&DATA[148+0], ay);
ax = X->ax;
io::write_c(&DATA[144+0], ax);
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
 if (!X->ignoreNetworkTag) X->tag = tag; 
X->ax = ax;
X->ay = ay;
X->timeAlive = timeAlive;
 X->level = min(10u,max(1u,level)); 

      if (exploded && !X->exploded) {
        X->explode(NULL);
        DESTROY(false);
      }
    
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}


INO_ParticleEmitter::INO_ParticleEmitter(NetworkConnection* cxn_)
: ImportedGameObject(156, cxn_),
  cxn(cxn_)
{ }

const NetworkConnection::geraet_num INO_ParticleEmitter::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_ParticleEmitter::create(NetworkConnection* cxn) throw() {
  return new INO_ParticleEmitter(cxn);
}

void INO_ParticleEmitter::construct() throw() {
  object = decodeConstruct(state);
}

void INO_ParticleEmitter::update() throw() {
  if (decodeUpdate(state, static_cast<ParticleEmitter*>(object)))
    destroy(false);
}

ParticleEmitter* INO_ParticleEmitter::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
type = (DATA[144+0] >> 0) & 3;
rmajor = (DATA[144+0] >> 2) & 7;
rminor = (DATA[144+0] >> 5) & 7;
io::read_c(&DATA[145+0], timeAlive);
memcpy(r, &DATA[147+0], 8);
io::read_c(&DATA[155+0], blame);
  ParticleEmitter* X;
  
    X = new ParticleEmitter(field, (ParticleBeamType)type,
                            0xFFFFFF, //TODO: Translate to local blame
                            x, y, vx, vy,
                            r, rmajor, rminor,
                            timeAlive);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
  
  return X;
  #undef DESTROY
}

bool INO_ParticleEmitter::decodeUpdate(const std::vector<byte>& DATA, ParticleEmitter* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
X->vx = vx;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
X->vy = vy;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
X->x = x;
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
X->y = y;
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
 if (!X->ignoreNetworkTag) X->tag = tag; 
type = (DATA[144+0] >> 0) & 3;
rmajor = (DATA[144+0] >> 2) & 7;
X->rmajor = rmajor;
rminor = (DATA[144+0] >> 5) & 7;
X->rminor = rminor;
io::read_c(&DATA[145+0], timeAlive);
X->timeAlive = timeAlive;
memcpy(r, &DATA[147+0], 8);
  memcpy(X->r, r, sizeof(r)); 
io::read_c(&DATA[155+0], blame);
X->blame = blame;
  return false;
  #undef DESTROY
}

ENO_ParticleEmitter::ENO_ParticleEmitter(NetworkConnection* cxn, ParticleEmitter* obj)
: ExportedGameObject(156, cxn, obj, clone(obj))
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
char tag[128];
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
  blame = X->blame;
io::write_c(&DATA[155+0], blame);
 memcpy(r, X->r, sizeof(r)); 
memcpy(&DATA[147+0], r, 8);
timeAlive = X->timeAlive;
io::write_c(&DATA[145+0], timeAlive);
rminor = X->rminor;
DATA[144+0] &= ~(7<<5); DATA[144+0] |= (rminor & 7) << 5;
rmajor = X->rmajor;
DATA[144+0] &= ~(7<<2); DATA[144+0] |= (rmajor & 7) << 2;
 type = (unsigned)X->type; 
DATA[144+0] &= ~(3<<0); DATA[144+0] |= (type & 3) << 0;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef DATA
  #undef field
  #undef X
}

ParticleEmitter* ENO_ParticleEmitter::clone(const ParticleEmitter* src) const throw() {
  #define X src
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
  blame = X->blame;
 memcpy(r, X->r, sizeof(r)); 
timeAlive = X->timeAlive;
rminor = X->rminor;
rmajor = X->rmajor;
 type = (unsigned)X->type; 
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  ParticleEmitter* dst;
  #define X dst
  
    X = new ParticleEmitter(field, (ParticleBeamType)type,
                            0xFFFFFF, //TODO: Translate to local blame
                            x, y, vx, vy,
                            r, rmajor, rminor,
                            timeAlive);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_ParticleEmitter::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
char tag[128];
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
    S(const ParticleEmitter* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
 type = (unsigned)X->type; 
rmajor = X->rmajor;
rminor = X->rminor;
timeAlive = X->timeAlive;
 memcpy(r, X->r, sizeof(r)); 
blame = X->blame;
    }
  } x(static_cast<ParticleEmitter*>(local.ref)), y(static_cast<ParticleEmitter*>(remote));

  
      if (strcmp(x.tag, y.tag)) return true; //Must send update
    
 return false; 

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR > l_dist) || (NEAR > 1 && l_dist < 5);
}

void ENO_ParticleEmitter::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  ParticleEmitter* l_local = static_cast<ParticleEmitter*>(this->local.ref);
  ParticleEmitter* l_remote = static_cast<ParticleEmitter*>(this->remote);
  float vx;
float vy;
float x;
float y;
char tag[128];
unsigned type;
unsigned rmajor;
unsigned rminor;
unsigned short timeAlive;
byte r[8];
unsigned char blame;
  #define X l_local
  blame = X->blame;
io::write_c(&DATA[155+0], blame);
 memcpy(r, X->r, sizeof(r)); 
memcpy(&DATA[147+0], r, 8);
timeAlive = X->timeAlive;
io::write_c(&DATA[145+0], timeAlive);
rminor = X->rminor;
DATA[144+0] &= ~(7<<5); DATA[144+0] |= (rminor & 7) << 5;
rmajor = X->rmajor;
DATA[144+0] &= ~(7<<2); DATA[144+0] |= (rmajor & 7) << 2;
 type = (unsigned)X->type; 
DATA[144+0] &= ~(3<<0); DATA[144+0] |= (type & 3) << 0;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
 if (!X->ignoreNetworkTag) X->tag = tag; 
X->rmajor = rmajor;
X->rminor = rminor;
X->timeAlive = timeAlive;
  memcpy(X->r, r, sizeof(r)); 
X->blame = blame;
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}


INO_Spectator::INO_Spectator(NetworkConnection* cxn_)
: ImportedGameObject(144, cxn_),
  cxn(cxn_)
{ }

const NetworkConnection::geraet_num INO_Spectator::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_Spectator::create(NetworkConnection* cxn) throw() {
  return new INO_Spectator(cxn);
}

void INO_Spectator::construct() throw() {
  object = decodeConstruct(state);
}

void INO_Spectator::update() throw() {
  if (decodeUpdate(state, static_cast<Spectator*>(object)))
    destroy(false);
}

Spectator* INO_Spectator::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
  Spectator* X;
  
    X = new Spectator(field, x, y, vx, vy);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
   cxn->setReference(X); 
  return X;
  #undef DESTROY
}

bool INO_Spectator::decodeUpdate(const std::vector<byte>& DATA, Spectator* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
X->vx = vx;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
X->vy = vy;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
X->x = x;
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
X->y = y;
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
 if (!X->ignoreNetworkTag) X->tag = tag; 
  return false;
  #undef DESTROY
}

ENO_Spectator::ENO_Spectator(NetworkConnection* cxn, Spectator* obj)
: ExportedGameObject(144, cxn, obj, clone(obj))
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
char tag[128];
   strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef DATA
  #undef field
  #undef X
}

Spectator* ENO_Spectator::clone(const Spectator* src) const throw() {
  #define X src
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
   strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  Spectator* dst;
  #define X dst
  
    X = new Spectator(field, x, y, vx, vy);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_Spectator::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
char tag[128];
    S(const Spectator* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
    }
  } x(static_cast<Spectator*>(local.ref)), y(static_cast<Spectator*>(remote));

  
      if (strcmp(x.tag, y.tag)) return true; //Must send update
    

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR > l_dist) || (NEAR > 1 && l_dist < 5);
}

void ENO_Spectator::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  Spectator* l_local = static_cast<Spectator*>(this->local.ref);
  Spectator* l_remote = static_cast<Spectator*>(this->remote);
  float vx;
float vy;
float x;
float y;
char tag[128];
  #define X l_local
   strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
 if (!X->ignoreNetworkTag) X->tag = tag; 
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}



  #define SQUARE_CELL 0
  #define CIRCLE_CELL 1
  #define EQUT_CELL 2
  #define RIGHTT_CELL 3

  enum ShipSystemCode {
    SSCAntimatterPower=0,
    SSCCloakingDevice,
    SSCDispersionShield,
    SSCGatlingPlasmaBurstLauncher,
    SSCMissileLauncher,
    SSCMonophasicEnergyEmitter,
    SSCParticleBeamLauncher,
    SSCRelIonAccelerator,

    SSCBussardRamjet,
    SSCFusionPower,
    SSCHeatsink,
    SSCMiniGravwaveDriveMKII,
    SSCPlasmaBurstLauncher,
    SSCSemiguidedBombLauncher,
    SSCShieldGenerator,
    SSCSuperParticleAccelerator,

    SSCCapacitor,
    SSCEnergyChargeLauncher,
    SSCFissionPower,
    SSCMagnetoBombLauncher,
    SSCMiniGravwaveDrive,
    SSCParticleAccelerator,
    SSCPowerCell,
    SSCReinforcementBulkhead,
    SSCSelfDestructCharge
  };

  //Uses the SYS(name) macro to handle every known ship system type.
  #define HANDLE_SYSTEMS  SYS(AntimatterPower)  SYS(CloakingDevice)  SYS(DispersionShield)  SYS(GatlingPlasmaBurstLauncher)  SYS(MissileLauncher)  SYS(MonophasicEnergyEmitter)  SYS(ParticleBeamLauncher)  SYS(RelIonAccelerator)  SYS(BussardRamjet)  SYS(FusionPower)  SYS(Heatsink)  SYS(MiniGravwaveDriveMKII)  SYS(PlasmaBurstLauncher)  SYS(SemiguidedBombLauncher)  SYS(SuperParticleAccelerator)  SYS(Capacitor)  SYS(EnergyChargeLauncher)  SYS(FissionPower)  SYS(MagnetoBombLauncher)  SYS(MiniGravwaveDrive)  SYS(ParticleAccelerator)  SYS(PowerCell)  SYS(ReinforcementBulkhead)  SYS(SelfDestructCharge)

  #define SHGEN(ix) ((ix) < X->networkCells.size()?  getShieldGenerator(X->networkCells[(ix)]) : NULL)

  //ShipSystem constructor helper
  template<typename T>
  struct ShipSystemConstructor {
    inline
    static T* construct(Ship* ship, unsigned cellix, unsigned sysix,
                        unsigned capacitance, bool gatPlasmaTurbo,
                        float shieldRad, unsigned shieldStrength)
    throw() {
      return new T(ship);
    }
  };

  template<>
  struct ShipSystemConstructor<Capacitor> {
    inline
    static Capacitor* construct(Ship* ship, unsigned cellix, unsigned sysix,
                                unsigned capacitance, bool gatPlasmaTurbo,
                                float shieldRad, unsigned shieldStrength)
    throw() {
      return new Capacitor(ship, capacitance);
    }
  };

  template<>
  struct ShipSystemConstructor<GatlingPlasmaBurstLauncher> {
    inline static GatlingPlasmaBurstLauncher*
    construct(Ship* ship, unsigned cellix, unsigned sysix,
              unsigned capacitance, bool gatPlasmaTurbo,
              float shieldRad, unsigned shieldStrength)
    throw() {
      return new GatlingPlasmaBurstLauncher(ship, gatPlasmaTurbo);
    }
  };

  template<>
  struct ShipSystemConstructor<ShieldGenerator> {
    inline static ShieldGenerator*
    construct(Ship* ship, unsigned cellix, unsigned sysix,
              unsigned capacitance, bool gatPlasmaTurbo,
              float shieldRad, unsigned shieldStrength)
    throw() {
      return new ShieldGenerator(ship, shieldStrength, shieldRad);
    }
  };

INO_Ship::INO_Ship(NetworkConnection* cxn_)
: ImportedGameObject(80658, cxn_),
  cxn(cxn_)
{ }

const NetworkConnection::geraet_num INO_Ship::num =
    NetworkConnection::registerGeraetCreator(&create);

InputNetworkGeraet* INO_Ship::create(NetworkConnection* cxn) throw() {
  return new INO_Ship(cxn);
}

void INO_Ship::construct() throw() {
  object = decodeConstruct(state);
}

void INO_Ship::update() throw() {
  if (decodeUpdate(state, static_cast<Ship*>(object)))
    destroy(false);
}

Ship* INO_Ship::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  #define DESTROY(x) do { delete X; return NULL; } while(0)
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
char target[128];
float colourR;
float colourG;
float colourB;
float theta;
float vtheta;
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
unsigned char neighboursBits03[16376];
unsigned char neighboursBits47[16376];
unsigned char neighboursBits8B[16376];
unsigned int neighbours[16376];
unsigned char cellType[4096];
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    unsigned char orientation, type;
  } systemInfo[8188];
unsigned char capacitors[8188];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
bool gatPlasmaTurbo[4096];
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
strncpy(target, (const char*)&DATA[144+0], 128-1); target[128-1]=0;
io::read_c(&DATA[272+0], colourR);
if (colourR != colourR) colourR = 0;
 else if (colourR < 0) colourR = 0;
 else if (colourR > 1) colourR = 1;
io::read_c(&DATA[276+0], colourG);
if (colourG != colourG) colourG = 0;
 else if (colourG < 0) colourG = 0;
 else if (colourG > 1) colourG = 1;
io::read_c(&DATA[280+0], colourB);
if (colourB != colourB) colourB = 0;
 else if (colourB < 0) colourB = 0;
 else if (colourB > 1) colourB = 1;
io::read_c(&DATA[284+0], theta);
if (theta != theta) theta = -1.0e9;
 else if (theta < -1.0e9) theta = -1.0e9;
 else if (theta > +1.0e9) theta = +1.0e9;
io::read_c(&DATA[288+0], vtheta);
if (vtheta != vtheta) vtheta = -1.0e9;
 else if (vtheta < -1.0e9) vtheta = -1.0e9;
 else if (vtheta > +1.0e9) vtheta = +1.0e9;
io::read_c(&DATA[292+0], thrustPercent);
if (thrustPercent != thrustPercent) thrustPercent = 0;
 else if (thrustPercent < 0) thrustPercent = 0;
 else if (thrustPercent > 1) thrustPercent = 1;
io::read_c(&DATA[296+0], reinforcement);
if (reinforcement != reinforcement) reinforcement = 0;
 else if (reinforcement < 0) reinforcement = 0;
 else if (reinforcement > 32) reinforcement = 32;
io::read_c(&DATA[300+0], currentCapacitancePercent);
io::read_c(&DATA[301+0], insignia);
isFragment = (DATA[309+0] >> 0) & 1;
thrustOn = (DATA[309+0] >> 1) & 1;
brakeOn = (DATA[309+0] >> 2) & 1;
shieldsDeactivated = (DATA[309+0] >> 3) & 1;
stealthMode = (DATA[309+0] >> 4) & 1;
rootIsBridge = (DATA[309+0] >> 5) & 1;
io::read_c(&DATA[310+0], rootTheta);
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
neighboursBits03[0+ARRAY_OFFSET] = ((&DATA[0]+312+ARRAY_OFFSET*1)[0+0] >> 0) & 15;
neighboursBits03[1+ARRAY_OFFSET] = ((&DATA[0]+312+ARRAY_OFFSET*1)[0+0] >> 4) & 15;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
neighboursBits47[0+ARRAY_OFFSET] = ((&DATA[0]+8500+ARRAY_OFFSET*1)[0+0] >> 0) & 15;
neighboursBits47[1+ARRAY_OFFSET] = ((&DATA[0]+8500+ARRAY_OFFSET*1)[0+0] >> 4) & 15;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
neighboursBits8B[0+ARRAY_OFFSET] = ((&DATA[0]+16688+ARRAY_OFFSET*1)[0+0] >> 0) & 15;
neighboursBits8B[1+ARRAY_OFFSET] = ((&DATA[0]+16688+ARRAY_OFFSET*1)[0+0] >> 4) & 15;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=1) {

        neighbours[0+ARRAY_OFFSET] = (neighboursBits03[(0+ARRAY_OFFSET)] << 0)
             | (neighboursBits47[(0+ARRAY_OFFSET)] << 4)
             | (neighboursBits8B[(0+ARRAY_OFFSET)] << 8);
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=4) {
cellType[0+ARRAY_OFFSET] = ((&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] >> 0) & 3;
cellType[1+ARRAY_OFFSET] = ((&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] >> 2) & 3;
cellType[2+ARRAY_OFFSET] = ((&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] >> 4) & 3;
cellType[3+ARRAY_OFFSET] = ((&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] >> 6) & 3;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::read_c(&(&DATA[0]+25900+ARRAY_OFFSET*1)[0+0], cellDamage[0+ARRAY_OFFSET]);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {
systemExist[0+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 0) & 1;
systemExist[1+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 1) & 1;
systemExist[2+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 2) & 1;
systemExist[3+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 3) & 1;
systemExist[4+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 4) & 1;
systemExist[5+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 5) & 1;
systemExist[6+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 6) & 1;
systemExist[7+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 7) & 1;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {
systemInfo[0+ARRAY_OFFSET].orientation = ((&DATA[0]+31018+ARRAY_OFFSET*1)[0+0] >> 0) & 3;
systemInfo[0+ARRAY_OFFSET].type = ((&DATA[0]+31018+ARRAY_OFFSET*1)[0+0] >> 2) & 63;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {
io::read_c(&(&DATA[0]+39206+ARRAY_OFFSET*1)[0+0], capacitors[0+ARRAY_OFFSET]);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {

        capacitors[0+ARRAY_OFFSET] = min((unsigned char)CAPACITOR_MAX, max((unsigned char)1, capacitors[0+ARRAY_OFFSET]));
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::read_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[0+0], shields[0+ARRAY_OFFSET].radius);
io::read_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[4+0], shields[0+ARRAY_OFFSET].maxStrength);
io::read_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[5+0], shields[0+ARRAY_OFFSET].currStrengthPercent);
io::read_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[6+0], shields[0+ARRAY_OFFSET].currStability);
io::read_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[7+0], shields[0+ARRAY_OFFSET].currAlpha);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
if (shields[0+ARRAY_OFFSET].radius != shields[0+ARRAY_OFFSET].radius) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MIN_SHIELD_RAD;
 else if (shields[0+ARRAY_OFFSET].radius < STD_CELL_SZ*MIN_SHIELD_RAD) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MIN_SHIELD_RAD;
 else if (shields[0+ARRAY_OFFSET].radius > STD_CELL_SZ*MAX_SHIELD_RAD) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MAX_SHIELD_RAD;
 shields[0+ARRAY_OFFSET].maxStrength = min((byte)MAX_SHIELD_STR,
                                        max((byte)MIN_SHIELD_STR,
                                            shields[0+ARRAY_OFFSET].maxStrength));
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=8) {
gatPlasmaTurbo[0+ARRAY_OFFSET] = ((&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] >> 0) & 1;
gatPlasmaTurbo[1+ARRAY_OFFSET] = ((&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] >> 1) & 1;
gatPlasmaTurbo[2+ARRAY_OFFSET] = ((&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] >> 2) & 1;
gatPlasmaTurbo[3+ARRAY_OFFSET] = ((&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] >> 3) & 1;
gatPlasmaTurbo[4+ARRAY_OFFSET] = ((&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] >> 4) & 1;
gatPlasmaTurbo[5+ARRAY_OFFSET] = ((&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] >> 5) & 1;
gatPlasmaTurbo[6+ARRAY_OFFSET] = ((&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] >> 6) & 1;
gatPlasmaTurbo[7+ARRAY_OFFSET] = ((&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] >> 7) & 1;
}
  Ship* X;
  
    X = new Ship(field);
    //Set fields from GameObject
    X->x = x;
    X->y = y;
    X->vx = vx;
    X->vy = vy;
    X->isRemote = true;

    //Count the number of cell slots used
    //The last cell with non-zero health is the last index we must store,
    //so the length is one plus that index.
    unsigned cellCount = lenof(cellDamage);
    while (cellCount > 0 && !cellDamage[cellCount-1]) --cellCount;

    X->networkCells.resize(cellCount, NULL);

    if (!cellDamage[0]) {
      #ifdef DEBUG
      cerr << "Warning: Ignoring ship with nonexistent root." << endl;
      #endif
      DESTROY(true);
    }

    if (rootIsBridge && rootTheta != 0) {
      #ifdef DEBUG
      cerr << "Warning: Ignoring ship with rotated bridge." << endl;
      #endif
      DESTROY(true);
    }

    //Initialise living cells
    for (unsigned i = 0; i < cellCount; ++i) {
      if (cellDamage[i]) {
        Cell* c;
        switch (cellType[i]) {
          case SQUARE_CELL:
            c = new SquareCell(X);
            break;

          case CIRCLE_CELL:
            c = new CircleCell(X);
            break;

          case EQUT_CELL:
            c = new EquTCell(X);
            break;

          default: //RIGHTT_CELL
            assert(cellType[i] == RIGHTT_CELL);
            if (i == 0 && rootIsBridge) {
              #ifdef DEBUG
              cerr << "Warning: Attempt to make right triangle bridge." << endl;
              #endif
              DESTROY(true);
            }
            c = new RightTCell(X);
            break;
        }
        //Wait with applying damage until ready to do physics

        //Add cell to ship
        X->cells.push_back(c);
        X->networkCells[i] = c;
        c->netIndex = i;
        if (i == 0 && rootIsBridge)
          c->usage = CellBridge;
      }
    }

    //Link cells to each other
    for (unsigned i=0; i < cellCount; ++i) {
      if (cellDamage[i]) {
        unsigned numNeighbours = (cellType[i] <= CIRCLE_CELL? 4 : 3);
        for (unsigned n = 0; n < numNeighbours; ++n) {
          if (unsigned nix = neighbours[i*4+n]) {
            //There is a linkage to this neighbour
            Cell* neighbour;
            if (nix == 1) {
              //Special case: EmptyCell
              neighbour = new EmptyCell(X, X->networkCells[i]);
              X->cells.push_back(neighbour);
            } else if (nix-2 < cellCount) {
              //General case
              neighbour = X->networkCells[nix-2];
            } else {
              #ifdef DEBUG
              cerr << "Warning: Neighbour index out of bounds: " << (nix-2)
                   << endl;
              #endif
              neighbour = NULL;
            }

            if (!neighbour) {
              #ifdef DEBUG
              cerr << "Warning: Nonexistent neighbour." << endl;
              #endif
              DESTROY(true);
            }

            X->networkCells[i]->neighbours[n] = neighbour;
          }
        }
      }
    }

    //Verify that all cells have bidirectional linkage
    for (unsigned i=0; i < X->cells.size(); ++i) {
      Cell* c = X->cells[i];
      for (unsigned n=0; n < 4; ++n) {
        if (c->neighbours[n]) {
          Cell* d = c->neighbours[n];
          for (unsigned m = 0; m < 4; ++m) {
            if (d->neighbours[m] == c)
              goto nextN;
          }

          //Shouldn't get here if all linkage is valid
          #ifdef DEBUG
          cerr << "Warning: Ignoring ship with monodirectional linkage." <<endl;
          #endif
          DESTROY(true);
        }
        nextN:;
      }
    }

    //Orient the cells
    X->cells[0]->orient(rootTheta);

    //Add systems
    for (unsigned i=0; i<cellCount; ++i) if (cellDamage[i]) {
      if (i==0 && rootIsBridge) continue; //Bridge has no systems

      unsigned syscount = (cellType[i] <= CIRCLE_CELL? 2:1);
      for (unsigned s=0; s<syscount; ++s) if (systemExist[i*2+s]) {
        ShipSystem* ss;
        #define SYS(systype)  case (unsigned)SSC##systype:  ss = ShipSystemConstructor<systype>::construct(  X, i, s, capacitors[i*2+s], gatPlasmaTurbo[i],  shields[i].radius, shields[i].maxStrength);  break;
        switch (systemInfo[i*2+s].type) {
          HANDLE_SYSTEMS
          default:
            #ifdef DEBUG
            cerr << "Warning: Ignoring unknown ship system type: "
                 << systemInfo[i*2+s].type << endl;
            #endif
            continue;
        }
        #undef SYS

        assert(ss);

        //Add system to ship
        X->networkCells[i]->systems[s] = ss;
        ss->container = X->networkCells[i];

        //Configure system and ensure it is happy there
        if (const char* error =
            ss->setOrientation(systemInfo[i*2+s].orientation)) {
          #ifdef DEBUG
          cerr << "Warning: Rejecting ship system with bad orientation: "
               << error << endl;
          #endif
          DESTROY(true);
        }
      }
    }

    //Ensure ship is valid
    if (const char* error = verify(X)) {
      #ifdef DEBUG
      cerr << "Warning: Discarding invalid ship: " << error << endl;
      #endif
      DESTROY(true);
    }
  
   if (!X->ignoreNetworkTag) X->tag = tag; 

      X->setColour(colourR, colourG, colourB);
    
 X->theta = theta; 
 X->vtheta = vtheta; 

      X->cosTheta = cos(X->theta);
      X->sinTheta = sin(X->theta);
    

      X->setReinforcement(reinforcement);
    

      X->insignia = insignia;
    

      if (isFragment) {
        X->spontaneouslyDie();
      } else {
        cxn->setReference(X);
      }
    

      X->setStealthMode(stealthMode);
    

      X->configureEngines(thrustPercent, thrustOn, brakeOn);
    
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStrength(shields[0+ARRAY_OFFSET].currStrengthPercent/255.0f *
                                   gen->getStrength());
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStability(shields[0+ARRAY_OFFSET].currStability/255.0f);
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldAlpha(shields[0+ARRAY_OFFSET].currAlpha/255.0f);
        }
      
}
   cxn->setReference(X); 
  return X;
  #undef DESTROY
}

bool INO_Ship::decodeUpdate(const std::vector<byte>& DATA, Ship* X)
throw () {
  #define DESTROY(x) return true
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
char target[128];
float theta;
float vtheta;
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
  io::read_c(&DATA[0+0], vx);
if (vx != vx) vx = -1.0e9;
 else if (vx < -1.0e9) vx = -1.0e9;
 else if (vx > +1.0e9) vx = +1.0e9;
X->vx = vx;
io::read_c(&DATA[4+0], vy);
if (vy != vy) vy = -1.0e9;
 else if (vy < -1.0e9) vy = -1.0e9;
 else if (vy > +1.0e9) vy = +1.0e9;
X->vy = vy;
io::read_c(&DATA[8+0], x);

      if (x == x)
        x = max(0.0f, min(field->width, x + T*vx));
      else
        x = 0;
    
X->x = x;
io::read_c(&DATA[12+0], y);

      if (y == y)
        y = max(0.0f, min(field->height, y + T*vy));
      else
        y = 0;
    
X->y = y;
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
 if (!X->ignoreNetworkTag) X->tag = tag; 
strncpy(target, (const char*)&DATA[144+0], 128-1); target[128-1]=0;

      if (target[0]) {
        //Stop immediately if no change
        if (X->target.ref
        &&  0 == strcmp(target, X->target.ref->tag.c_str()))
          goto targetFound;

        //Seacrh the field for such a ship
        {
          GameField::iterator it = field->begin(), end = field->end();
          for (; it != end; ++it) {
            GameObject* go = *it;
            if (go->getClassification() == GameObject::ClassShip) {
              Ship* s = (Ship*)go;
              if (s->hasPower()
              &&  Allies != getAlliance(X->insignia, s->insignia)
              &&  0 == strcmp(target, s->tag.c_str())) {
                //Found
                X->target.assign(s);
                goto targetFound;
              }
            }
          }
        }

        //Not found
        X->target.assign(NULL);

        targetFound:;
      } else {
        X->target.assign(NULL);
      }
    
io::read_c(&DATA[284+0], theta);
if (theta != theta) theta = -1.0e9;
 else if (theta < -1.0e9) theta = -1.0e9;
 else if (theta > +1.0e9) theta = +1.0e9;
X->theta = theta;
io::read_c(&DATA[288+0], vtheta);
if (vtheta != vtheta) vtheta = -1.0e9;
 else if (vtheta < -1.0e9) vtheta = -1.0e9;
 else if (vtheta > +1.0e9) vtheta = +1.0e9;
X->vtheta = vtheta;

      X->cosTheta = cos(X->theta);
      X->sinTheta = sin(X->theta);
    
io::read_c(&DATA[292+0], thrustPercent);
if (thrustPercent != thrustPercent) thrustPercent = 0;
 else if (thrustPercent < 0) thrustPercent = 0;
 else if (thrustPercent > 1) thrustPercent = 1;

io::read_c(&DATA[296+0], reinforcement);
if (reinforcement != reinforcement) reinforcement = 0;
 else if (reinforcement < 0) reinforcement = 0;
 else if (reinforcement > 32) reinforcement = 32;

io::read_c(&DATA[300+0], currentCapacitancePercent);

      X->physicsRequire(PHYS_SHIP_CAPAC_BIT);
      X->currentCapacitance=X->totalCapacitance*
                            currentCapacitancePercent/255.0f;
    
io::read_c(&DATA[301+0], insignia);
X->insignia = insignia;
isFragment = (DATA[309+0] >> 0) & 1;

      if (isFragment && !X->isFragment) {
        X->spontaneouslyDie();
        cxn->unsetReference(X);
      }
    
thrustOn = (DATA[309+0] >> 1) & 1;

brakeOn = (DATA[309+0] >> 2) & 1;

shieldsDeactivated = (DATA[309+0] >> 3) & 1;

      shield_deactivate(X);
      X->shieldsDeactivated=true;
      //Clear all cell power bits that have shields
      X->physicsRequire(PHYS_SHIP_SHIELD_INVENTORY_BIT);
      for (unsigned i=0; i<X->shields.size(); ++i)
        X->shields[i]->getParent()->physicsClear(PHYS_CELL_POWER_BITS
                                                |PHYS_CELL_POWER_PROD_BITS);
      X->shields.clear();
    
stealthMode = (DATA[309+0] >> 4) & 1;

      X->setStealthMode(stealthMode);
    
rootIsBridge = (DATA[309+0] >> 5) & 1;

      X->configureEngines(thrustPercent, thrustOn, brakeOn);
    
io::read_c(&DATA[310+0], rootTheta);
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::read_c(&(&DATA[0]+25900+ARRAY_OFFSET*1)[0+0], cellDamage[0+ARRAY_OFFSET]);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        if (!cellDamage[0+ARRAY_OFFSET] && !(0+ARRAY_OFFSET)) {
          //Illegal attempt to destroy root; ignore
          #ifdef DEBUG
          cerr << "Warning: Ignoring illegal attempt to destroy Ship root!"
               << endl;
          #endif
          DESTROY(true);
        }
        if (!cellDamage[0+ARRAY_OFFSET]) {
          //Delink the cell from its neighbours, spawning PlasmaFires
          //if appropriate.
          for (unsigned n = 0; n < 4; ++n) {
            if (c->neighbours[n]) {
              unsigned ret = c->neighbours[n]->getNeighbour(c);
              EmptyCell* ec = new EmptyCell(X, c->neighbours[n]);
              c->neighbours[n]->neighbours[ret] = ec;
              if (highQuality && EXPCLOSE(x,y))
                field->add(new PlasmaFire(ec));
            }
          }

          //Spawn fragments if appropriate
          pair<float,float> coord = X->cellCoord(X, c);
          Blast blast(field, 0, coord.first, coord.second,
                      STD_CELL_SZ/2, c->getMaxDamage()-c->getCurrDamage(),
                      true, STD_CELL_SZ/16, false, true, false);
          CellFragment::spawn(c, &blast);

          //Destroy systems within cell
          if (c->systems[0]) c->systems[0]->destroy(0xFFFFFF);
          if (c->systems[1]) c->systems[1]->destroy(0xFFFFFF);
          //Remove cell from ship
          X->preremove(c);
          #ifndef AB_OPENGL_14
          if (X->renderer)
            X->renderer->cellRemoved(c);
          #endif
          X->removeCell(c);
          X->networkCells[(0+ARRAY_OFFSET)] = NULL;

          //Free
          delete c;
        } else {
          //Damage the cell by the appropriate amount
          float newdmg = 1.0f - cellDamage[0+ARRAY_OFFSET]/255.0f;
          newdmg *= c->getMaxDamage();
          float olddmg = c->getCurrDamage();
          #ifndef NDEBUG
          bool destroyed =
          #endif
          c->applyDamage(newdmg-olddmg, 0xFFFFFF);
          assert(!destroyed);
          X->cellDamaged(c);
        }
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {
systemExist[0+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 0) & 1;
systemExist[1+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 1) & 1;
systemExist[2+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 2) & 1;
systemExist[3+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 3) & 1;
systemExist[4+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 4) & 1;
systemExist[5+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 5) & 1;
systemExist[6+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 6) & 1;
systemExist[7+ARRAY_OFFSET] = ((&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] >> 7) & 1;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[0+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[1+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[2+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[3+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[4+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[5+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[6+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[7+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::read_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[0+0], shields[0+ARRAY_OFFSET].radius);
io::read_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[4+0], shields[0+ARRAY_OFFSET].maxStrength);
io::read_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[5+0], shields[0+ARRAY_OFFSET].currStrengthPercent);
io::read_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[6+0], shields[0+ARRAY_OFFSET].currStability);
io::read_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[7+0], shields[0+ARRAY_OFFSET].currAlpha);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
if (shields[0+ARRAY_OFFSET].radius != shields[0+ARRAY_OFFSET].radius) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MIN_SHIELD_RAD;
 else if (shields[0+ARRAY_OFFSET].radius < STD_CELL_SZ*MIN_SHIELD_RAD) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MIN_SHIELD_RAD;
 else if (shields[0+ARRAY_OFFSET].radius > STD_CELL_SZ*MAX_SHIELD_RAD) shields[0+ARRAY_OFFSET].radius = STD_CELL_SZ*MAX_SHIELD_RAD;
 shields[0+ARRAY_OFFSET].maxStrength = min((byte)MAX_SHIELD_STR,
                                        max((byte)MIN_SHIELD_STR,
                                            shields[0+ARRAY_OFFSET].maxStrength));
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStrength(shields[0+ARRAY_OFFSET].currStrengthPercent/255.0f *
                                   gen->getStrength());
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStability(shields[0+ARRAY_OFFSET].currStability/255.0f);
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldAlpha(shields[0+ARRAY_OFFSET].currAlpha/255.0f);
        }
      
}
  return false;
  #undef DESTROY
}

ENO_Ship::ENO_Ship(NetworkConnection* cxn, Ship* obj)
: ExportedGameObject(80658, cxn, obj, clone(obj))
{
  //Populate initial data
  #define X obj
  #define field (cxn->field)
  const unsigned T = cxn->getLatency();
  #define DATA state
  float vx;
float vy;
float x;
float y;
char tag[128];
char target[128];
float colourR;
float colourG;
float colourB;
float theta;
float vtheta;
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
unsigned char neighboursBits03[16376];
unsigned char neighboursBits47[16376];
unsigned char neighboursBits8B[16376];
unsigned int neighbours[16376];
unsigned char cellType[4096];
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    unsigned char orientation, type;
  } systemInfo[8188];
unsigned char capacitors[8188];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
bool gatPlasmaTurbo[4096];
  for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=8) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(0+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = false;
        }
      }
    

      if ((1+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(1+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(1+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = false;
        }
      }
    

      if ((2+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(2+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(2+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = false;
        }
      }
    

      if ((3+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(3+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(3+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = false;
        }
      }
    

      if ((4+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(4+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(4+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = false;
        }
      }
    

      if ((5+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(5+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(5+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = false;
        }
      }
    

      if ((6+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(6+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(6+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = false;
        }
      }
    

      if ((7+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(7+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(7+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = false;
        }
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=8) {
(&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] &= ~(1<<0); (&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] |= (gatPlasmaTurbo[0+ARRAY_OFFSET] & 1) << 0;
(&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] &= ~(1<<1); (&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] |= (gatPlasmaTurbo[1+ARRAY_OFFSET] & 1) << 1;
(&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] &= ~(1<<2); (&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] |= (gatPlasmaTurbo[2+ARRAY_OFFSET] & 1) << 2;
(&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] &= ~(1<<3); (&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] |= (gatPlasmaTurbo[3+ARRAY_OFFSET] & 1) << 3;
(&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] &= ~(1<<4); (&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] |= (gatPlasmaTurbo[4+ARRAY_OFFSET] & 1) << 4;
(&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] &= ~(1<<5); (&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] |= (gatPlasmaTurbo[5+ARRAY_OFFSET] & 1) << 5;
(&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] &= ~(1<<6); (&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] |= (gatPlasmaTurbo[6+ARRAY_OFFSET] & 1) << 6;
(&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] &= ~(1<<7); (&DATA[0]+80146+ARRAY_OFFSET*1)[0+0] |= (gatPlasmaTurbo[7+ARRAY_OFFSET] & 1) << 7;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].radius = gen->getRadius();
          else
            shields[0+ARRAY_OFFSET].radius = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].maxStrength = (byte)gen->getStrength();
          else
            shields[0+ARRAY_OFFSET].maxStrength = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStrengthPercent =
                (byte)(255*gen->getShieldStrength()/gen->getStrength());
          else
            shields[0+ARRAY_OFFSET].currStrengthPercent = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStability = (byte)(255.0f*gen->getShieldStability());
          else
            shields[0+ARRAY_OFFSET].currStability = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currAlpha = (byte)(255.0f * gen->getShieldAlpha());
          else
            shields[0+ARRAY_OFFSET].currAlpha = 0;
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::write_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[0+0], shields[0+ARRAY_OFFSET].radius);
io::write_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[4+0], shields[0+ARRAY_OFFSET].maxStrength);
io::write_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[5+0], shields[0+ARRAY_OFFSET].currStrengthPercent);
io::write_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[6+0], shields[0+ARRAY_OFFSET].currStability);
io::write_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[7+0], shields[0+ARRAY_OFFSET].currAlpha);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
          if (cellix < X->networkCells.size()
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]
          &&  typeid(*X->networkCells[cellix]->systems[sysix]) ==
              typeid(Capacitor))
            capacitors[0+ARRAY_OFFSET] = ((Capacitor*)X->networkCells[cellix]->systems[sysix])->
                   getCapacity();
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {
io::write_c(&(&DATA[0]+39206+ARRAY_OFFSET*1)[0+0], capacitors[0+ARRAY_OFFSET]);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {

        unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
        if (cellix < X->networkCells.size()
        &&  X->networkCells[cellix]
        &&  X->networkCells[cellix]->systems[sysix]) {
          systemInfo[0+ARRAY_OFFSET].orientation =
            X->networkCells[cellix]->systems[sysix]->getOrientation();
        } else {
          systemInfo[0+ARRAY_OFFSET].orientation = 0;
        }
      

        {
          #define SYS(clazz)  if (typeid(*sys) == typeid(clazz))  systemInfo[0+ARRAY_OFFSET].type = (unsigned char)SSC##clazz;  else

          unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
          if (cellix < X->networkCells.size()
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            ShipSystem*const sys = X->networkCells[cellix]->systems[sysix];
            HANDLE_SYSTEMS
            /* else */ {
              cerr << "FATAL: Unexpected ShipSystem type: "
                  << typeid(*sys).name() << endl;
              exit(EXIT_PROGRAM_BUG);
            }
          } else {
            systemInfo[0+ARRAY_OFFSET].type = 0;
          }

          #undef SYS
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {
(&DATA[0]+31018+ARRAY_OFFSET*1)[0+0] &= ~(3<<0); (&DATA[0]+31018+ARRAY_OFFSET*1)[0+0] |= (systemInfo[0+ARRAY_OFFSET].orientation & 3) << 0;
(&DATA[0]+31018+ARRAY_OFFSET*1)[0+0] &= ~(63<<2); (&DATA[0]+31018+ARRAY_OFFSET*1)[0+0] |= (systemInfo[0+ARRAY_OFFSET].type & 63) << 2;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          systemExist[0+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          systemExist[1+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          systemExist[2+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          systemExist[3+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          systemExist[4+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          systemExist[5+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          systemExist[6+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          systemExist[7+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<0); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[0+ARRAY_OFFSET] & 1) << 0;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<1); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[1+ARRAY_OFFSET] & 1) << 1;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<2); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[2+ARRAY_OFFSET] & 1) << 2;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<3); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[3+ARRAY_OFFSET] & 1) << 3;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<4); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[4+ARRAY_OFFSET] & 1) << 4;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<5); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[5+ARRAY_OFFSET] & 1) << 5;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<6); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[6+ARRAY_OFFSET] & 1) << 6;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<7); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[7+ARRAY_OFFSET] & 1) << 7;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        cellDamage[0+ARRAY_OFFSET] = max((byte)1,
                   (byte)(255 - 255*c->getCurrDamage()/c->getMaxDamage()));
      } else {
        cellDamage[0+ARRAY_OFFSET] = 0; //Nonexistent
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::write_c(&(&DATA[0]+25900+ARRAY_OFFSET*1)[0+0], cellDamage[0+ARRAY_OFFSET]);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=4) {

      //Only bother initialising if the cell actually exists
      if (X->networkCells.size() > (0+ARRAY_OFFSET) && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(0+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[0+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[0+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[0+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[0+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      }
    

      //Only bother initialising if the cell actually exists
      if (X->networkCells.size() > (1+ARRAY_OFFSET) && X->networkCells[(1+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(1+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[1+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[1+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[1+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[1+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      }
    

      //Only bother initialising if the cell actually exists
      if (X->networkCells.size() > (2+ARRAY_OFFSET) && X->networkCells[(2+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(2+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[2+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[2+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[2+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[2+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      }
    

      //Only bother initialising if the cell actually exists
      if (X->networkCells.size() > (3+ARRAY_OFFSET) && X->networkCells[(3+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(3+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[3+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[3+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[3+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[3+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=4) {
(&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] &= ~(3<<0); (&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] |= (cellType[0+ARRAY_OFFSET] & 3) << 0;
(&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] &= ~(3<<2); (&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] |= (cellType[1+ARRAY_OFFSET] & 3) << 2;
(&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] &= ~(3<<4); (&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] |= (cellType[2+ARRAY_OFFSET] & 3) << 4;
(&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] &= ~(3<<6); (&DATA[0]+24876+ARRAY_OFFSET*1)[0+0] |= (cellType[3+ARRAY_OFFSET] & 3) << 6;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=1) {

        {
          const unsigned neigh = (0+ARRAY_OFFSET)&3;
          const unsigned cellix = (0+ARRAY_OFFSET)>>2;
          if (X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->neighbours[neigh]) {
            //Exists, but EmptyCells are encoded specially
            if (X->networkCells[cellix]->neighbours[neigh]->isEmpty) {
              //Special value: 1
              neighbours[0+ARRAY_OFFSET] = 1;
            } else {
              //Generic
              neighbours[0+ARRAY_OFFSET] = 2 + X->networkCells[cellix]->neighbours[neigh]->netIndex;
            }
          } else {
            //Nonexistent
            neighbours[0+ARRAY_OFFSET] = 0;
          }
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=1) {

        neighboursBits03[(0+ARRAY_OFFSET)] = neighbours[0+ARRAY_OFFSET] & 15;
        neighboursBits47[(0+ARRAY_OFFSET)] = (neighbours[0+ARRAY_OFFSET] >> 4) & 15;
        neighboursBits8B[(0+ARRAY_OFFSET)] = neighbours[0+ARRAY_OFFSET] >> 8;
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
(&DATA[0]+16688+ARRAY_OFFSET*1)[0+0] &= ~(15<<0); (&DATA[0]+16688+ARRAY_OFFSET*1)[0+0] |= (neighboursBits8B[0+ARRAY_OFFSET] & 15) << 0;
(&DATA[0]+16688+ARRAY_OFFSET*1)[0+0] &= ~(15<<4); (&DATA[0]+16688+ARRAY_OFFSET*1)[0+0] |= (neighboursBits8B[1+ARRAY_OFFSET] & 15) << 4;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
(&DATA[0]+8500+ARRAY_OFFSET*1)[0+0] &= ~(15<<0); (&DATA[0]+8500+ARRAY_OFFSET*1)[0+0] |= (neighboursBits47[0+ARRAY_OFFSET] & 15) << 0;
(&DATA[0]+8500+ARRAY_OFFSET*1)[0+0] &= ~(15<<4); (&DATA[0]+8500+ARRAY_OFFSET*1)[0+0] |= (neighboursBits47[1+ARRAY_OFFSET] & 15) << 4;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=2) {
(&DATA[0]+312+ARRAY_OFFSET*1)[0+0] &= ~(15<<0); (&DATA[0]+312+ARRAY_OFFSET*1)[0+0] |= (neighboursBits03[0+ARRAY_OFFSET] & 15) << 0;
(&DATA[0]+312+ARRAY_OFFSET*1)[0+0] &= ~(15<<4); (&DATA[0]+312+ARRAY_OFFSET*1)[0+0] |= (neighboursBits03[1+ARRAY_OFFSET] & 15) << 4;
}

      rootTheta = X->cells[0]->getT();
    
io::write_c(&DATA[310+0], rootTheta);

      rootIsBridge = (X->cells[0]->usage == CellBridge);
    
DATA[309+0] &= ~(1<<5); DATA[309+0] |= (rootIsBridge & 1) << 5;
stealthMode = X->stealthMode;
DATA[309+0] &= ~(1<<4); DATA[309+0] |= (stealthMode & 1) << 4;
shieldsDeactivated = X->shieldsDeactivated;
DATA[309+0] &= ~(1<<3); DATA[309+0] |= (shieldsDeactivated & 1) << 3;
brakeOn = X->brakeOn;
DATA[309+0] &= ~(1<<2); DATA[309+0] |= (brakeOn & 1) << 2;
thrustOn = X->thrustOn;
DATA[309+0] &= ~(1<<1); DATA[309+0] |= (thrustOn & 1) << 1;

      isFragment = X->isFragment;
    
DATA[309+0] &= ~(1<<0); DATA[309+0] |= (isFragment & 1) << 0;
insignia = X->insignia;
io::write_c(&DATA[301+0], insignia);

      currentCapacitancePercent = 255*X->getCapacitancePercent();
    
io::write_c(&DATA[300+0], currentCapacitancePercent);
reinforcement = X->reinforcement;
io::write_c(&DATA[296+0], reinforcement);
thrustPercent = X->thrustPercent;
io::write_c(&DATA[292+0], thrustPercent);
vtheta = X->vtheta;
io::write_c(&DATA[288+0], vtheta);
theta = X->theta;
io::write_c(&DATA[284+0], theta);
colourB = X->colourB;
io::write_c(&DATA[280+0], colourB);
colourG = X->colourG;
io::write_c(&DATA[276+0], colourG);
colourR = X->colourR;
io::write_c(&DATA[272+0], colourR);

      if (X->target.ref)
        strncpy(target, X->target.ref->tag.c_str(), 128);
      else
        target[0]=0;
    
strncpy((char*)&DATA[144+0], target, 128);

      if (X->networkCells.empty()) {
        for (unsigned i = 0; i < X->cells.size(); ++i) {
          if (!X->cells[i]->isEmpty) {
            X->cells[i]->netIndex = X->networkCells.size();
            const_cast<Ship*>(X)->networkCells.push_back(X->cells[i]);
          }
        }
      }
    
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef DATA
  #undef field
  #undef X
}

Ship* ENO_Ship::clone(const Ship* src) const throw() {
  #define X src
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
char target[128];
float colourR;
float colourG;
float colourB;
float theta;
float vtheta;
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
unsigned char neighboursBits03[16376];
unsigned char neighboursBits47[16376];
unsigned char neighboursBits8B[16376];
unsigned int neighbours[16376];
unsigned char cellType[4096];
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    unsigned char orientation, type;
  } systemInfo[8188];
unsigned char capacitors[8188];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
bool gatPlasmaTurbo[4096];
  for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=8) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(0+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[0+ARRAY_OFFSET] = false;
        }
      }
    

      if ((1+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(1+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(1+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[1+ARRAY_OFFSET] = false;
        }
      }
    

      if ((2+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(2+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(2+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[2+ARRAY_OFFSET] = false;
        }
      }
    

      if ((3+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(3+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(3+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[3+ARRAY_OFFSET] = false;
        }
      }
    

      if ((4+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(4+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(4+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[4+ARRAY_OFFSET] = false;
        }
      }
    

      if ((5+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(5+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(5+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[5+ARRAY_OFFSET] = false;
        }
      }
    

      if ((6+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(6+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(6+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[6+ARRAY_OFFSET] = false;
        }
      }
    

      if ((7+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(7+ARRAY_OFFSET)]) {
        ShipSystem*const*const s = X->networkCells[(7+ARRAY_OFFSET)]->systems;

        if (s[0] && typeid(*s[0]) == typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[0])->getTurbo();
        } else if (s[1] && typeid(*s[1])==typeid(GatlingPlasmaBurstLauncher)) {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = ((GatlingPlasmaBurstLauncher*)s[1])->getTurbo();
        } else {
          gatPlasmaTurbo[7+ARRAY_OFFSET] = false;
        }
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].radius = gen->getRadius();
          else
            shields[0+ARRAY_OFFSET].radius = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].maxStrength = (byte)gen->getStrength();
          else
            shields[0+ARRAY_OFFSET].maxStrength = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStrengthPercent =
                (byte)(255*gen->getShieldStrength()/gen->getStrength());
          else
            shields[0+ARRAY_OFFSET].currStrengthPercent = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStability = (byte)(255.0f*gen->getShieldStability());
          else
            shields[0+ARRAY_OFFSET].currStability = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currAlpha = (byte)(255.0f * gen->getShieldAlpha());
          else
            shields[0+ARRAY_OFFSET].currAlpha = 0;
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
          if (cellix < X->networkCells.size()
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]
          &&  typeid(*X->networkCells[cellix]->systems[sysix]) ==
              typeid(Capacitor))
            capacitors[0+ARRAY_OFFSET] = ((Capacitor*)X->networkCells[cellix]->systems[sysix])->
                   getCapacity();
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8188; ARRAY_OFFSET+=1) {

        unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
        if (cellix < X->networkCells.size()
        &&  X->networkCells[cellix]
        &&  X->networkCells[cellix]->systems[sysix]) {
          systemInfo[0+ARRAY_OFFSET].orientation =
            X->networkCells[cellix]->systems[sysix]->getOrientation();
        } else {
          systemInfo[0+ARRAY_OFFSET].orientation = 0;
        }
      

        {
          #define SYS(clazz)  if (typeid(*sys) == typeid(clazz))  systemInfo[0+ARRAY_OFFSET].type = (unsigned char)SSC##clazz;  else

          unsigned cellix = (0+ARRAY_OFFSET)/2, sysix = (0+ARRAY_OFFSET)&1;
          if (cellix < X->networkCells.size()
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            ShipSystem*const sys = X->networkCells[cellix]->systems[sysix];
            HANDLE_SYSTEMS
            /* else */ {
              cerr << "FATAL: Unexpected ShipSystem type: "
                  << typeid(*sys).name() << endl;
              exit(EXIT_PROGRAM_BUG);
            }
          } else {
            systemInfo[0+ARRAY_OFFSET].type = 0;
          }

          #undef SYS
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          systemExist[0+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          systemExist[1+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          systemExist[2+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          systemExist[3+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          systemExist[4+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          systemExist[5+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          systemExist[6+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          systemExist[7+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        cellDamage[0+ARRAY_OFFSET] = max((byte)1,
                   (byte)(255 - 255*c->getCurrDamage()/c->getMaxDamage()));
      } else {
        cellDamage[0+ARRAY_OFFSET] = 0; //Nonexistent
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4096; ARRAY_OFFSET+=4) {

      //Only bother initialising if the cell actually exists
      if (X->networkCells.size() > (0+ARRAY_OFFSET) && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(0+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[0+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[0+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[0+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[0+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      }
    

      //Only bother initialising if the cell actually exists
      if (X->networkCells.size() > (1+ARRAY_OFFSET) && X->networkCells[(1+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(1+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[1+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[1+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[1+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[1+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      }
    

      //Only bother initialising if the cell actually exists
      if (X->networkCells.size() > (2+ARRAY_OFFSET) && X->networkCells[(2+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(2+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[2+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[2+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[2+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[2+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      }
    

      //Only bother initialising if the cell actually exists
      if (X->networkCells.size() > (3+ARRAY_OFFSET) && X->networkCells[(3+ARRAY_OFFSET)]) {
        Cell* c = X->networkCells[(3+ARRAY_OFFSET)];
        if (typeid(*c) == typeid(SquareCell))
          cellType[3+ARRAY_OFFSET] = SQUARE_CELL;
        else if (typeid(*c) == typeid(CircleCell))
          cellType[3+ARRAY_OFFSET] = CIRCLE_CELL;
        else if (typeid(*c) == typeid(EquTCell))
          cellType[3+ARRAY_OFFSET] = EQUT_CELL;
        else {
          assert(typeid(*c) == typeid(RightTCell));
          cellType[3+ARRAY_OFFSET] = RIGHTT_CELL;
        }
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<16376; ARRAY_OFFSET+=1) {

        {
          const unsigned neigh = (0+ARRAY_OFFSET)&3;
          const unsigned cellix = (0+ARRAY_OFFSET)>>2;
          if (X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->neighbours[neigh]) {
            //Exists, but EmptyCells are encoded specially
            if (X->networkCells[cellix]->neighbours[neigh]->isEmpty) {
              //Special value: 1
              neighbours[0+ARRAY_OFFSET] = 1;
            } else {
              //Generic
              neighbours[0+ARRAY_OFFSET] = 2 + X->networkCells[cellix]->neighbours[neigh]->netIndex;
            }
          } else {
            //Nonexistent
            neighbours[0+ARRAY_OFFSET] = 0;
          }
        }
      
}

      rootTheta = X->cells[0]->getT();
    

      rootIsBridge = (X->cells[0]->usage == CellBridge);
    
stealthMode = X->stealthMode;
shieldsDeactivated = X->shieldsDeactivated;
brakeOn = X->brakeOn;
thrustOn = X->thrustOn;

      isFragment = X->isFragment;
    
insignia = X->insignia;

      currentCapacitancePercent = 255*X->getCapacitancePercent();
    
reinforcement = X->reinforcement;
thrustPercent = X->thrustPercent;
vtheta = X->vtheta;
theta = X->theta;
colourB = X->colourB;
colourG = X->colourG;
colourR = X->colourR;

      if (X->target.ref)
        strncpy(target, X->target.ref->tag.c_str(), 128);
      else
        target[0]=0;
    

      if (X->networkCells.empty()) {
        for (unsigned i = 0; i < X->cells.size(); ++i) {
          if (!X->cells[i]->isEmpty) {
            X->cells[i]->netIndex = X->networkCells.size();
            const_cast<Ship*>(X)->networkCells.push_back(X->cells[i]);
          }
        }
      }
    
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
y = X->y;
x = X->x;
vy = X->vy;
vx = X->vx;
  #undef X
  Ship* dst;
  #define X dst
  
    X = new Ship(field);
    //Set fields from GameObject
    X->x = x;
    X->y = y;
    X->vx = vx;
    X->vy = vy;
    X->isRemote = true;

    //Count the number of cell slots used
    //The last cell with non-zero health is the last index we must store,
    //so the length is one plus that index.
    unsigned cellCount = lenof(cellDamage);
    while (cellCount > 0 && !cellDamage[cellCount-1]) --cellCount;

    X->networkCells.resize(cellCount, NULL);

    if (!cellDamage[0]) {
      #ifdef DEBUG
      cerr << "Warning: Ignoring ship with nonexistent root." << endl;
      #endif
      DESTROY(true);
    }

    if (rootIsBridge && rootTheta != 0) {
      #ifdef DEBUG
      cerr << "Warning: Ignoring ship with rotated bridge." << endl;
      #endif
      DESTROY(true);
    }

    //Initialise living cells
    for (unsigned i = 0; i < cellCount; ++i) {
      if (cellDamage[i]) {
        Cell* c;
        switch (cellType[i]) {
          case SQUARE_CELL:
            c = new SquareCell(X);
            break;

          case CIRCLE_CELL:
            c = new CircleCell(X);
            break;

          case EQUT_CELL:
            c = new EquTCell(X);
            break;

          default: //RIGHTT_CELL
            assert(cellType[i] == RIGHTT_CELL);
            if (i == 0 && rootIsBridge) {
              #ifdef DEBUG
              cerr << "Warning: Attempt to make right triangle bridge." << endl;
              #endif
              DESTROY(true);
            }
            c = new RightTCell(X);
            break;
        }
        //Wait with applying damage until ready to do physics

        //Add cell to ship
        X->cells.push_back(c);
        X->networkCells[i] = c;
        c->netIndex = i;
        if (i == 0 && rootIsBridge)
          c->usage = CellBridge;
      }
    }

    //Link cells to each other
    for (unsigned i=0; i < cellCount; ++i) {
      if (cellDamage[i]) {
        unsigned numNeighbours = (cellType[i] <= CIRCLE_CELL? 4 : 3);
        for (unsigned n = 0; n < numNeighbours; ++n) {
          if (unsigned nix = neighbours[i*4+n]) {
            //There is a linkage to this neighbour
            Cell* neighbour;
            if (nix == 1) {
              //Special case: EmptyCell
              neighbour = new EmptyCell(X, X->networkCells[i]);
              X->cells.push_back(neighbour);
            } else if (nix-2 < cellCount) {
              //General case
              neighbour = X->networkCells[nix-2];
            } else {
              #ifdef DEBUG
              cerr << "Warning: Neighbour index out of bounds: " << (nix-2)
                   << endl;
              #endif
              neighbour = NULL;
            }

            if (!neighbour) {
              #ifdef DEBUG
              cerr << "Warning: Nonexistent neighbour." << endl;
              #endif
              DESTROY(true);
            }

            X->networkCells[i]->neighbours[n] = neighbour;
          }
        }
      }
    }

    //Verify that all cells have bidirectional linkage
    for (unsigned i=0; i < X->cells.size(); ++i) {
      Cell* c = X->cells[i];
      for (unsigned n=0; n < 4; ++n) {
        if (c->neighbours[n]) {
          Cell* d = c->neighbours[n];
          for (unsigned m = 0; m < 4; ++m) {
            if (d->neighbours[m] == c)
              goto nextN;
          }

          //Shouldn't get here if all linkage is valid
          #ifdef DEBUG
          cerr << "Warning: Ignoring ship with monodirectional linkage." <<endl;
          #endif
          DESTROY(true);
        }
        nextN:;
      }
    }

    //Orient the cells
    X->cells[0]->orient(rootTheta);

    //Add systems
    for (unsigned i=0; i<cellCount; ++i) if (cellDamage[i]) {
      if (i==0 && rootIsBridge) continue; //Bridge has no systems

      unsigned syscount = (cellType[i] <= CIRCLE_CELL? 2:1);
      for (unsigned s=0; s<syscount; ++s) if (systemExist[i*2+s]) {
        ShipSystem* ss;
        #define SYS(systype)  case (unsigned)SSC##systype:  ss = ShipSystemConstructor<systype>::construct(  X, i, s, capacitors[i*2+s], gatPlasmaTurbo[i],  shields[i].radius, shields[i].maxStrength);  break;
        switch (systemInfo[i*2+s].type) {
          HANDLE_SYSTEMS
          default:
            #ifdef DEBUG
            cerr << "Warning: Ignoring unknown ship system type: "
                 << systemInfo[i*2+s].type << endl;
            #endif
            continue;
        }
        #undef SYS

        assert(ss);

        //Add system to ship
        X->networkCells[i]->systems[s] = ss;
        ss->container = X->networkCells[i];

        //Configure system and ensure it is happy there
        if (const char* error =
            ss->setOrientation(systemInfo[i*2+s].orientation)) {
          #ifdef DEBUG
          cerr << "Warning: Rejecting ship system with bad orientation: "
               << error << endl;
          #endif
          DESTROY(true);
        }
      }
    }

    //Ensure ship is valid
    if (const char* error = verify(X)) {
      #ifdef DEBUG
      cerr << "Warning: Discarding invalid ship: " << error << endl;
      #endif
      DESTROY(true);
    }
  
   if (!X->ignoreNetworkTag) X->tag = tag; 

      X->setColour(colourR, colourG, colourB);
    
 X->theta = theta; 
 X->vtheta = vtheta; 

      X->cosTheta = cos(X->theta);
      X->sinTheta = sin(X->theta);
    

      X->setReinforcement(reinforcement);
    

      X->insignia = insignia;
    

      if (isFragment) {
        X->spontaneouslyDie();
      } else {
        cxn->setReference(X);
      }
    

      X->setStealthMode(stealthMode);
    

      X->configureEngines(thrustPercent, thrustOn, brakeOn);
    
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStrength(shields[0+ARRAY_OFFSET].currStrengthPercent/255.0f *
                                   gen->getStrength());
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStability(shields[0+ARRAY_OFFSET].currStability/255.0f);
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldAlpha(shields[0+ARRAY_OFFSET].currAlpha/255.0f);
        }
      
}
  #undef X
  #undef field
  #undef DESTROY
  return dst;
}

bool ENO_Ship::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
char tag[128];
char target[128];
float theta;
float vtheta;
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
    S(const Ship* X) {
      vx = X->vx;
vy = X->vy;
x = X->x;
y = X->y;
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 

      if (X->networkCells.empty()) {
        for (unsigned i = 0; i < X->cells.size(); ++i) {
          if (!X->cells[i]->isEmpty) {
            X->cells[i]->netIndex = X->networkCells.size();
            const_cast<Ship*>(X)->networkCells.push_back(X->cells[i]);
          }
        }
      }
    

      if (X->target.ref)
        strncpy(target, X->target.ref->tag.c_str(), 128);
      else
        target[0]=0;
    
theta = X->theta;
vtheta = X->vtheta;
thrustPercent = X->thrustPercent;
reinforcement = X->reinforcement;

      currentCapacitancePercent = 255*X->getCapacitancePercent();
    
insignia = X->insignia;

      isFragment = X->isFragment;
    
thrustOn = X->thrustOn;
brakeOn = X->brakeOn;
shieldsDeactivated = X->shieldsDeactivated;
stealthMode = X->stealthMode;

      rootIsBridge = (X->cells[0]->usage == CellBridge);
    

      rootTheta = X->cells[0]->getT();
    
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        cellDamage[0+ARRAY_OFFSET] = max((byte)1,
                   (byte)(255 - 255*c->getCurrDamage()/c->getMaxDamage()));
      } else {
        cellDamage[0+ARRAY_OFFSET] = 0; //Nonexistent
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          systemExist[0+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          systemExist[1+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          systemExist[2+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          systemExist[3+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          systemExist[4+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          systemExist[5+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          systemExist[6+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          systemExist[7+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].radius = gen->getRadius();
          else
            shields[0+ARRAY_OFFSET].radius = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].maxStrength = (byte)gen->getStrength();
          else
            shields[0+ARRAY_OFFSET].maxStrength = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStrengthPercent =
                (byte)(255*gen->getShieldStrength()/gen->getStrength());
          else
            shields[0+ARRAY_OFFSET].currStrengthPercent = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStability = (byte)(255.0f*gen->getShieldStability());
          else
            shields[0+ARRAY_OFFSET].currStability = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currAlpha = (byte)(255.0f * gen->getShieldAlpha());
          else
            shields[0+ARRAY_OFFSET].currAlpha = 0;
        }
      
}
    }
  } x(static_cast<Ship*>(local.ref)), y(static_cast<Ship*>(remote));

  
      if (strcmp(x.tag, y.tag)) return true; //Must send update
    

      //Only prioritise updating the target if near
      if (strcmp(x.target, y.target))
        NEAR += 100;
    

      if (x.isFragment != y.isFragment)
        return true; //MUST update
    
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      //If one is zero and the other not, we must send an update
      if ((x.cellDamage[0+ARRAY_OFFSET] == 0) != (y.cellDamage[0+ARRAY_OFFSET] == 0))
        return true;

      //Consider 10% difference worth it at close range; don't care at far
      NEAR += fabs((x.cellDamage[0+ARRAY_OFFSET]-y.cellDamage[0+ARRAY_OFFSET])/25.6f);
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        //Usually send updates for differences when near
        NEAR +=
          fabs((float)x.shields[0+ARRAY_OFFSET].currStrengthPercent - y.shields[0+ARRAY_OFFSET].currStrengthPercent);
      

        NEAR += fabs((float)x.shields[0+ARRAY_OFFSET].currStability - y.shields[0+ARRAY_OFFSET].currStability);
      

        NEAR += fabs((float)x.shields[0+ARRAY_OFFSET].currAlpha - y.shields[0+ARRAY_OFFSET].currAlpha);
      
}

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR > l_dist) || (NEAR > 1 && l_dist < 5);
}

void ENO_Ship::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  #define DESTROY(x) assert(!(x))
  Ship* l_local = static_cast<Ship*>(this->local.ref);
  Ship* l_remote = static_cast<Ship*>(this->remote);
  float vx;
float vy;
float x;
float y;
char tag[128];
char target[128];
float theta;
float vtheta;
float thrustPercent;
float reinforcement;
unsigned char currentCapacitancePercent;
unsigned long long insignia;
bool isFragment;
bool thrustOn;
bool brakeOn;
bool shieldsDeactivated;
bool stealthMode;
bool rootIsBridge;
signed short rootTheta;
unsigned char cellDamage[4094];
bool systemExist[8192];
struct {
    float radius;
    byte maxStrength, currStrengthPercent, currStability, currAlpha;
  } shields[4094];
  #define X l_local
  for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].radius = gen->getRadius();
          else
            shields[0+ARRAY_OFFSET].radius = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].maxStrength = (byte)gen->getStrength();
          else
            shields[0+ARRAY_OFFSET].maxStrength = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStrengthPercent =
                (byte)(255*gen->getShieldStrength()/gen->getStrength());
          else
            shields[0+ARRAY_OFFSET].currStrengthPercent = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currStability = (byte)(255.0f*gen->getShieldStability());
          else
            shields[0+ARRAY_OFFSET].currStability = 0;
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            shields[0+ARRAY_OFFSET].currAlpha = (byte)(255.0f * gen->getShieldAlpha());
          else
            shields[0+ARRAY_OFFSET].currAlpha = 0;
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::write_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[0+0], shields[0+ARRAY_OFFSET].radius);
io::write_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[4+0], shields[0+ARRAY_OFFSET].maxStrength);
io::write_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[5+0], shields[0+ARRAY_OFFSET].currStrengthPercent);
io::write_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[6+0], shields[0+ARRAY_OFFSET].currStability);
io::write_c(&(&DATA[0]+47394+ARRAY_OFFSET*8)[7+0], shields[0+ARRAY_OFFSET].currAlpha);
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          systemExist[0+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          systemExist[1+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          systemExist[2+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          systemExist[3+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          systemExist[4+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          systemExist[5+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          systemExist[6+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          systemExist[7+ARRAY_OFFSET] = (X->networkCells.size() > cellix
              &&  X->networkCells[cellix]
              &&  X->networkCells[cellix]->systems[sysix]);
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<0); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[0+ARRAY_OFFSET] & 1) << 0;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<1); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[1+ARRAY_OFFSET] & 1) << 1;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<2); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[2+ARRAY_OFFSET] & 1) << 2;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<3); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[3+ARRAY_OFFSET] & 1) << 3;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<4); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[4+ARRAY_OFFSET] & 1) << 4;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<5); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[5+ARRAY_OFFSET] & 1) << 5;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<6); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[6+ARRAY_OFFSET] & 1) << 6;
(&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] &= ~(1<<7); (&DATA[0]+29994+ARRAY_OFFSET*1)[0+0] |= (systemExist[7+ARRAY_OFFSET] & 1) << 7;
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        cellDamage[0+ARRAY_OFFSET] = max((byte)1,
                   (byte)(255 - 255*c->getCurrDamage()/c->getMaxDamage()));
      } else {
        cellDamage[0+ARRAY_OFFSET] = 0; //Nonexistent
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {
io::write_c(&(&DATA[0]+25900+ARRAY_OFFSET*1)[0+0], cellDamage[0+ARRAY_OFFSET]);
}

      rootTheta = X->cells[0]->getT();
    
io::write_c(&DATA[310+0], rootTheta);

      rootIsBridge = (X->cells[0]->usage == CellBridge);
    
DATA[309+0] &= ~(1<<5); DATA[309+0] |= (rootIsBridge & 1) << 5;
stealthMode = X->stealthMode;
DATA[309+0] &= ~(1<<4); DATA[309+0] |= (stealthMode & 1) << 4;
shieldsDeactivated = X->shieldsDeactivated;
DATA[309+0] &= ~(1<<3); DATA[309+0] |= (shieldsDeactivated & 1) << 3;
brakeOn = X->brakeOn;
DATA[309+0] &= ~(1<<2); DATA[309+0] |= (brakeOn & 1) << 2;
thrustOn = X->thrustOn;
DATA[309+0] &= ~(1<<1); DATA[309+0] |= (thrustOn & 1) << 1;

      isFragment = X->isFragment;
    
DATA[309+0] &= ~(1<<0); DATA[309+0] |= (isFragment & 1) << 0;
insignia = X->insignia;
io::write_c(&DATA[301+0], insignia);

      currentCapacitancePercent = 255*X->getCapacitancePercent();
    
io::write_c(&DATA[300+0], currentCapacitancePercent);
reinforcement = X->reinforcement;
io::write_c(&DATA[296+0], reinforcement);
thrustPercent = X->thrustPercent;
io::write_c(&DATA[292+0], thrustPercent);
vtheta = X->vtheta;
io::write_c(&DATA[288+0], vtheta);
theta = X->theta;
io::write_c(&DATA[284+0], theta);

      if (X->target.ref)
        strncpy(target, X->target.ref->tag.c_str(), 128);
      else
        target[0]=0;
    
strncpy((char*)&DATA[144+0], target, 128);

      if (X->networkCells.empty()) {
        for (unsigned i = 0; i < X->cells.size(); ++i) {
          if (!X->cells[i]->isEmpty) {
            X->cells[i]->netIndex = X->networkCells.size();
            const_cast<Ship*>(X)->networkCells.push_back(X->cells[i]);
          }
        }
      }
    
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
y = X->y;
io::write_c(&DATA[12+0], y);
x = X->x;
io::write_c(&DATA[8+0], x);
vy = X->vy;
io::write_c(&DATA[4+0], vy);
vx = X->vx;
io::write_c(&DATA[0+0], vx);
  #undef X
  #define X l_remote
  X->vx = vx;
X->vy = vy;
X->x = x;
X->y = y;
 if (!X->ignoreNetworkTag) X->tag = tag; 

      if (target[0]) {
        //Stop immediately if no change
        if (X->target.ref
        &&  0 == strcmp(target, X->target.ref->tag.c_str()))
          goto targetFound;

        //Seacrh the field for such a ship
        {
          GameField::iterator it = field->begin(), end = field->end();
          for (; it != end; ++it) {
            GameObject* go = *it;
            if (go->getClassification() == GameObject::ClassShip) {
              Ship* s = (Ship*)go;
              if (s->hasPower()
              &&  Allies != getAlliance(X->insignia, s->insignia)
              &&  0 == strcmp(target, s->tag.c_str())) {
                //Found
                X->target.assign(s);
                goto targetFound;
              }
            }
          }
        }

        //Not found
        X->target.assign(NULL);

        targetFound:;
      } else {
        X->target.assign(NULL);
      }
    
X->theta = theta;
X->vtheta = vtheta;

      X->cosTheta = cos(X->theta);
      X->sinTheta = sin(X->theta);
    



      X->physicsRequire(PHYS_SHIP_CAPAC_BIT);
      X->currentCapacitance=X->totalCapacitance*
                            currentCapacitancePercent/255.0f;
    
X->insignia = insignia;

      if (isFragment && !X->isFragment) {
        X->spontaneouslyDie();
        cxn->unsetReference(X);
      }
    



      shield_deactivate(X);
      X->shieldsDeactivated=true;
      //Clear all cell power bits that have shields
      X->physicsRequire(PHYS_SHIP_SHIELD_INVENTORY_BIT);
      for (unsigned i=0; i<X->shields.size(); ++i)
        X->shields[i]->getParent()->physicsClear(PHYS_CELL_POWER_BITS
                                                |PHYS_CELL_POWER_PROD_BITS);
      X->shields.clear();
    

      X->setStealthMode(stealthMode);
    

      X->configureEngines(thrustPercent, thrustOn, brakeOn);
    
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

      if ((0+ARRAY_OFFSET) < X->networkCells.size() && X->networkCells[(0+ARRAY_OFFSET)]) {
        Cell*const c = X->networkCells[(0+ARRAY_OFFSET)];
        if (!cellDamage[0+ARRAY_OFFSET] && !(0+ARRAY_OFFSET)) {
          //Illegal attempt to destroy root; ignore
          #ifdef DEBUG
          cerr << "Warning: Ignoring illegal attempt to destroy Ship root!"
               << endl;
          #endif
          DESTROY(true);
        }
        if (!cellDamage[0+ARRAY_OFFSET]) {
          //Delink the cell from its neighbours, spawning PlasmaFires
          //if appropriate.
          for (unsigned n = 0; n < 4; ++n) {
            if (c->neighbours[n]) {
              unsigned ret = c->neighbours[n]->getNeighbour(c);
              EmptyCell* ec = new EmptyCell(X, c->neighbours[n]);
              c->neighbours[n]->neighbours[ret] = ec;
              if (highQuality && EXPCLOSE(x,y))
                field->add(new PlasmaFire(ec));
            }
          }

          //Spawn fragments if appropriate
          pair<float,float> coord = X->cellCoord(X, c);
          Blast blast(field, 0, coord.first, coord.second,
                      STD_CELL_SZ/2, c->getMaxDamage()-c->getCurrDamage(),
                      true, STD_CELL_SZ/16, false, true, false);
          CellFragment::spawn(c, &blast);

          //Destroy systems within cell
          if (c->systems[0]) c->systems[0]->destroy(0xFFFFFF);
          if (c->systems[1]) c->systems[1]->destroy(0xFFFFFF);
          //Remove cell from ship
          X->preremove(c);
          #ifndef AB_OPENGL_14
          if (X->renderer)
            X->renderer->cellRemoved(c);
          #endif
          X->removeCell(c);
          X->networkCells[(0+ARRAY_OFFSET)] = NULL;

          //Free
          delete c;
        } else {
          //Damage the cell by the appropriate amount
          float newdmg = 1.0f - cellDamage[0+ARRAY_OFFSET]/255.0f;
          newdmg *= c->getMaxDamage();
          float olddmg = c->getCurrDamage();
          #ifndef NDEBUG
          bool destroyed =
          #endif
          c->applyDamage(newdmg-olddmg, 0xFFFFFF);
          assert(!destroyed);
          X->cellDamaged(c);
        }
      }
    
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<8192; ARRAY_OFFSET+=8) {

        {
          unsigned cellix = (0+ARRAY_OFFSET)/2;
          unsigned sysix = (0+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[0+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (1+ARRAY_OFFSET)/2;
          unsigned sysix = (1+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[1+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (2+ARRAY_OFFSET)/2;
          unsigned sysix = (2+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[2+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (3+ARRAY_OFFSET)/2;
          unsigned sysix = (3+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[3+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (4+ARRAY_OFFSET)/2;
          unsigned sysix = (4+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[4+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (5+ARRAY_OFFSET)/2;
          unsigned sysix = (5+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[5+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (6+ARRAY_OFFSET)/2;
          unsigned sysix = (6+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[6+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      

        {
          unsigned cellix = (7+ARRAY_OFFSET)/2;
          unsigned sysix = (7+ARRAY_OFFSET)&1;
          //Check for system destruction
          if (!systemExist[7+ARRAY_OFFSET]
          &&  X->networkCells.size() > cellix
          &&  X->networkCells[cellix]
          &&  X->networkCells[cellix]->systems[sysix]) {
            //Destroy it
            X->networkCells[cellix]->systems[sysix]->destroy(0xFFFFFF);
            delete X->networkCells[cellix]->systems[sysix];
            X->networkCells[cellix]->systems[sysix] = NULL;
            X->networkCells[cellix]->physicsClear(PHYS_CELL_ALL|PHYS_SHIP_ALL);
            X->cellChanged(X->networkCells[cellix]);
          }
        }
      
}
for (unsigned ARRAY_OFFSET=0; ARRAY_OFFSET<4094; ARRAY_OFFSET+=1) {

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStrength(shields[0+ARRAY_OFFSET].currStrengthPercent/255.0f *
                                   gen->getStrength());
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldStability(shields[0+ARRAY_OFFSET].currStability/255.0f);
        }
      

        {
          ShieldGenerator* gen = SHGEN((0+ARRAY_OFFSET));
          if (gen)
            gen->setShieldAlpha(shields[0+ARRAY_OFFSET].currAlpha/255.0f);
        }
      
}
  #undef X
  #undef DATA
  #undef T
  #undef DESTROY
  #undef field
}

      ShieldGenerator* INO_Ship::getShieldGenerator(const Cell* c) throw() {
        if (!c) return NULL;
        if (c->systems[0]
        &&  c->systems[0]->clazz == Classification_Shield)
          return static_cast<ShieldGenerator*>(c->systems[0]);
        if (c->systems[1]
        &&  c->systems[1]->clazz == Classification_Shield)
          return static_cast<ShieldGenerator*>(c->systems[1]);
        return NULL;
      }
    


  #include "../synchronous_control_geraet.hxx"
  ExportedGameObject* createObjectExport(NetworkConnection* cxn,
                                         GameObject* object)
  throw() {
    ExportedGameObject* ego;

if (typeid(*object) == typeid(EnergyCharge))
  ego = new ENO_EnergyCharge(cxn, (EnergyCharge*)object);
else
if (typeid(*object) == typeid(MagnetoBomb))
  ego = new ENO_MagnetoBomb(cxn, (MagnetoBomb*)object);
else
if (typeid(*object) == typeid(SemiguidedBomb))
  ego = new ENO_SemiguidedBomb(cxn, (SemiguidedBomb*)object);
else
if (typeid(*object) == typeid(PlasmaBurst))
  ego = new ENO_PlasmaBurst(cxn, (PlasmaBurst*)object);
else
if (typeid(*object) == typeid(Missile))
  ego = new ENO_Missile(cxn, (Missile*)object);
else
if (typeid(*object) == typeid(ParticleEmitter))
  ego = new ENO_ParticleEmitter(cxn, (ParticleEmitter*)object);
else
if (typeid(*object) == typeid(Spectator))
  ego = new ENO_Spectator(cxn, (Spectator*)object);
else
if (typeid(*object) == typeid(Ship))
  ego = new ENO_Ship(cxn, (Ship*)object);
else

  {
    cerr << "FATAL: Unknown object type to export: "
         << typeid(*object).name() << endl;
    assert(false);
    exit(EXIT_PROGRAM_BUG);
  }

  assert(ego);
  cxn->scg->openChannel(ego, INO_Ship::num);
  return ego;
}
