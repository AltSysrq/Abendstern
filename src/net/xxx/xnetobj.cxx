
  /**
   * @file
   * @author src/net/generate.tcl
   * @brief Autogenerated. Do not edit!
   */

  #include <cstring>

  #include "xnetobj.hxx"
  #include "../io.hxx"

  using namespace std;
  //These diagnostics will happen alot due to the way code is
  //generated; they are safe to ignore.
  #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
  #pragma GCC diagnostic ignored "-Wunused-variable"


  #include "src/sim/game_object.hxx"
  #include "src/ship/everything.hxx"
  #include "src/weapon/energy_charge.hxx"
  #include "src/weapon/magneto_bomb.hxx"
  #include "src/weapon/plasma_burst.hxx"
  #include "src/weapon/semiguided_bomb.hxx"
  #include "src/weapon/missile.hxx"
  #include "src/weapon/monophasic_energy_pulse.hxx"
  #include "src/weapon/particle_beam.hxx"

#ifdef NEAR
#undef NEAR
#endif
#ifdef FAR
#undef FAR
#endif

INO_EnergyCharge::INO_EnergyCharge(NetworkConnection* cxn_)
: ImportedGameObject(153, cxn_),
  cxn(cxn_)
{ }

void INO_EnergyCharge::construct() throw() {
  object = decodeConstruct(state);
}

void INO_EnergyCharge::update() throw() {
  if (decodeUpdate(state, static_cast<EnergyCharge*>(object)))
    destroy();
}

EnergyCharge* INO_EnergyCharge::decodeConstruct(const std::vector<byte>& DATA)
const throw() {
  float vx;
float vy;
float x;
float y;
char tag[128];
float intensity;
float theta;
bool exploded;
  io::read_c(&DATA[0+0], vx);
io::read_c(&DATA[4+0], vy);
io::read_c(&DATA[8+0], x);
io::read_c(&DATA[12+0], y);
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
io::read_c(&DATA[144+0], intensity);
io::read_c(&DATA[148+0], theta);
exploded = (DATA[152+0] >> 0) & 1;
  EnergyCharge* X;
  
     X = new EnergyCharge(field, x, y, vx, vy, theta, intensity);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
  return X;
}

bool INO_EnergyCharge::decodeUpdate(const std::vector<byte>& DATA, EnergyCharge* X)
const throw () {
  bool DESTROY = false;
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float intensity;
float theta;
bool exploded;
  io::read_c(&DATA[0+0], vx);
 X->vx = vx; 
io::read_c(&DATA[4+0], vy);
 X->vy = vy; 
io::read_c(&DATA[8+0], x);
 X->x = max(0.0f, min(field->width, x + T*vx)); 
io::read_c(&DATA[12+0], y);
 X->y = max(0.0f, min(field->height, y + T*vy)); 
strncpy(tag, (const char*)&DATA[16+0], 128-1); tag[128-1]=0;
 if (!X->ignoreNetworkTag) X->tag = tag; 
io::read_c(&DATA[144+0], intensity);
 X->intensity = max(0.0f,min(1.0f,intensity)); 
io::read_c(&DATA[148+0], theta);
exploded = (DATA[152+0] >> 0) & 1;

      if (!X->exploded && exploded)
        X->explode(NULL);
    
  return DESTROY;
}

ENO_EnergyCharge::ENO_EnergyCharge(NetworkConnection* cxn, EnergyCharge* obj)
: ExportedGameObject(153, cxn, obj, clone(obj))
{ }

EnergyCharge* ENO_EnergyCharge::clone(const EnergyCharge* src) const throw() {
  #define X src
  #define field (&this->cxn->field)
  const unsigned T = cxn->getLatency();
  float vx;
float vy;
float x;
float y;
char tag[128];
float intensity;
float theta;
bool exploded;
   exploded = X->exploded; 
 theta = X->theta; 
 intensity = X->intensity; 
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
 y = X->y; 
 x = X->x; 
 vy = X->vy; 
 vx = X->vx; 
  #undef X
  EnergyCharge* dst;
  #define X dst
  
     X = new EnergyCharge(field, x, y, vx, vy, theta, intensity);
  
   if (!X->ignoreNetworkTag) X->tag = tag; 
  #undef X
  #undef field
  return dst;
}

bool ENO_EnergyCharge::shouldUpdate() const throw() {
  float NEAR = 0, FAR = 0;
  struct S {
    float vx;
float vy;
float x;
float y;
char tag[128];
float intensity;
float theta;
bool exploded;
    S(const EnergyCharge* X) {
       vx = X->vx; 
 vy = X->vy; 
 x = X->x; 
 y = X->y; 
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
 intensity = X->intensity; 
 theta = X->theta; 
 exploded = X->exploded; 
    }
  } x(static_cast<EnergyCharge*>(local.ref)), y(static_cast<EnergyCharge*>(remote));

   return false; 
{
      float delta = fabs(x.vx - y.vx);
      //Consider 1 screen/sec to be too much at 10 screens
      NEAR += delta*10000;
      FAR += delta*10000;
    }
{
      float delta = fabs(x.vy - y.vy);
      NEAR += delta*10000;
      FAR += delta*10000;
    }
{
      float delta = fabs(x.x - y.x);
      NEAR += delta*32;
      FAR += delta*32;
    }
{
      float delta = fabs(x.y + y.y);
      NEAR += delta*32;
      FAR += delta*32;
    }

      if (strcmp(x.tag, y.tag)) return true; //Must send update
    

  float l_dist = cxn->distanceOf(this->local.ref);
  return (FAR > l_dist) || (NEAR > 1 && l_dist < 5);
}

void ENO_EnergyCharge::updateRemote() throw() {
  #define T 0
  #define DATA (this->state)
  #define field (&this->cxn->field)
  EnergyCharge* l_local = static_cast<EnergyCharge*>(this->local.ref);
  EnergyCharge* l_remote = static_cast<EnergyCharge*>(this->remote);
  float vx;
float vy;
float x;
float y;
char tag[128];
float intensity;
float theta;
bool exploded;
  #define X l_local
   exploded = X->exploded; 
DATA[152+0] &= ~(1<<0); DATA[152+0] |= (exploded & 1) << 0;
 theta = X->theta; 
io::write_c(&DATA[148+0], theta);
 intensity = X->intensity; 
io::write_c(&DATA[144+0], intensity);
 strncpy(tag, X->tag.c_str(), sizeof(tag-1)); 
strncpy((char*)&DATA[16+0], tag, 128);
 y = X->y; 
io::write_c(&DATA[12+0], y);
 x = X->x; 
io::write_c(&DATA[8+0], x);
 vy = X->vy; 
io::write_c(&DATA[4+0], vy);
 vx = X->vx; 
io::write_c(&DATA[0+0], vx);
  #undef X
  #define X l_remote
   X->vx = vx; 
 X->vy = vy; 
 X->x = max(0.0f, min(field->width, x + T*vx)); 
 X->y = max(0.0f, min(field->height, y + T*vy)); 
 if (!X->ignoreNetworkTag) X->tag = tag; 
 X->intensity = max(0.0f,min(1.0f,intensity)); 

      if (!X->exploded && exploded)
        X->explode(NULL);
    
  #undef X
  #undef DATA
  #undef T
  #undef field
}

