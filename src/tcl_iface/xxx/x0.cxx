
  /**
   * @file
   * @author C++-Tcl Bridge Code Generator
   * @brief Autogenerated bindings; <b>not intended for human consumption</b>
   *
   * AUTOGENERATED BY generate.tcl. DO NOT EDIT DIRECTLY.
   * @see src/tcl_iface/readme.txt
   */

  #include <map>
  #include <set>
  #include <vector>
  #include <string>
  #include <cstring>
  #include <cstdio>
  #include <cstdlib>
  #include <iostream>

  #include <GL/gl.h>
  #include <SDL.h>
  #include <tcl.h>
  #include <itcl.h>
  #include <libconfig.h++>

  #include "src/tcl_iface/bridge.hxx"
  #include "src/tcl_iface/implementation.hxx"
  #include "src/tcl_iface/dynfun.hxx"
  #include "src/exit_conditions.hxx"
  #include "src/globals.hxx"

  #pragma GCC diagnostic ignored "-Wunused-label"
  #pragma GCC diagnostic ignored "-Waddress"
  using namespace std;
  using namespace tcl_glue_implementation;
  using namespace libconfig;

  //Commands get their zeroth argument as their own name;
  //code generation is simpler if we drop this
  #define SHIFT ++objv, --objc

#include "src/background/explosion.hxx"
#include "src/sim/game_field.hxx"
#include "src/background/planet.hxx"
#include "src/secondary/planet_generator.hxx"
#include "src/net/game_discoverer.hxx"
#include "src/net/tuner.hxx"
#include "src/net/antenna.hxx"

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      
     
     
     cppDelete(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

class TclExplosion : public Explosion {
      public:
static int get409 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get409", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Explosion* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Explosion)
        &&  0==ex->type->superclasses.count(&typeid(Explosion))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Explosion, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Explosion* tmp=(Explosion*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewBooleanObj(parent->hungry);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set410 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set410", TCL_VOLATILE);
        return TCL_ERROR;
      }
      bool newVal;
      Explosion* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Explosion)
        &&  0==ex->type->superclasses.count(&typeid(Explosion))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Explosion, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Explosion* tmp=(Explosion*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int gen1744;
            int err = Tcl_GetBooleanFromObj(interp, objv[1], (int*)&gen1744);
            newVal=gen1744;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->hungry = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

TclExplosion(GameField* arg2, ExplosionType arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11) : Explosion(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Explosion* constructorstationary
    (const string& name, const string& magicCookie,  GameField* arg2, ExplosionType arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Explosion* ret;
      ret=new Explosion(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Explosion)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline412 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 12) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
ExplosionType arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
float arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
float arg8; bool arg8Init=false;
float arg9; bool arg9Init=false;
float arg10; bool arg10Init=false;
float arg11; bool arg11Init=false;
Explosion* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{
        const char* tmp = Tcl_GetStringFromObj(objv[3], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "Explosion::Simple")) {arg3=Explosion::Simple; goto done1746;}
        
          if (0 == strcmp(tmp, "Explosion::Spark")) {arg3=Explosion::Spark; goto done1746;}
        
          if (0 == strcmp(tmp, "Explosion::BigSpark")) {arg3=Explosion::BigSpark; goto done1746;}
        
          if (0 == strcmp(tmp, "Explosion::Sparkle")) {arg3=Explosion::Sparkle; goto done1746;}
        
          if (0 == strcmp(tmp, "Explosion::Incursion")) {arg3=Explosion::Incursion; goto done1746;}
        
          if (0 == strcmp(tmp, "Explosion::Flame")) {arg3=Explosion::Flame; goto done1746;}
        
          if (0 == strcmp(tmp, "Explosion::Invisible")) {arg3=Explosion::Invisible; goto done1746;}
         {
          sprintf(staticError, "Unable to convert %s to ExplosionType", tmp);
          scriptError(staticError);
        } 
done1746:;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg5 = (float)tmp;};
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[8], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg8 = (float)tmp;};
arg8Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[9], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg9 = (float)tmp;};
arg9Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[10], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg10 = (float)tmp;};
arg10Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[11], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg11 = (float)tmp;};
arg11Init=true;
try {
      ret =
     
     
     constructorstationary(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
if (arg8Init) {arg8Init=false; }
if (arg9Init) {arg9Init=false; }
if (arg10Init) {arg10Init=false; }
if (arg11Init) {arg11Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

TclExplosion(GameField* arg2, ExplosionType arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11, float arg12, float arg13) : Explosion(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Explosion* constructorvelocity
    (const string& name, const string& magicCookie,  GameField* arg2, ExplosionType arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11, float arg12, float arg13) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Explosion* ret;
      ret=new Explosion(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Explosion)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline414 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 14) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
ExplosionType arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
float arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
float arg8; bool arg8Init=false;
float arg9; bool arg9Init=false;
float arg10; bool arg10Init=false;
float arg11; bool arg11Init=false;
float arg12; bool arg12Init=false;
float arg13; bool arg13Init=false;
Explosion* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{
        const char* tmp = Tcl_GetStringFromObj(objv[3], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "Explosion::Simple")) {arg3=Explosion::Simple; goto done1748;}
        
          if (0 == strcmp(tmp, "Explosion::Spark")) {arg3=Explosion::Spark; goto done1748;}
        
          if (0 == strcmp(tmp, "Explosion::BigSpark")) {arg3=Explosion::BigSpark; goto done1748;}
        
          if (0 == strcmp(tmp, "Explosion::Sparkle")) {arg3=Explosion::Sparkle; goto done1748;}
        
          if (0 == strcmp(tmp, "Explosion::Incursion")) {arg3=Explosion::Incursion; goto done1748;}
        
          if (0 == strcmp(tmp, "Explosion::Flame")) {arg3=Explosion::Flame; goto done1748;}
        
          if (0 == strcmp(tmp, "Explosion::Invisible")) {arg3=Explosion::Invisible; goto done1748;}
         {
          sprintf(staticError, "Unable to convert %s to ExplosionType", tmp);
          scriptError(staticError);
        } 
done1748:;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg5 = (float)tmp;};
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[8], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg8 = (float)tmp;};
arg8Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[9], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg9 = (float)tmp;};
arg9Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[10], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg10 = (float)tmp;};
arg10Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[11], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg11 = (float)tmp;};
arg11Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[12], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg12 = (float)tmp;};
arg12Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[13], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg13 = (float)tmp;};
arg13Init=true;
try {
      ret =
     
     
     constructorvelocity(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
if (arg8Init) {arg8Init=false; }
if (arg9Init) {arg9Init=false; }
if (arg10Init) {arg10Init=false; }
if (arg11Init) {arg11Init=false; }
if (arg12Init) {arg12Init=false; }
if (arg13Init) {arg13Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

TclExplosion(GameField* arg2, ExplosionType arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11, float arg12, float arg13, float arg14, float arg15) : Explosion(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Explosion* constructorsmeared
    (const string& name, const string& magicCookie,  GameField* arg2, ExplosionType arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, float arg10, float arg11, float arg12, float arg13, float arg14, float arg15) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Explosion* ret;
      ret=new Explosion(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Explosion)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline416 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 16) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
ExplosionType arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
float arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
float arg8; bool arg8Init=false;
float arg9; bool arg9Init=false;
float arg10; bool arg10Init=false;
float arg11; bool arg11Init=false;
float arg12; bool arg12Init=false;
float arg13; bool arg13Init=false;
float arg14; bool arg14Init=false;
float arg15; bool arg15Init=false;
Explosion* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{
        const char* tmp = Tcl_GetStringFromObj(objv[3], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "Explosion::Simple")) {arg3=Explosion::Simple; goto done1750;}
        
          if (0 == strcmp(tmp, "Explosion::Spark")) {arg3=Explosion::Spark; goto done1750;}
        
          if (0 == strcmp(tmp, "Explosion::BigSpark")) {arg3=Explosion::BigSpark; goto done1750;}
        
          if (0 == strcmp(tmp, "Explosion::Sparkle")) {arg3=Explosion::Sparkle; goto done1750;}
        
          if (0 == strcmp(tmp, "Explosion::Incursion")) {arg3=Explosion::Incursion; goto done1750;}
        
          if (0 == strcmp(tmp, "Explosion::Flame")) {arg3=Explosion::Flame; goto done1750;}
        
          if (0 == strcmp(tmp, "Explosion::Invisible")) {arg3=Explosion::Invisible; goto done1750;}
         {
          sprintf(staticError, "Unable to convert %s to ExplosionType", tmp);
          scriptError(staticError);
        } 
done1750:;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg5 = (float)tmp;};
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[8], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg8 = (float)tmp;};
arg8Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[9], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg9 = (float)tmp;};
arg9Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[10], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg10 = (float)tmp;};
arg10Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[11], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg11 = (float)tmp;};
arg11Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[12], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg12 = (float)tmp;};
arg12Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[13], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg13 = (float)tmp;};
arg13Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[14], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg14 = (float)tmp;};
arg14Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[15], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg15 = (float)tmp;};
arg15Init=true;
try {
      ret =
     
     
     constructorsmeared(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
if (arg8Init) {arg8Init=false; }
if (arg9Init) {arg9Init=false; }
if (arg10Init) {arg10Init=false; }
if (arg11Init) {arg11Init=false; }
if (arg12Init) {arg12Init=false; }
if (arg13Init) {arg13Init=false; }
if (arg14Init) {arg14Init=false; }
if (arg15Init) {arg15Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

TclExplosion(GameField* arg2, ExplosionType arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, GameObject* arg10) : Explosion(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Explosion* constructorby
    (const string& name, const string& magicCookie,  GameField* arg2, ExplosionType arg3, float arg4, float arg5, float arg6, float arg7, float arg8, float arg9, GameObject* arg10) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Explosion* ret;
      ret=new Explosion(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Explosion)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline418 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 11) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
ExplosionType arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
float arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
float arg8; bool arg8Init=false;
float arg9; bool arg9Init=false;
GameObject* arg10; bool arg10Init=false;
Explosion* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{
        const char* tmp = Tcl_GetStringFromObj(objv[3], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "Explosion::Simple")) {arg3=Explosion::Simple; goto done1752;}
        
          if (0 == strcmp(tmp, "Explosion::Spark")) {arg3=Explosion::Spark; goto done1752;}
        
          if (0 == strcmp(tmp, "Explosion::BigSpark")) {arg3=Explosion::BigSpark; goto done1752;}
        
          if (0 == strcmp(tmp, "Explosion::Sparkle")) {arg3=Explosion::Sparkle; goto done1752;}
        
          if (0 == strcmp(tmp, "Explosion::Incursion")) {arg3=Explosion::Incursion; goto done1752;}
        
          if (0 == strcmp(tmp, "Explosion::Flame")) {arg3=Explosion::Flame; goto done1752;}
        
          if (0 == strcmp(tmp, "Explosion::Invisible")) {arg3=Explosion::Invisible; goto done1752;}
         {
          sprintf(staticError, "Unable to convert %s to ExplosionType", tmp);
          scriptError(staticError);
        } 
done1752:;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg5 = (float)tmp;};
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[8], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg8 = (float)tmp;};
arg8Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[9], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg9 = (float)tmp;};
arg9Init=true;
{
      string name(Tcl_GetStringFromObj(objv[10], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameObject)
        &&  0==ex->type->superclasses.count(&typeid(GameObject))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameObject, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameObject* tmp=(GameObject*)ex->ptr;
        
        arg10 = tmp;
    } else arg10=NULL;
};
arg10Init=true;
try {
      ret =
     
     
     constructorby(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
if (arg8Init) {arg8Init=false; }
if (arg9Init) {arg9Init=false; }
if (arg10Init) {arg10Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline420 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Explosion* parent=NULL;
int arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Explosion)
        &&  0==ex->type->superclasses.count(&typeid(Explosion))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Explosion, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Explosion* tmp=(Explosion*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (int)tmp;};
arg0Init=true;
try {
      
     parent->
     
     multiExplosion(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline422 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Explosion* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Explosion)
        &&  0==ex->type->superclasses.count(&typeid(Explosion))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Explosion, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Explosion* tmp=(Explosion*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getColourR();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline424 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Explosion* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Explosion)
        &&  0==ex->type->superclasses.count(&typeid(Explosion))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Explosion, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Explosion* tmp=(Explosion*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getColourG();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline426 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Explosion* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Explosion)
        &&  0==ex->type->superclasses.count(&typeid(Explosion))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Explosion, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Explosion* tmp=(Explosion*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getColourB();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline428 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Explosion* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Explosion)
        &&  0==ex->type->superclasses.count(&typeid(Explosion))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Explosion, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Explosion* tmp=(Explosion*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getSize();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline430 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Explosion* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Explosion)
        &&  0==ex->type->superclasses.count(&typeid(Explosion))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Explosion, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Explosion* tmp=(Explosion*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getDensity();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ get409", get409, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set410", set410, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline412", trampoline412, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline414", trampoline414, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline416", trampoline416, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline418", trampoline418, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline420", trampoline420, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline422", trampoline422, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline424", trampoline424, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline426", trampoline426, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline428", trampoline428, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline430", trampoline430, 0, NULL);
TypeExport* ste=new TypeExport(typeid(Explosion)),
                           * ete=new TypeExport(typeid(TclExplosion));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="Explosion";
ste->superclasses.insert(&typeid(GameObject));
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(Explosion));
typeExports[&typeid(Explosion)]=ste;
typeExports[&typeid(TclExplosion)]=ete;
}
};
void classdec408(bool safe, Tcl_Interp* interp) throw() {
  TclExplosion::cppDecCode(safe,interp);
}

class TclPlanet : public Planet {
      public:
TclPlanet(GameObject* arg2, GameField* arg3, const char* arg4, const char* arg5, float arg6, float arg7, float arg8, float arg9) : Planet(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Planet* constructordefault
    (const string& name, const string& magicCookie,  GameObject* arg2, GameField* arg3, const char* arg4, const char* arg5, float arg6, float arg7, float arg8, float arg9) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Planet* ret;
      ret=new Planet(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Planet)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline715 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 10) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameObject* arg2; bool arg2Init=false;
GameField* arg3; bool arg3Init=false;
const char* arg4; bool arg4Init=false;
const char* arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
float arg8; bool arg8Init=false;
float arg9; bool arg9Init=false;
Planet* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameObject)
        &&  0==ex->type->superclasses.count(&typeid(GameObject))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameObject, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameObject* tmp=(GameObject*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{
      string name(Tcl_GetStringFromObj(objv[3], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg3 = tmp;
    } else arg3=NULL;
};
arg3Init=true;
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[4], &length);
          arg4 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg4Init=true;
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[5], &length);
          arg5 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[8], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg8 = (float)tmp;};
arg8Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[9], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg9 = (float)tmp;};
arg9Init=true;
try {
      ret =
     
     
     constructordefault(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
if (arg8Init) {arg8Init=false; }
if (arg9Init) {arg9Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline715", trampoline715, 0, NULL);
TypeExport* ste=new TypeExport(typeid(Planet)),
                           * ete=new TypeExport(typeid(TclPlanet));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="Planet";
ste->superclasses.insert(&typeid(Background));
ste->superclasses.insert(&typeid(EffectsHandler));
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(Planet));
typeExports[&typeid(Planet)]=ste;
typeExports[&typeid(TclPlanet)]=ete;
}
};
void classdec714(bool safe, Tcl_Interp* interp) throw() {
  TclPlanet::cppDecCode(safe,interp);
}

 int get954 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get954", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)planetgen::width);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get956 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get956", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)planetgen::height);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

class Tclplanetgen_colon_u_colon_Parameters : public planetgen::Parameters {
      public:
Tclplanetgen_colon_u_colon_Parameters() : planetgen::Parameters() {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static planetgen::Parameters* constructordefault
    (const string& name, const string& magicCookie ) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      planetgen::Parameters* ret;
      ret=new planetgen::Parameters();
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(planetgen::Parameters)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline959 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
planetgen::Parameters* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      ret =
     
     
     constructordefault(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static int get961 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get961", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->seed);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set962 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set962", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->seed = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get964 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get964", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->continents);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set965 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set965", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->continents = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get967 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get967", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->largeIslands);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set968 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set968", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->largeIslands = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get970 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get970", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->smallIslands);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set971 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set971", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->smallIslands = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get973 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get973", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->islandGrouping);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set974 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set974", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->islandGrouping = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get976 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get976", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->landSlope);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set977 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set977", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->landSlope = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get979 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get979", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->oceans);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set980 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set980", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->oceans = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get982 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get982", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->seas);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set983 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set983", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->seas = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get985 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get985", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->lakes);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set986 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set986", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->lakes = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get988 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get988", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->rivers);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set989 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set989", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->rivers = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get991 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get991", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->mountainRanges);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set992 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set992", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->mountainRanges = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get994 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get994", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->mountainSteepness);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set995 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set995", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->mountainSteepness = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get997 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get997", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->enormousMountains);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set998 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set998", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->enormousMountains = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1000 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1000", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->craters);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1001 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1001", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->craters = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1003 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1003", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->maxCraterSize);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1004 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1004", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->maxCraterSize = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1006 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1006", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->equatorTemperature);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1007 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1007", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->equatorTemperature = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1009 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1009", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->solarEquator);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1010 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1010", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->solarEquator = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1012 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1012", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->polarTemperature);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1013 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1013", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->polarTemperature = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1015 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1015", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->altitudeTemperatureDelta);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1016 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1016", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->altitudeTemperatureDelta = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1018 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1018", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->waterTemperatureDelta);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1019 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1019", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->waterTemperatureDelta = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1021 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1021", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->freezingPoint);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1022 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1022", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->freezingPoint = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1024 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1024", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->humidity);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1025 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1025", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->humidity = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1027 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1027", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->vapourTransport);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1028 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1028", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->vapourTransport = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1030 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1030", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->mountainBlockage);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1031 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1031", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->mountainBlockage = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1033 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1033", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->vegitationHumidity);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1034 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1034", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->vegitationHumidity = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1036 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1036", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->cities);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1037 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1037", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->cities = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1039 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1039", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->maxCitySize);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1040 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1040", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->maxCitySize = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1042 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1042", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->cityGrouping);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1043 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1043", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->cityGrouping = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1045 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1045", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->waterColour);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1046 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1046", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->waterColour = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1048 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1048", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->vegitationColour);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1049 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1049", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->vegitationColour = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1051 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1051", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->lowerPlanetColour);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1052 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1052", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->lowerPlanetColour = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1054 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1054", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->upperPlanetColour);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set1055 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1055", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      planetgen::Parameters* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->upperPlanetColour = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline959", trampoline959, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get961", get961, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set962", set962, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get964", get964, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set965", set965, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get967", get967, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set968", set968, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get970", get970, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set971", set971, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get973", get973, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set974", set974, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get976", get976, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set977", set977, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get979", get979, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set980", set980, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get982", get982, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set983", set983, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get985", get985, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set986", set986, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get988", get988, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set989", set989, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get991", get991, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set992", set992, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get994", get994, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set995", set995, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get997", get997, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set998", set998, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1000", get1000, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1001", set1001, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1003", get1003, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1004", set1004, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1006", get1006, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1007", set1007, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1009", get1009, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1010", set1010, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1012", get1012, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1013", set1013, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1015", get1015, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1016", set1016, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1018", get1018, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1019", set1019, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1021", get1021, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1022", set1022, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1024", get1024, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1025", set1025, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1027", get1027, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1028", set1028, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1030", get1030, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1031", set1031, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1033", get1033, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1034", set1034, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1036", get1036, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1037", set1037, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1039", get1039, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1040", set1040, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1042", get1042, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1043", set1043, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1045", get1045, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1046", set1046, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1048", get1048, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1049", set1049, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1051", get1051, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1052", set1052, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1054", get1054, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set1055", set1055, 0, NULL);
TypeExport* ste=new TypeExport(typeid(planetgen::Parameters)),
                           * ete=new TypeExport(typeid(Tclplanetgen_colon_u_colon_Parameters));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="PlanetGeneratorParms";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(planetgen::Parameters));
typeExports[&typeid(planetgen::Parameters)]=ste;
typeExports[&typeid(Tclplanetgen_colon_u_colon_Parameters)]=ete;
}
};
void classdec958(bool safe, Tcl_Interp* interp) throw() {
  Tclplanetgen_colon_u_colon_Parameters::cppDecCode(safe,interp);
}

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1057 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
planetgen::Parameters* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(planetgen::Parameters)
        &&  0==ex->type->superclasses.count(&typeid(planetgen::Parameters))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " planetgen::Parameters, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        planetgen::Parameters* tmp=(planetgen::Parameters*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      
     
     
     planetgen::begin(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1059 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
const char* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      ret =
     
     
     planetgen::what();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(ret? ret : "", -1, &dstr);
        retTcl = Tcl_NewUnicodeObj(tuc, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1061 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      ret =
     
     
     planetgen::progress();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1063 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      ret =
     
     
     planetgen::done();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1065 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      
     
     
     planetgen::kill();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1067 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
const char* arg0; bool arg0Init=false;
const char* arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
          arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg0Init=true;
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
          arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg1Init=true;
try {
      
     
     
     planetgen::save(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


class TclGameDiscoverer : public GameDiscoverer {
      public:
TclGameDiscoverer(Tuner* arg2) : GameDiscoverer(arg2) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static GameDiscoverer* constructordefault
    (const string& name, const string& magicCookie,  Tuner* arg2) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      GameDiscoverer* ret;
      ret=new GameDiscoverer(arg2);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(GameDiscoverer)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1269 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
Tuner* arg2; bool arg2Init=false;
GameDiscoverer* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Tuner)
        &&  0==ex->type->superclasses.count(&typeid(Tuner))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Tuner, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Tuner* tmp=(Tuner*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
try {
      ret =
     
     
     constructordefault(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1271 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       GameDiscoverer* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameDiscoverer)
        &&  0==ex->type->superclasses.count(&typeid(GameDiscoverer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameDiscoverer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameDiscoverer* tmp=(GameDiscoverer*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     start();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1273 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       GameDiscoverer* parent=NULL;
Antenna* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameDiscoverer)
        &&  0==ex->type->superclasses.count(&typeid(GameDiscoverer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameDiscoverer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameDiscoverer* tmp=(GameDiscoverer*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Antenna)
        &&  0==ex->type->superclasses.count(&typeid(Antenna))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Antenna, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Antenna* tmp=(Antenna*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      
     parent->
     
     poll(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1275 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       GameDiscoverer* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameDiscoverer)
        &&  0==ex->type->superclasses.count(&typeid(GameDiscoverer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameDiscoverer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameDiscoverer* tmp=(GameDiscoverer*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     progress();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline1269", trampoline1269, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1271", trampoline1271, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1273", trampoline1273, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1275", trampoline1275, 0, NULL);
TypeExport* ste=new TypeExport(typeid(GameDiscoverer)),
                           * ete=new TypeExport(typeid(TclGameDiscoverer));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="GameDiscoverer";
ste->superclasses.insert(&typeid(PacketProcessor));
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(GameDiscoverer));
typeExports[&typeid(GameDiscoverer)]=ste;
typeExports[&typeid(TclGameDiscoverer)]=ete;
}
};
void classdec1268(bool safe, Tcl_Interp* interp) throw() {
  TclGameDiscoverer::cppDecCode(safe,interp);
}


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1572 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      
     
     
     debugTclExports();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


