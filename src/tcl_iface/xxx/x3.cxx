
  /**
   * @file
   * @author C++-Tcl Bridge Code Generator
   * @brief Autogenerated bindings; <b>not intended for human consumption</b>
   *
   * AUTOGENERATED BY generate.tcl. DO NOT EDIT DIRECTLY.
   * @see src/tcl_iface/readme.txt
   */

  #include <map>
  #include <set>
  #include <vector>
  #include <string>
  #include <cstring>
  #include <cstdio>
  #include <cstdlib>
  #include <iostream>

  #include <GL/gl.h>
  #include <SDL.h>
  #include <tcl.h>
  #include <itcl.h>
  #include <libconfig.h++>

  #include "src/tcl_iface/bridge.hxx"
  #include "src/tcl_iface/implementation.hxx"
  #include "src/tcl_iface/dynfun.hxx"
  #include "src/exit_conditions.hxx"
  #include "src/globals.hxx"

  #pragma GCC diagnostic ignored "-Wunused-label"
  #pragma GCC diagnostic ignored "-Waddress"
  using namespace std;
  using namespace tcl_glue_implementation;
  using namespace libconfig;

  //Commands get their zeroth argument as their own name;
  //code generation is simpler if we drop this
  #define SHIFT ++objv, --objc

#include "src/ship/ship.hxx"
#include "src/camera/camera.hxx"
#include "src/globals.hxx"
#include "src/core/game_state.hxx"
#include "src/net/network_game.hxx"
#include "src/net/network_connection.hxx"
#include "src/net/abuhops.hxx"
 int get59 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get59", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDLK_LAST);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline61 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
SDLKey arg0; bool arg0Init=false;
unsigned ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
        const char* tmp = Tcl_GetStringFromObj(objv[0], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "k_unknown")) {arg0=SDLK_UNKNOWN; goto done1577;}
        
          if (0 == strcmp(tmp, "k_enter")) {arg0=SDLK_RETURN; goto done1577;}
        
          if (0 == strcmp(tmp, "k_scrolllock")) {arg0=SDLK_SCROLLOCK; goto done1577;}
        
          if (0 == strcmp(tmp, "k_backspace")) {arg0=SDLK_BACKSPACE; goto done1577;}
        
          if (0 == strcmp(tmp, "k_tab")) {arg0=SDLK_TAB; goto done1577;}
        
          if (0 == strcmp(tmp, "k_clear")) {arg0=SDLK_CLEAR; goto done1577;}
        
          if (0 == strcmp(tmp, "k_pause")) {arg0=SDLK_PAUSE; goto done1577;}
        
          if (0 == strcmp(tmp, "k_escape")) {arg0=SDLK_ESCAPE; goto done1577;}
        
          if (0 == strcmp(tmp, "k_space")) {arg0=SDLK_SPACE; goto done1577;}
        
          if (0 == strcmp(tmp, "k_exclaim")) {arg0=SDLK_EXCLAIM; goto done1577;}
        
          if (0 == strcmp(tmp, "k_quotedbl")) {arg0=SDLK_QUOTEDBL; goto done1577;}
        
          if (0 == strcmp(tmp, "k_hash")) {arg0=SDLK_HASH; goto done1577;}
        
          if (0 == strcmp(tmp, "k_dollar")) {arg0=SDLK_DOLLAR; goto done1577;}
        
          if (0 == strcmp(tmp, "k_ampersand")) {arg0=SDLK_AMPERSAND; goto done1577;}
        
          if (0 == strcmp(tmp, "k_quote")) {arg0=SDLK_QUOTE; goto done1577;}
        
          if (0 == strcmp(tmp, "k_leftparen")) {arg0=SDLK_LEFTPAREN; goto done1577;}
        
          if (0 == strcmp(tmp, "k_rightparen")) {arg0=SDLK_RIGHTPAREN; goto done1577;}
        
          if (0 == strcmp(tmp, "k_asterisk")) {arg0=SDLK_ASTERISK; goto done1577;}
        
          if (0 == strcmp(tmp, "k_plus")) {arg0=SDLK_PLUS; goto done1577;}
        
          if (0 == strcmp(tmp, "k_comma")) {arg0=SDLK_COMMA; goto done1577;}
        
          if (0 == strcmp(tmp, "k_minus")) {arg0=SDLK_MINUS; goto done1577;}
        
          if (0 == strcmp(tmp, "k_period")) {arg0=SDLK_PERIOD; goto done1577;}
        
          if (0 == strcmp(tmp, "k_slash")) {arg0=SDLK_SLASH; goto done1577;}
        
          if (0 == strcmp(tmp, "k_0")) {arg0=SDLK_0; goto done1577;}
        
          if (0 == strcmp(tmp, "k_1")) {arg0=SDLK_1; goto done1577;}
        
          if (0 == strcmp(tmp, "k_2")) {arg0=SDLK_2; goto done1577;}
        
          if (0 == strcmp(tmp, "k_3")) {arg0=SDLK_3; goto done1577;}
        
          if (0 == strcmp(tmp, "k_4")) {arg0=SDLK_4; goto done1577;}
        
          if (0 == strcmp(tmp, "k_5")) {arg0=SDLK_5; goto done1577;}
        
          if (0 == strcmp(tmp, "k_6")) {arg0=SDLK_6; goto done1577;}
        
          if (0 == strcmp(tmp, "k_7")) {arg0=SDLK_7; goto done1577;}
        
          if (0 == strcmp(tmp, "k_8")) {arg0=SDLK_8; goto done1577;}
        
          if (0 == strcmp(tmp, "k_9")) {arg0=SDLK_9; goto done1577;}
        
          if (0 == strcmp(tmp, "k_colon")) {arg0=SDLK_COLON; goto done1577;}
        
          if (0 == strcmp(tmp, "k_semicolon")) {arg0=SDLK_SEMICOLON; goto done1577;}
        
          if (0 == strcmp(tmp, "k_less")) {arg0=SDLK_LESS; goto done1577;}
        
          if (0 == strcmp(tmp, "k_equals")) {arg0=SDLK_EQUALS; goto done1577;}
        
          if (0 == strcmp(tmp, "k_greater")) {arg0=SDLK_GREATER; goto done1577;}
        
          if (0 == strcmp(tmp, "k_question")) {arg0=SDLK_QUESTION; goto done1577;}
        
          if (0 == strcmp(tmp, "k_at")) {arg0=SDLK_AT; goto done1577;}
        
          if (0 == strcmp(tmp, "k_leftbracket")) {arg0=SDLK_LEFTBRACKET; goto done1577;}
        
          if (0 == strcmp(tmp, "k_backslash")) {arg0=SDLK_BACKSLASH; goto done1577;}
        
          if (0 == strcmp(tmp, "k_rightbracket")) {arg0=SDLK_RIGHTBRACKET; goto done1577;}
        
          if (0 == strcmp(tmp, "k_caret")) {arg0=SDLK_CARET; goto done1577;}
        
          if (0 == strcmp(tmp, "k_underscore")) {arg0=SDLK_UNDERSCORE; goto done1577;}
        
          if (0 == strcmp(tmp, "k_backquote")) {arg0=SDLK_BACKQUOTE; goto done1577;}
        
          if (0 == strcmp(tmp, "k_delete")) {arg0=SDLK_DELETE; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp0")) {arg0=SDLK_KP0; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp1")) {arg0=SDLK_KP1; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp2")) {arg0=SDLK_KP2; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp3")) {arg0=SDLK_KP3; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp4")) {arg0=SDLK_KP4; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp5")) {arg0=SDLK_KP5; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp6")) {arg0=SDLK_KP6; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp7")) {arg0=SDLK_KP7; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp8")) {arg0=SDLK_KP8; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp9")) {arg0=SDLK_KP9; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp_period")) {arg0=SDLK_KP_PERIOD; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp_divide")) {arg0=SDLK_KP_DIVIDE; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp_multiply")) {arg0=SDLK_KP_MULTIPLY; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp_minus")) {arg0=SDLK_KP_MINUS; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp_plus")) {arg0=SDLK_KP_PLUS; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp_enter")) {arg0=SDLK_KP_ENTER; goto done1577;}
        
          if (0 == strcmp(tmp, "k_kp_equals")) {arg0=SDLK_KP_EQUALS; goto done1577;}
        
          if (0 == strcmp(tmp, "k_up")) {arg0=SDLK_UP; goto done1577;}
        
          if (0 == strcmp(tmp, "k_down")) {arg0=SDLK_DOWN; goto done1577;}
        
          if (0 == strcmp(tmp, "k_right")) {arg0=SDLK_RIGHT; goto done1577;}
        
          if (0 == strcmp(tmp, "k_left")) {arg0=SDLK_LEFT; goto done1577;}
        
          if (0 == strcmp(tmp, "k_insert")) {arg0=SDLK_INSERT; goto done1577;}
        
          if (0 == strcmp(tmp, "k_home")) {arg0=SDLK_HOME; goto done1577;}
        
          if (0 == strcmp(tmp, "k_end")) {arg0=SDLK_END; goto done1577;}
        
          if (0 == strcmp(tmp, "k_pageup")) {arg0=SDLK_PAGEUP; goto done1577;}
        
          if (0 == strcmp(tmp, "k_pagedown")) {arg0=SDLK_PAGEDOWN; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f1")) {arg0=SDLK_F1; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f2")) {arg0=SDLK_F2; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f3")) {arg0=SDLK_F3; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f4")) {arg0=SDLK_F4; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f5")) {arg0=SDLK_F5; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f6")) {arg0=SDLK_F6; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f7")) {arg0=SDLK_F7; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f8")) {arg0=SDLK_F8; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f9")) {arg0=SDLK_F9; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f10")) {arg0=SDLK_F10; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f11")) {arg0=SDLK_F11; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f12")) {arg0=SDLK_F12; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f13")) {arg0=SDLK_F13; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f14")) {arg0=SDLK_F14; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f15")) {arg0=SDLK_F15; goto done1577;}
        
          if (0 == strcmp(tmp, "k_numlock")) {arg0=SDLK_NUMLOCK; goto done1577;}
        
          if (0 == strcmp(tmp, "k_capslock")) {arg0=SDLK_CAPSLOCK; goto done1577;}
        
          if (0 == strcmp(tmp, "k_rshift")) {arg0=SDLK_RSHIFT; goto done1577;}
        
          if (0 == strcmp(tmp, "k_lshift")) {arg0=SDLK_LSHIFT; goto done1577;}
        
          if (0 == strcmp(tmp, "k_rctrl")) {arg0=SDLK_RCTRL; goto done1577;}
        
          if (0 == strcmp(tmp, "k_lctrl")) {arg0=SDLK_LCTRL; goto done1577;}
        
          if (0 == strcmp(tmp, "k_ralt")) {arg0=SDLK_RALT; goto done1577;}
        
          if (0 == strcmp(tmp, "k_lalt")) {arg0=SDLK_LALT; goto done1577;}
        
          if (0 == strcmp(tmp, "k_rmeta")) {arg0=SDLK_RMETA; goto done1577;}
        
          if (0 == strcmp(tmp, "k_lmeta")) {arg0=SDLK_LMETA; goto done1577;}
        
          if (0 == strcmp(tmp, "k_lsuper")) {arg0=SDLK_LSUPER; goto done1577;}
        
          if (0 == strcmp(tmp, "k_rsuper")) {arg0=SDLK_RSUPER; goto done1577;}
        
          if (0 == strcmp(tmp, "k_mode")) {arg0=SDLK_MODE; goto done1577;}
        
          if (0 == strcmp(tmp, "k_compose")) {arg0=SDLK_COMPOSE; goto done1577;}
        
          if (0 == strcmp(tmp, "k_help")) {arg0=SDLK_HELP; goto done1577;}
        
          if (0 == strcmp(tmp, "k_print")) {arg0=SDLK_PRINT; goto done1577;}
        
          if (0 == strcmp(tmp, "k_sysreq")) {arg0=SDLK_SYSREQ; goto done1577;}
        
          if (0 == strcmp(tmp, "k_break")) {arg0=SDLK_BREAK; goto done1577;}
        
          if (0 == strcmp(tmp, "k_menu")) {arg0=SDLK_MENU; goto done1577;}
        
          if (0 == strcmp(tmp, "k_power")) {arg0=SDLK_POWER; goto done1577;}
        
          if (0 == strcmp(tmp, "k_euro")) {arg0=SDLK_EURO; goto done1577;}
        
          if (0 == strcmp(tmp, "k_undo")) {arg0=SDLK_UNDO; goto done1577;}
        
          if (0 == strcmp(tmp, "k_a")) {arg0=SDLK_a; goto done1577;}
        
          if (0 == strcmp(tmp, "k_b")) {arg0=SDLK_b; goto done1577;}
        
          if (0 == strcmp(tmp, "k_c")) {arg0=SDLK_c; goto done1577;}
        
          if (0 == strcmp(tmp, "k_d")) {arg0=SDLK_d; goto done1577;}
        
          if (0 == strcmp(tmp, "k_e")) {arg0=SDLK_e; goto done1577;}
        
          if (0 == strcmp(tmp, "k_f")) {arg0=SDLK_f; goto done1577;}
        
          if (0 == strcmp(tmp, "k_g")) {arg0=SDLK_g; goto done1577;}
        
          if (0 == strcmp(tmp, "k_h")) {arg0=SDLK_h; goto done1577;}
        
          if (0 == strcmp(tmp, "k_i")) {arg0=SDLK_i; goto done1577;}
        
          if (0 == strcmp(tmp, "k_j")) {arg0=SDLK_j; goto done1577;}
        
          if (0 == strcmp(tmp, "k_k")) {arg0=SDLK_k; goto done1577;}
        
          if (0 == strcmp(tmp, "k_l")) {arg0=SDLK_l; goto done1577;}
        
          if (0 == strcmp(tmp, "k_m")) {arg0=SDLK_m; goto done1577;}
        
          if (0 == strcmp(tmp, "k_n")) {arg0=SDLK_n; goto done1577;}
        
          if (0 == strcmp(tmp, "k_o")) {arg0=SDLK_o; goto done1577;}
        
          if (0 == strcmp(tmp, "k_p")) {arg0=SDLK_p; goto done1577;}
        
          if (0 == strcmp(tmp, "k_q")) {arg0=SDLK_q; goto done1577;}
        
          if (0 == strcmp(tmp, "k_r")) {arg0=SDLK_r; goto done1577;}
        
          if (0 == strcmp(tmp, "k_s")) {arg0=SDLK_s; goto done1577;}
        
          if (0 == strcmp(tmp, "k_t")) {arg0=SDLK_t; goto done1577;}
        
          if (0 == strcmp(tmp, "k_u")) {arg0=SDLK_u; goto done1577;}
        
          if (0 == strcmp(tmp, "k_v")) {arg0=SDLK_v; goto done1577;}
        
          if (0 == strcmp(tmp, "k_w")) {arg0=SDLK_w; goto done1577;}
        
          if (0 == strcmp(tmp, "k_x")) {arg0=SDLK_x; goto done1577;}
        
          if (0 == strcmp(tmp, "k_y")) {arg0=SDLK_y; goto done1577;}
        
          if (0 == strcmp(tmp, "k_z")) {arg0=SDLK_z; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_0")) {arg0=SDLK_WORLD_0; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_1")) {arg0=SDLK_WORLD_1; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_2")) {arg0=SDLK_WORLD_2; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_3")) {arg0=SDLK_WORLD_3; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_4")) {arg0=SDLK_WORLD_4; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_5")) {arg0=SDLK_WORLD_5; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_6")) {arg0=SDLK_WORLD_6; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_7")) {arg0=SDLK_WORLD_7; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_8")) {arg0=SDLK_WORLD_8; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_9")) {arg0=SDLK_WORLD_9; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_10")) {arg0=SDLK_WORLD_10; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_11")) {arg0=SDLK_WORLD_11; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_12")) {arg0=SDLK_WORLD_12; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_13")) {arg0=SDLK_WORLD_13; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_14")) {arg0=SDLK_WORLD_14; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_15")) {arg0=SDLK_WORLD_15; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_16")) {arg0=SDLK_WORLD_16; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_17")) {arg0=SDLK_WORLD_17; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_18")) {arg0=SDLK_WORLD_18; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_19")) {arg0=SDLK_WORLD_19; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_20")) {arg0=SDLK_WORLD_20; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_21")) {arg0=SDLK_WORLD_21; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_22")) {arg0=SDLK_WORLD_22; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_23")) {arg0=SDLK_WORLD_23; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_24")) {arg0=SDLK_WORLD_24; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_25")) {arg0=SDLK_WORLD_25; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_26")) {arg0=SDLK_WORLD_26; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_27")) {arg0=SDLK_WORLD_27; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_28")) {arg0=SDLK_WORLD_28; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_29")) {arg0=SDLK_WORLD_29; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_30")) {arg0=SDLK_WORLD_30; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_31")) {arg0=SDLK_WORLD_31; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_32")) {arg0=SDLK_WORLD_32; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_33")) {arg0=SDLK_WORLD_33; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_34")) {arg0=SDLK_WORLD_34; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_35")) {arg0=SDLK_WORLD_35; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_36")) {arg0=SDLK_WORLD_36; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_37")) {arg0=SDLK_WORLD_37; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_38")) {arg0=SDLK_WORLD_38; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_39")) {arg0=SDLK_WORLD_39; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_40")) {arg0=SDLK_WORLD_40; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_41")) {arg0=SDLK_WORLD_41; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_42")) {arg0=SDLK_WORLD_42; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_43")) {arg0=SDLK_WORLD_43; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_44")) {arg0=SDLK_WORLD_44; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_45")) {arg0=SDLK_WORLD_45; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_46")) {arg0=SDLK_WORLD_46; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_47")) {arg0=SDLK_WORLD_47; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_48")) {arg0=SDLK_WORLD_48; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_49")) {arg0=SDLK_WORLD_49; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_50")) {arg0=SDLK_WORLD_50; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_51")) {arg0=SDLK_WORLD_51; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_52")) {arg0=SDLK_WORLD_52; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_53")) {arg0=SDLK_WORLD_53; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_54")) {arg0=SDLK_WORLD_54; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_55")) {arg0=SDLK_WORLD_55; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_56")) {arg0=SDLK_WORLD_56; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_57")) {arg0=SDLK_WORLD_57; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_58")) {arg0=SDLK_WORLD_58; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_59")) {arg0=SDLK_WORLD_59; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_60")) {arg0=SDLK_WORLD_60; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_61")) {arg0=SDLK_WORLD_61; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_62")) {arg0=SDLK_WORLD_62; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_63")) {arg0=SDLK_WORLD_63; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_64")) {arg0=SDLK_WORLD_64; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_65")) {arg0=SDLK_WORLD_65; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_66")) {arg0=SDLK_WORLD_66; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_67")) {arg0=SDLK_WORLD_67; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_68")) {arg0=SDLK_WORLD_68; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_69")) {arg0=SDLK_WORLD_69; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_70")) {arg0=SDLK_WORLD_70; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_71")) {arg0=SDLK_WORLD_71; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_72")) {arg0=SDLK_WORLD_72; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_73")) {arg0=SDLK_WORLD_73; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_74")) {arg0=SDLK_WORLD_74; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_75")) {arg0=SDLK_WORLD_75; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_76")) {arg0=SDLK_WORLD_76; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_77")) {arg0=SDLK_WORLD_77; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_78")) {arg0=SDLK_WORLD_78; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_79")) {arg0=SDLK_WORLD_79; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_80")) {arg0=SDLK_WORLD_80; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_81")) {arg0=SDLK_WORLD_81; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_82")) {arg0=SDLK_WORLD_82; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_83")) {arg0=SDLK_WORLD_83; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_84")) {arg0=SDLK_WORLD_84; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_85")) {arg0=SDLK_WORLD_85; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_86")) {arg0=SDLK_WORLD_86; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_87")) {arg0=SDLK_WORLD_87; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_88")) {arg0=SDLK_WORLD_88; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_89")) {arg0=SDLK_WORLD_89; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_90")) {arg0=SDLK_WORLD_90; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_91")) {arg0=SDLK_WORLD_91; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_92")) {arg0=SDLK_WORLD_92; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_93")) {arg0=SDLK_WORLD_93; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_94")) {arg0=SDLK_WORLD_94; goto done1577;}
        
          if (0 == strcmp(tmp, "k_world_95")) {arg0=SDLK_WORLD_95; goto done1577;}
         {
          char* end;
          arg0 = (SDLKey)strtol(tmp, &end, 10);
          if (*end) {
            sprintf(staticError, "Unable to convert %s to SDLKey", tmp);
            scriptError(staticError);
          }
          goto done1577;
        } 
done1577:;};
arg0Init=true;
try {
      ret =
     
     
     SDLKeyToInt(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

 int get63 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get63", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_NONE);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get65 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get65", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_LSHIFT);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get67 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get67", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_RSHIFT);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get69 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get69", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_LCTRL);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get71 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get71", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_RCTRL);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get73 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get73", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_LALT);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get75 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get75", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_RALT);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get77 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get77", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_LMETA);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get79 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get79", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_RMETA);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get81 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get81", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_NUM);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get83 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get83", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_CAPS);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get85 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get85", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_MODE);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get87 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get87", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_RESERVED);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

class TclSDL_keysym : public SDL_keysym {
      public:
static int get90 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get90", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->scancode);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set91 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set91", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint8)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->scancode = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get93 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get93", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->sym)
      {

          case SDLK_UNKNOWN: tmp="k_unknown"; break;
          case SDLK_RETURN: tmp="k_enter"; break;
          case SDLK_SCROLLOCK: tmp="k_scrolllock"; break;
          case SDLK_BACKSPACE: tmp="k_backspace"; break;
          case SDLK_TAB: tmp="k_tab"; break;
          case SDLK_CLEAR: tmp="k_clear"; break;
          case SDLK_PAUSE: tmp="k_pause"; break;
          case SDLK_ESCAPE: tmp="k_escape"; break;
          case SDLK_SPACE: tmp="k_space"; break;
          case SDLK_EXCLAIM: tmp="k_exclaim"; break;
          case SDLK_QUOTEDBL: tmp="k_quotedbl"; break;
          case SDLK_HASH: tmp="k_hash"; break;
          case SDLK_DOLLAR: tmp="k_dollar"; break;
          case SDLK_AMPERSAND: tmp="k_ampersand"; break;
          case SDLK_QUOTE: tmp="k_quote"; break;
          case SDLK_LEFTPAREN: tmp="k_leftparen"; break;
          case SDLK_RIGHTPAREN: tmp="k_rightparen"; break;
          case SDLK_ASTERISK: tmp="k_asterisk"; break;
          case SDLK_PLUS: tmp="k_plus"; break;
          case SDLK_COMMA: tmp="k_comma"; break;
          case SDLK_MINUS: tmp="k_minus"; break;
          case SDLK_PERIOD: tmp="k_period"; break;
          case SDLK_SLASH: tmp="k_slash"; break;
          case SDLK_0: tmp="k_0"; break;
          case SDLK_1: tmp="k_1"; break;
          case SDLK_2: tmp="k_2"; break;
          case SDLK_3: tmp="k_3"; break;
          case SDLK_4: tmp="k_4"; break;
          case SDLK_5: tmp="k_5"; break;
          case SDLK_6: tmp="k_6"; break;
          case SDLK_7: tmp="k_7"; break;
          case SDLK_8: tmp="k_8"; break;
          case SDLK_9: tmp="k_9"; break;
          case SDLK_COLON: tmp="k_colon"; break;
          case SDLK_SEMICOLON: tmp="k_semicolon"; break;
          case SDLK_LESS: tmp="k_less"; break;
          case SDLK_EQUALS: tmp="k_equals"; break;
          case SDLK_GREATER: tmp="k_greater"; break;
          case SDLK_QUESTION: tmp="k_question"; break;
          case SDLK_AT: tmp="k_at"; break;
          case SDLK_LEFTBRACKET: tmp="k_leftbracket"; break;
          case SDLK_BACKSLASH: tmp="k_backslash"; break;
          case SDLK_RIGHTBRACKET: tmp="k_rightbracket"; break;
          case SDLK_CARET: tmp="k_caret"; break;
          case SDLK_UNDERSCORE: tmp="k_underscore"; break;
          case SDLK_BACKQUOTE: tmp="k_backquote"; break;
          case SDLK_DELETE: tmp="k_delete"; break;
          case SDLK_KP0: tmp="k_kp0"; break;
          case SDLK_KP1: tmp="k_kp1"; break;
          case SDLK_KP2: tmp="k_kp2"; break;
          case SDLK_KP3: tmp="k_kp3"; break;
          case SDLK_KP4: tmp="k_kp4"; break;
          case SDLK_KP5: tmp="k_kp5"; break;
          case SDLK_KP6: tmp="k_kp6"; break;
          case SDLK_KP7: tmp="k_kp7"; break;
          case SDLK_KP8: tmp="k_kp8"; break;
          case SDLK_KP9: tmp="k_kp9"; break;
          case SDLK_KP_PERIOD: tmp="k_kp_period"; break;
          case SDLK_KP_DIVIDE: tmp="k_kp_divide"; break;
          case SDLK_KP_MULTIPLY: tmp="k_kp_multiply"; break;
          case SDLK_KP_MINUS: tmp="k_kp_minus"; break;
          case SDLK_KP_PLUS: tmp="k_kp_plus"; break;
          case SDLK_KP_ENTER: tmp="k_kp_enter"; break;
          case SDLK_KP_EQUALS: tmp="k_kp_equals"; break;
          case SDLK_UP: tmp="k_up"; break;
          case SDLK_DOWN: tmp="k_down"; break;
          case SDLK_RIGHT: tmp="k_right"; break;
          case SDLK_LEFT: tmp="k_left"; break;
          case SDLK_INSERT: tmp="k_insert"; break;
          case SDLK_HOME: tmp="k_home"; break;
          case SDLK_END: tmp="k_end"; break;
          case SDLK_PAGEUP: tmp="k_pageup"; break;
          case SDLK_PAGEDOWN: tmp="k_pagedown"; break;
          case SDLK_F1: tmp="k_f1"; break;
          case SDLK_F2: tmp="k_f2"; break;
          case SDLK_F3: tmp="k_f3"; break;
          case SDLK_F4: tmp="k_f4"; break;
          case SDLK_F5: tmp="k_f5"; break;
          case SDLK_F6: tmp="k_f6"; break;
          case SDLK_F7: tmp="k_f7"; break;
          case SDLK_F8: tmp="k_f8"; break;
          case SDLK_F9: tmp="k_f9"; break;
          case SDLK_F10: tmp="k_f10"; break;
          case SDLK_F11: tmp="k_f11"; break;
          case SDLK_F12: tmp="k_f12"; break;
          case SDLK_F13: tmp="k_f13"; break;
          case SDLK_F14: tmp="k_f14"; break;
          case SDLK_F15: tmp="k_f15"; break;
          case SDLK_NUMLOCK: tmp="k_numlock"; break;
          case SDLK_CAPSLOCK: tmp="k_capslock"; break;
          case SDLK_RSHIFT: tmp="k_rshift"; break;
          case SDLK_LSHIFT: tmp="k_lshift"; break;
          case SDLK_RCTRL: tmp="k_rctrl"; break;
          case SDLK_LCTRL: tmp="k_lctrl"; break;
          case SDLK_RALT: tmp="k_ralt"; break;
          case SDLK_LALT: tmp="k_lalt"; break;
          case SDLK_RMETA: tmp="k_rmeta"; break;
          case SDLK_LMETA: tmp="k_lmeta"; break;
          case SDLK_LSUPER: tmp="k_lsuper"; break;
          case SDLK_RSUPER: tmp="k_rsuper"; break;
          case SDLK_MODE: tmp="k_mode"; break;
          case SDLK_COMPOSE: tmp="k_compose"; break;
          case SDLK_HELP: tmp="k_help"; break;
          case SDLK_PRINT: tmp="k_print"; break;
          case SDLK_SYSREQ: tmp="k_sysreq"; break;
          case SDLK_BREAK: tmp="k_break"; break;
          case SDLK_MENU: tmp="k_menu"; break;
          case SDLK_POWER: tmp="k_power"; break;
          case SDLK_EURO: tmp="k_euro"; break;
          case SDLK_UNDO: tmp="k_undo"; break;
          case SDLK_a: tmp="k_a"; break;
          case SDLK_b: tmp="k_b"; break;
          case SDLK_c: tmp="k_c"; break;
          case SDLK_d: tmp="k_d"; break;
          case SDLK_e: tmp="k_e"; break;
          case SDLK_f: tmp="k_f"; break;
          case SDLK_g: tmp="k_g"; break;
          case SDLK_h: tmp="k_h"; break;
          case SDLK_i: tmp="k_i"; break;
          case SDLK_j: tmp="k_j"; break;
          case SDLK_k: tmp="k_k"; break;
          case SDLK_l: tmp="k_l"; break;
          case SDLK_m: tmp="k_m"; break;
          case SDLK_n: tmp="k_n"; break;
          case SDLK_o: tmp="k_o"; break;
          case SDLK_p: tmp="k_p"; break;
          case SDLK_q: tmp="k_q"; break;
          case SDLK_r: tmp="k_r"; break;
          case SDLK_s: tmp="k_s"; break;
          case SDLK_t: tmp="k_t"; break;
          case SDLK_u: tmp="k_u"; break;
          case SDLK_v: tmp="k_v"; break;
          case SDLK_w: tmp="k_w"; break;
          case SDLK_x: tmp="k_x"; break;
          case SDLK_y: tmp="k_y"; break;
          case SDLK_z: tmp="k_z"; break;
          case SDLK_WORLD_0: tmp="k_world_0"; break;
          case SDLK_WORLD_1: tmp="k_world_1"; break;
          case SDLK_WORLD_2: tmp="k_world_2"; break;
          case SDLK_WORLD_3: tmp="k_world_3"; break;
          case SDLK_WORLD_4: tmp="k_world_4"; break;
          case SDLK_WORLD_5: tmp="k_world_5"; break;
          case SDLK_WORLD_6: tmp="k_world_6"; break;
          case SDLK_WORLD_7: tmp="k_world_7"; break;
          case SDLK_WORLD_8: tmp="k_world_8"; break;
          case SDLK_WORLD_9: tmp="k_world_9"; break;
          case SDLK_WORLD_10: tmp="k_world_10"; break;
          case SDLK_WORLD_11: tmp="k_world_11"; break;
          case SDLK_WORLD_12: tmp="k_world_12"; break;
          case SDLK_WORLD_13: tmp="k_world_13"; break;
          case SDLK_WORLD_14: tmp="k_world_14"; break;
          case SDLK_WORLD_15: tmp="k_world_15"; break;
          case SDLK_WORLD_16: tmp="k_world_16"; break;
          case SDLK_WORLD_17: tmp="k_world_17"; break;
          case SDLK_WORLD_18: tmp="k_world_18"; break;
          case SDLK_WORLD_19: tmp="k_world_19"; break;
          case SDLK_WORLD_20: tmp="k_world_20"; break;
          case SDLK_WORLD_21: tmp="k_world_21"; break;
          case SDLK_WORLD_22: tmp="k_world_22"; break;
          case SDLK_WORLD_23: tmp="k_world_23"; break;
          case SDLK_WORLD_24: tmp="k_world_24"; break;
          case SDLK_WORLD_25: tmp="k_world_25"; break;
          case SDLK_WORLD_26: tmp="k_world_26"; break;
          case SDLK_WORLD_27: tmp="k_world_27"; break;
          case SDLK_WORLD_28: tmp="k_world_28"; break;
          case SDLK_WORLD_29: tmp="k_world_29"; break;
          case SDLK_WORLD_30: tmp="k_world_30"; break;
          case SDLK_WORLD_31: tmp="k_world_31"; break;
          case SDLK_WORLD_32: tmp="k_world_32"; break;
          case SDLK_WORLD_33: tmp="k_world_33"; break;
          case SDLK_WORLD_34: tmp="k_world_34"; break;
          case SDLK_WORLD_35: tmp="k_world_35"; break;
          case SDLK_WORLD_36: tmp="k_world_36"; break;
          case SDLK_WORLD_37: tmp="k_world_37"; break;
          case SDLK_WORLD_38: tmp="k_world_38"; break;
          case SDLK_WORLD_39: tmp="k_world_39"; break;
          case SDLK_WORLD_40: tmp="k_world_40"; break;
          case SDLK_WORLD_41: tmp="k_world_41"; break;
          case SDLK_WORLD_42: tmp="k_world_42"; break;
          case SDLK_WORLD_43: tmp="k_world_43"; break;
          case SDLK_WORLD_44: tmp="k_world_44"; break;
          case SDLK_WORLD_45: tmp="k_world_45"; break;
          case SDLK_WORLD_46: tmp="k_world_46"; break;
          case SDLK_WORLD_47: tmp="k_world_47"; break;
          case SDLK_WORLD_48: tmp="k_world_48"; break;
          case SDLK_WORLD_49: tmp="k_world_49"; break;
          case SDLK_WORLD_50: tmp="k_world_50"; break;
          case SDLK_WORLD_51: tmp="k_world_51"; break;
          case SDLK_WORLD_52: tmp="k_world_52"; break;
          case SDLK_WORLD_53: tmp="k_world_53"; break;
          case SDLK_WORLD_54: tmp="k_world_54"; break;
          case SDLK_WORLD_55: tmp="k_world_55"; break;
          case SDLK_WORLD_56: tmp="k_world_56"; break;
          case SDLK_WORLD_57: tmp="k_world_57"; break;
          case SDLK_WORLD_58: tmp="k_world_58"; break;
          case SDLK_WORLD_59: tmp="k_world_59"; break;
          case SDLK_WORLD_60: tmp="k_world_60"; break;
          case SDLK_WORLD_61: tmp="k_world_61"; break;
          case SDLK_WORLD_62: tmp="k_world_62"; break;
          case SDLK_WORLD_63: tmp="k_world_63"; break;
          case SDLK_WORLD_64: tmp="k_world_64"; break;
          case SDLK_WORLD_65: tmp="k_world_65"; break;
          case SDLK_WORLD_66: tmp="k_world_66"; break;
          case SDLK_WORLD_67: tmp="k_world_67"; break;
          case SDLK_WORLD_68: tmp="k_world_68"; break;
          case SDLK_WORLD_69: tmp="k_world_69"; break;
          case SDLK_WORLD_70: tmp="k_world_70"; break;
          case SDLK_WORLD_71: tmp="k_world_71"; break;
          case SDLK_WORLD_72: tmp="k_world_72"; break;
          case SDLK_WORLD_73: tmp="k_world_73"; break;
          case SDLK_WORLD_74: tmp="k_world_74"; break;
          case SDLK_WORLD_75: tmp="k_world_75"; break;
          case SDLK_WORLD_76: tmp="k_world_76"; break;
          case SDLK_WORLD_77: tmp="k_world_77"; break;
          case SDLK_WORLD_78: tmp="k_world_78"; break;
          case SDLK_WORLD_79: tmp="k_world_79"; break;
          case SDLK_WORLD_80: tmp="k_world_80"; break;
          case SDLK_WORLD_81: tmp="k_world_81"; break;
          case SDLK_WORLD_82: tmp="k_world_82"; break;
          case SDLK_WORLD_83: tmp="k_world_83"; break;
          case SDLK_WORLD_84: tmp="k_world_84"; break;
          case SDLK_WORLD_85: tmp="k_world_85"; break;
          case SDLK_WORLD_86: tmp="k_world_86"; break;
          case SDLK_WORLD_87: tmp="k_world_87"; break;
          case SDLK_WORLD_88: tmp="k_world_88"; break;
          case SDLK_WORLD_89: tmp="k_world_89"; break;
          case SDLK_WORLD_90: tmp="k_world_90"; break;
          case SDLK_WORLD_91: tmp="k_world_91"; break;
          case SDLK_WORLD_92: tmp="k_world_92"; break;
          case SDLK_WORLD_93: tmp="k_world_93"; break;
          case SDLK_WORLD_94: tmp="k_world_94"; break;
          case SDLK_WORLD_95: tmp="k_world_95"; break;
          default:
          tmp = "k_unknown"; break;
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set94 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set94", TCL_VOLATILE);
        return TCL_ERROR;
      }
      SDLKey newVal;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "k_unknown")) {newVal=SDLK_UNKNOWN; goto done1580;}
        
          if (0 == strcmp(tmp, "k_enter")) {newVal=SDLK_RETURN; goto done1580;}
        
          if (0 == strcmp(tmp, "k_scrolllock")) {newVal=SDLK_SCROLLOCK; goto done1580;}
        
          if (0 == strcmp(tmp, "k_backspace")) {newVal=SDLK_BACKSPACE; goto done1580;}
        
          if (0 == strcmp(tmp, "k_tab")) {newVal=SDLK_TAB; goto done1580;}
        
          if (0 == strcmp(tmp, "k_clear")) {newVal=SDLK_CLEAR; goto done1580;}
        
          if (0 == strcmp(tmp, "k_pause")) {newVal=SDLK_PAUSE; goto done1580;}
        
          if (0 == strcmp(tmp, "k_escape")) {newVal=SDLK_ESCAPE; goto done1580;}
        
          if (0 == strcmp(tmp, "k_space")) {newVal=SDLK_SPACE; goto done1580;}
        
          if (0 == strcmp(tmp, "k_exclaim")) {newVal=SDLK_EXCLAIM; goto done1580;}
        
          if (0 == strcmp(tmp, "k_quotedbl")) {newVal=SDLK_QUOTEDBL; goto done1580;}
        
          if (0 == strcmp(tmp, "k_hash")) {newVal=SDLK_HASH; goto done1580;}
        
          if (0 == strcmp(tmp, "k_dollar")) {newVal=SDLK_DOLLAR; goto done1580;}
        
          if (0 == strcmp(tmp, "k_ampersand")) {newVal=SDLK_AMPERSAND; goto done1580;}
        
          if (0 == strcmp(tmp, "k_quote")) {newVal=SDLK_QUOTE; goto done1580;}
        
          if (0 == strcmp(tmp, "k_leftparen")) {newVal=SDLK_LEFTPAREN; goto done1580;}
        
          if (0 == strcmp(tmp, "k_rightparen")) {newVal=SDLK_RIGHTPAREN; goto done1580;}
        
          if (0 == strcmp(tmp, "k_asterisk")) {newVal=SDLK_ASTERISK; goto done1580;}
        
          if (0 == strcmp(tmp, "k_plus")) {newVal=SDLK_PLUS; goto done1580;}
        
          if (0 == strcmp(tmp, "k_comma")) {newVal=SDLK_COMMA; goto done1580;}
        
          if (0 == strcmp(tmp, "k_minus")) {newVal=SDLK_MINUS; goto done1580;}
        
          if (0 == strcmp(tmp, "k_period")) {newVal=SDLK_PERIOD; goto done1580;}
        
          if (0 == strcmp(tmp, "k_slash")) {newVal=SDLK_SLASH; goto done1580;}
        
          if (0 == strcmp(tmp, "k_0")) {newVal=SDLK_0; goto done1580;}
        
          if (0 == strcmp(tmp, "k_1")) {newVal=SDLK_1; goto done1580;}
        
          if (0 == strcmp(tmp, "k_2")) {newVal=SDLK_2; goto done1580;}
        
          if (0 == strcmp(tmp, "k_3")) {newVal=SDLK_3; goto done1580;}
        
          if (0 == strcmp(tmp, "k_4")) {newVal=SDLK_4; goto done1580;}
        
          if (0 == strcmp(tmp, "k_5")) {newVal=SDLK_5; goto done1580;}
        
          if (0 == strcmp(tmp, "k_6")) {newVal=SDLK_6; goto done1580;}
        
          if (0 == strcmp(tmp, "k_7")) {newVal=SDLK_7; goto done1580;}
        
          if (0 == strcmp(tmp, "k_8")) {newVal=SDLK_8; goto done1580;}
        
          if (0 == strcmp(tmp, "k_9")) {newVal=SDLK_9; goto done1580;}
        
          if (0 == strcmp(tmp, "k_colon")) {newVal=SDLK_COLON; goto done1580;}
        
          if (0 == strcmp(tmp, "k_semicolon")) {newVal=SDLK_SEMICOLON; goto done1580;}
        
          if (0 == strcmp(tmp, "k_less")) {newVal=SDLK_LESS; goto done1580;}
        
          if (0 == strcmp(tmp, "k_equals")) {newVal=SDLK_EQUALS; goto done1580;}
        
          if (0 == strcmp(tmp, "k_greater")) {newVal=SDLK_GREATER; goto done1580;}
        
          if (0 == strcmp(tmp, "k_question")) {newVal=SDLK_QUESTION; goto done1580;}
        
          if (0 == strcmp(tmp, "k_at")) {newVal=SDLK_AT; goto done1580;}
        
          if (0 == strcmp(tmp, "k_leftbracket")) {newVal=SDLK_LEFTBRACKET; goto done1580;}
        
          if (0 == strcmp(tmp, "k_backslash")) {newVal=SDLK_BACKSLASH; goto done1580;}
        
          if (0 == strcmp(tmp, "k_rightbracket")) {newVal=SDLK_RIGHTBRACKET; goto done1580;}
        
          if (0 == strcmp(tmp, "k_caret")) {newVal=SDLK_CARET; goto done1580;}
        
          if (0 == strcmp(tmp, "k_underscore")) {newVal=SDLK_UNDERSCORE; goto done1580;}
        
          if (0 == strcmp(tmp, "k_backquote")) {newVal=SDLK_BACKQUOTE; goto done1580;}
        
          if (0 == strcmp(tmp, "k_delete")) {newVal=SDLK_DELETE; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp0")) {newVal=SDLK_KP0; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp1")) {newVal=SDLK_KP1; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp2")) {newVal=SDLK_KP2; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp3")) {newVal=SDLK_KP3; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp4")) {newVal=SDLK_KP4; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp5")) {newVal=SDLK_KP5; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp6")) {newVal=SDLK_KP6; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp7")) {newVal=SDLK_KP7; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp8")) {newVal=SDLK_KP8; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp9")) {newVal=SDLK_KP9; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp_period")) {newVal=SDLK_KP_PERIOD; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp_divide")) {newVal=SDLK_KP_DIVIDE; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp_multiply")) {newVal=SDLK_KP_MULTIPLY; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp_minus")) {newVal=SDLK_KP_MINUS; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp_plus")) {newVal=SDLK_KP_PLUS; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp_enter")) {newVal=SDLK_KP_ENTER; goto done1580;}
        
          if (0 == strcmp(tmp, "k_kp_equals")) {newVal=SDLK_KP_EQUALS; goto done1580;}
        
          if (0 == strcmp(tmp, "k_up")) {newVal=SDLK_UP; goto done1580;}
        
          if (0 == strcmp(tmp, "k_down")) {newVal=SDLK_DOWN; goto done1580;}
        
          if (0 == strcmp(tmp, "k_right")) {newVal=SDLK_RIGHT; goto done1580;}
        
          if (0 == strcmp(tmp, "k_left")) {newVal=SDLK_LEFT; goto done1580;}
        
          if (0 == strcmp(tmp, "k_insert")) {newVal=SDLK_INSERT; goto done1580;}
        
          if (0 == strcmp(tmp, "k_home")) {newVal=SDLK_HOME; goto done1580;}
        
          if (0 == strcmp(tmp, "k_end")) {newVal=SDLK_END; goto done1580;}
        
          if (0 == strcmp(tmp, "k_pageup")) {newVal=SDLK_PAGEUP; goto done1580;}
        
          if (0 == strcmp(tmp, "k_pagedown")) {newVal=SDLK_PAGEDOWN; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f1")) {newVal=SDLK_F1; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f2")) {newVal=SDLK_F2; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f3")) {newVal=SDLK_F3; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f4")) {newVal=SDLK_F4; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f5")) {newVal=SDLK_F5; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f6")) {newVal=SDLK_F6; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f7")) {newVal=SDLK_F7; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f8")) {newVal=SDLK_F8; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f9")) {newVal=SDLK_F9; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f10")) {newVal=SDLK_F10; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f11")) {newVal=SDLK_F11; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f12")) {newVal=SDLK_F12; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f13")) {newVal=SDLK_F13; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f14")) {newVal=SDLK_F14; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f15")) {newVal=SDLK_F15; goto done1580;}
        
          if (0 == strcmp(tmp, "k_numlock")) {newVal=SDLK_NUMLOCK; goto done1580;}
        
          if (0 == strcmp(tmp, "k_capslock")) {newVal=SDLK_CAPSLOCK; goto done1580;}
        
          if (0 == strcmp(tmp, "k_rshift")) {newVal=SDLK_RSHIFT; goto done1580;}
        
          if (0 == strcmp(tmp, "k_lshift")) {newVal=SDLK_LSHIFT; goto done1580;}
        
          if (0 == strcmp(tmp, "k_rctrl")) {newVal=SDLK_RCTRL; goto done1580;}
        
          if (0 == strcmp(tmp, "k_lctrl")) {newVal=SDLK_LCTRL; goto done1580;}
        
          if (0 == strcmp(tmp, "k_ralt")) {newVal=SDLK_RALT; goto done1580;}
        
          if (0 == strcmp(tmp, "k_lalt")) {newVal=SDLK_LALT; goto done1580;}
        
          if (0 == strcmp(tmp, "k_rmeta")) {newVal=SDLK_RMETA; goto done1580;}
        
          if (0 == strcmp(tmp, "k_lmeta")) {newVal=SDLK_LMETA; goto done1580;}
        
          if (0 == strcmp(tmp, "k_lsuper")) {newVal=SDLK_LSUPER; goto done1580;}
        
          if (0 == strcmp(tmp, "k_rsuper")) {newVal=SDLK_RSUPER; goto done1580;}
        
          if (0 == strcmp(tmp, "k_mode")) {newVal=SDLK_MODE; goto done1580;}
        
          if (0 == strcmp(tmp, "k_compose")) {newVal=SDLK_COMPOSE; goto done1580;}
        
          if (0 == strcmp(tmp, "k_help")) {newVal=SDLK_HELP; goto done1580;}
        
          if (0 == strcmp(tmp, "k_print")) {newVal=SDLK_PRINT; goto done1580;}
        
          if (0 == strcmp(tmp, "k_sysreq")) {newVal=SDLK_SYSREQ; goto done1580;}
        
          if (0 == strcmp(tmp, "k_break")) {newVal=SDLK_BREAK; goto done1580;}
        
          if (0 == strcmp(tmp, "k_menu")) {newVal=SDLK_MENU; goto done1580;}
        
          if (0 == strcmp(tmp, "k_power")) {newVal=SDLK_POWER; goto done1580;}
        
          if (0 == strcmp(tmp, "k_euro")) {newVal=SDLK_EURO; goto done1580;}
        
          if (0 == strcmp(tmp, "k_undo")) {newVal=SDLK_UNDO; goto done1580;}
        
          if (0 == strcmp(tmp, "k_a")) {newVal=SDLK_a; goto done1580;}
        
          if (0 == strcmp(tmp, "k_b")) {newVal=SDLK_b; goto done1580;}
        
          if (0 == strcmp(tmp, "k_c")) {newVal=SDLK_c; goto done1580;}
        
          if (0 == strcmp(tmp, "k_d")) {newVal=SDLK_d; goto done1580;}
        
          if (0 == strcmp(tmp, "k_e")) {newVal=SDLK_e; goto done1580;}
        
          if (0 == strcmp(tmp, "k_f")) {newVal=SDLK_f; goto done1580;}
        
          if (0 == strcmp(tmp, "k_g")) {newVal=SDLK_g; goto done1580;}
        
          if (0 == strcmp(tmp, "k_h")) {newVal=SDLK_h; goto done1580;}
        
          if (0 == strcmp(tmp, "k_i")) {newVal=SDLK_i; goto done1580;}
        
          if (0 == strcmp(tmp, "k_j")) {newVal=SDLK_j; goto done1580;}
        
          if (0 == strcmp(tmp, "k_k")) {newVal=SDLK_k; goto done1580;}
        
          if (0 == strcmp(tmp, "k_l")) {newVal=SDLK_l; goto done1580;}
        
          if (0 == strcmp(tmp, "k_m")) {newVal=SDLK_m; goto done1580;}
        
          if (0 == strcmp(tmp, "k_n")) {newVal=SDLK_n; goto done1580;}
        
          if (0 == strcmp(tmp, "k_o")) {newVal=SDLK_o; goto done1580;}
        
          if (0 == strcmp(tmp, "k_p")) {newVal=SDLK_p; goto done1580;}
        
          if (0 == strcmp(tmp, "k_q")) {newVal=SDLK_q; goto done1580;}
        
          if (0 == strcmp(tmp, "k_r")) {newVal=SDLK_r; goto done1580;}
        
          if (0 == strcmp(tmp, "k_s")) {newVal=SDLK_s; goto done1580;}
        
          if (0 == strcmp(tmp, "k_t")) {newVal=SDLK_t; goto done1580;}
        
          if (0 == strcmp(tmp, "k_u")) {newVal=SDLK_u; goto done1580;}
        
          if (0 == strcmp(tmp, "k_v")) {newVal=SDLK_v; goto done1580;}
        
          if (0 == strcmp(tmp, "k_w")) {newVal=SDLK_w; goto done1580;}
        
          if (0 == strcmp(tmp, "k_x")) {newVal=SDLK_x; goto done1580;}
        
          if (0 == strcmp(tmp, "k_y")) {newVal=SDLK_y; goto done1580;}
        
          if (0 == strcmp(tmp, "k_z")) {newVal=SDLK_z; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_0")) {newVal=SDLK_WORLD_0; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_1")) {newVal=SDLK_WORLD_1; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_2")) {newVal=SDLK_WORLD_2; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_3")) {newVal=SDLK_WORLD_3; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_4")) {newVal=SDLK_WORLD_4; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_5")) {newVal=SDLK_WORLD_5; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_6")) {newVal=SDLK_WORLD_6; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_7")) {newVal=SDLK_WORLD_7; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_8")) {newVal=SDLK_WORLD_8; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_9")) {newVal=SDLK_WORLD_9; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_10")) {newVal=SDLK_WORLD_10; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_11")) {newVal=SDLK_WORLD_11; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_12")) {newVal=SDLK_WORLD_12; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_13")) {newVal=SDLK_WORLD_13; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_14")) {newVal=SDLK_WORLD_14; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_15")) {newVal=SDLK_WORLD_15; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_16")) {newVal=SDLK_WORLD_16; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_17")) {newVal=SDLK_WORLD_17; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_18")) {newVal=SDLK_WORLD_18; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_19")) {newVal=SDLK_WORLD_19; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_20")) {newVal=SDLK_WORLD_20; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_21")) {newVal=SDLK_WORLD_21; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_22")) {newVal=SDLK_WORLD_22; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_23")) {newVal=SDLK_WORLD_23; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_24")) {newVal=SDLK_WORLD_24; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_25")) {newVal=SDLK_WORLD_25; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_26")) {newVal=SDLK_WORLD_26; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_27")) {newVal=SDLK_WORLD_27; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_28")) {newVal=SDLK_WORLD_28; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_29")) {newVal=SDLK_WORLD_29; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_30")) {newVal=SDLK_WORLD_30; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_31")) {newVal=SDLK_WORLD_31; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_32")) {newVal=SDLK_WORLD_32; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_33")) {newVal=SDLK_WORLD_33; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_34")) {newVal=SDLK_WORLD_34; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_35")) {newVal=SDLK_WORLD_35; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_36")) {newVal=SDLK_WORLD_36; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_37")) {newVal=SDLK_WORLD_37; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_38")) {newVal=SDLK_WORLD_38; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_39")) {newVal=SDLK_WORLD_39; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_40")) {newVal=SDLK_WORLD_40; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_41")) {newVal=SDLK_WORLD_41; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_42")) {newVal=SDLK_WORLD_42; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_43")) {newVal=SDLK_WORLD_43; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_44")) {newVal=SDLK_WORLD_44; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_45")) {newVal=SDLK_WORLD_45; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_46")) {newVal=SDLK_WORLD_46; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_47")) {newVal=SDLK_WORLD_47; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_48")) {newVal=SDLK_WORLD_48; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_49")) {newVal=SDLK_WORLD_49; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_50")) {newVal=SDLK_WORLD_50; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_51")) {newVal=SDLK_WORLD_51; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_52")) {newVal=SDLK_WORLD_52; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_53")) {newVal=SDLK_WORLD_53; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_54")) {newVal=SDLK_WORLD_54; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_55")) {newVal=SDLK_WORLD_55; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_56")) {newVal=SDLK_WORLD_56; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_57")) {newVal=SDLK_WORLD_57; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_58")) {newVal=SDLK_WORLD_58; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_59")) {newVal=SDLK_WORLD_59; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_60")) {newVal=SDLK_WORLD_60; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_61")) {newVal=SDLK_WORLD_61; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_62")) {newVal=SDLK_WORLD_62; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_63")) {newVal=SDLK_WORLD_63; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_64")) {newVal=SDLK_WORLD_64; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_65")) {newVal=SDLK_WORLD_65; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_66")) {newVal=SDLK_WORLD_66; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_67")) {newVal=SDLK_WORLD_67; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_68")) {newVal=SDLK_WORLD_68; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_69")) {newVal=SDLK_WORLD_69; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_70")) {newVal=SDLK_WORLD_70; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_71")) {newVal=SDLK_WORLD_71; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_72")) {newVal=SDLK_WORLD_72; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_73")) {newVal=SDLK_WORLD_73; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_74")) {newVal=SDLK_WORLD_74; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_75")) {newVal=SDLK_WORLD_75; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_76")) {newVal=SDLK_WORLD_76; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_77")) {newVal=SDLK_WORLD_77; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_78")) {newVal=SDLK_WORLD_78; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_79")) {newVal=SDLK_WORLD_79; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_80")) {newVal=SDLK_WORLD_80; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_81")) {newVal=SDLK_WORLD_81; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_82")) {newVal=SDLK_WORLD_82; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_83")) {newVal=SDLK_WORLD_83; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_84")) {newVal=SDLK_WORLD_84; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_85")) {newVal=SDLK_WORLD_85; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_86")) {newVal=SDLK_WORLD_86; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_87")) {newVal=SDLK_WORLD_87; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_88")) {newVal=SDLK_WORLD_88; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_89")) {newVal=SDLK_WORLD_89; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_90")) {newVal=SDLK_WORLD_90; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_91")) {newVal=SDLK_WORLD_91; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_92")) {newVal=SDLK_WORLD_92; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_93")) {newVal=SDLK_WORLD_93; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_94")) {newVal=SDLK_WORLD_94; goto done1580;}
        
          if (0 == strcmp(tmp, "k_world_95")) {newVal=SDLK_WORLD_95; goto done1580;}
         {
          char* end;
          newVal = (SDLKey)strtol(tmp, &end, 10);
          if (*end) {
            sprintf(staticError, "Unable to convert %s to SDLKey", tmp);
            scriptError(staticError);
          }
          goto done1580;
        } 
done1580:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->sym = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get96 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get96", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->mod);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set97 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set97", TCL_VOLATILE);
        return TCL_ERROR;
      }
      SDLMod newVal;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (SDLMod)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->mod = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get99 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get99", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->unicode);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set100 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set100", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint16 newVal;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->unicode = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ get90", get90, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set91", set91, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get93", get93, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set94", set94, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get96", get96, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set97", set97, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get99", get99, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set100", set100, 0, NULL);
TypeExport* ste=new TypeExport(typeid(SDL_keysym)),
                           * ete=new TypeExport(typeid(TclSDL_keysym));
ste->isAObject=ete->isAObject=false;
ste->tclClassName=ete->tclClassName="SDL_keysym";
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(SDL_keysym));
typeExports[&typeid(SDL_keysym)]=ste;
typeExports[&typeid(TclSDL_keysym)]=ete;
}
};
void classdec89(bool safe, Tcl_Interp* interp) throw() {
  TclSDL_keysym::cppDecCode(safe,interp);
}
class TclSDL_KeyboardEvent : public SDL_KeyboardEvent {
      public:
static int get103 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get103", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->type)
      {

          case SDL_KEYDOWN: tmp="DOWN"; break;
          case SDL_KEYUP: tmp="UP"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration Uint8 value "
               << (int)parent->type << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set104 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set104", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "DOWN")) {newVal=SDL_KEYDOWN; goto done1584;}
        
          if (0 == strcmp(tmp, "UP")) {newVal=SDL_KEYUP; goto done1584;}
         {
          sprintf(staticError, "Unable to convert %s to Uint8", tmp);
          scriptError(staticError);
        } 
done1584:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->type = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get106 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get106", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->state)
      {

          case SDL_PRESSED: tmp="PRESSED"; break;
          case SDL_RELEASED: tmp="RELEASED"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration Uint8 value "
               << (int)parent->state << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set107 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set107", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "PRESSED")) {newVal=SDL_PRESSED; goto done1586;}
        
          if (0 == strcmp(tmp, "RELEASED")) {newVal=SDL_RELEASED; goto done1586;}
         {
          sprintf(staticError, "Unable to convert %s to Uint8", tmp);
          scriptError(staticError);
        } 
done1586:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->state = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get109 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get109", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {if (!(&parent->keysym)) {
      objout=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(&parent->keysym));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(SDL_keysym)];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(&parent->keysym)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      objout=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set110 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set110", TCL_VOLATILE);
        return TCL_ERROR;
      }
      SDL_keysym* newVal;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        newVal = tmp;
    } else {scriptError("Null pointer assigned to immediate");}
}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->keysym = *newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ get103", get103, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set104", set104, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get106", get106, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set107", set107, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get109", get109, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set110", set110, 0, NULL);
TypeExport* ste=new TypeExport(typeid(SDL_KeyboardEvent)),
                           * ete=new TypeExport(typeid(TclSDL_KeyboardEvent));
ste->isAObject=ete->isAObject=false;
ste->tclClassName=ete->tclClassName="SDL_KeyboardEvent";
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(SDL_KeyboardEvent));
typeExports[&typeid(SDL_KeyboardEvent)]=ste;
typeExports[&typeid(TclSDL_KeyboardEvent)]=ete;
}
};
void classdec102(bool safe, Tcl_Interp* interp) throw() {
  TclSDL_KeyboardEvent::cppDecCode(safe,interp);
}
 int get112 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get112", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_BUTTON(1));}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get114 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get114", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_BUTTON(2));}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get116 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get116", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_BUTTON(3));}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get118 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get118", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_BUTTON(4));}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get120 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get120", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_BUTTON(5));}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline122 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
SDLMod ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      ret =
     
     
     SDL_GetModState();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

 int get124 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get124", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_DEFAULT_REPEAT_INTERVAL);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get126 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get126", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_DEFAULT_REPEAT_DELAY);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline128 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
int arg0; bool arg0Init=false;
int arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (int)tmp;};
arg0Init=true;
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (int)tmp;};
arg1Init=true;
try {
      
     
     
     SDL_EnableKeyRepeat(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


class TclSDL_MouseMotionEvent : public SDL_MouseMotionEvent {
      public:
static int get131 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get131", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->type);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set132 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set132", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint8)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->type = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get134 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get134", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->state);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set135 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set135", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint8)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->state = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get137 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get137", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->x);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set138 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set138", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint16 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->x = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get140 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get140", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->y);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set141 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set141", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint16 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->y = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get143 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get143", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->xrel);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set144 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set144", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Sint16 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Sint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->xrel = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get146 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get146", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->yrel);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set147 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set147", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Sint16 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Sint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->yrel = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ get131", get131, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set132", set132, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get134", get134, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set135", set135, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get137", get137, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set138", set138, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get140", get140, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set141", set141, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get143", get143, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set144", set144, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get146", get146, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set147", set147, 0, NULL);
TypeExport* ste=new TypeExport(typeid(SDL_MouseMotionEvent)),
                           * ete=new TypeExport(typeid(TclSDL_MouseMotionEvent));
ste->isAObject=ete->isAObject=false;
ste->tclClassName=ete->tclClassName="SDL_MouseMotionEvent";
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(SDL_MouseMotionEvent));
typeExports[&typeid(SDL_MouseMotionEvent)]=ste;
typeExports[&typeid(TclSDL_MouseMotionEvent)]=ete;
}
};
void classdec130(bool safe, Tcl_Interp* interp) throw() {
  TclSDL_MouseMotionEvent::cppDecCode(safe,interp);
}
class TclSDL_MouseButtonEvent : public SDL_MouseButtonEvent {
      public:
static int get150 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get150", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->type)
      {

          case SDL_MOUSEBUTTONDOWN: tmp="DOWN"; break;
          case SDL_MOUSEBUTTONUP: tmp="UP"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration Uint8 value "
               << (int)parent->type << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set151 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set151", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "DOWN")) {newVal=SDL_MOUSEBUTTONDOWN; goto done1596;}
        
          if (0 == strcmp(tmp, "UP")) {newVal=SDL_MOUSEBUTTONUP; goto done1596;}
         {
          sprintf(staticError, "Unable to convert %s to Uint8", tmp);
          scriptError(staticError);
        } 
done1596:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->type = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get153 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get153", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->which);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set154 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set154", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint8)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->which = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get156 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get156", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->button)
      {

          case SDL_BUTTON_LEFT: tmp="mb_left"; break;
          case SDL_BUTTON_MIDDLE: tmp="mb_mid"; break;
          case SDL_BUTTON_RIGHT: tmp="mb_right"; break;
          case SDL_BUTTON_WHEELUP: tmp="mb_wup"; break;
          case SDL_BUTTON_WHEELDOWN: tmp="mb_wdown"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration Uint8 value "
               << (int)parent->button << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set157 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set157", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "mb_left")) {newVal=SDL_BUTTON_LEFT; goto done1599;}
        
          if (0 == strcmp(tmp, "mb_mid")) {newVal=SDL_BUTTON_MIDDLE; goto done1599;}
        
          if (0 == strcmp(tmp, "mb_right")) {newVal=SDL_BUTTON_RIGHT; goto done1599;}
        
          if (0 == strcmp(tmp, "mb_wup")) {newVal=SDL_BUTTON_WHEELUP; goto done1599;}
        
          if (0 == strcmp(tmp, "mb_wdown")) {newVal=SDL_BUTTON_WHEELDOWN; goto done1599;}
         {
          sprintf(staticError, "Unable to convert %s to Uint8", tmp);
          scriptError(staticError);
        } 
done1599:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->button = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get159 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get159", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->state)
      {

          case SDL_PRESSED: tmp="PRESSED"; break;
          case SDL_RELEASED: tmp="RELEASED"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration Uint8 value "
               << (int)parent->state << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set160 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set160", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "PRESSED")) {newVal=SDL_PRESSED; goto done1601;}
        
          if (0 == strcmp(tmp, "RELEASED")) {newVal=SDL_RELEASED; goto done1601;}
         {
          sprintf(staticError, "Unable to convert %s to Uint8", tmp);
          scriptError(staticError);
        } 
done1601:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->state = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get162 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get162", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->x);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set163 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set163", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint16 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->x = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get165 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get165", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->y);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set166 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set166", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint16 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->y = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ get150", get150, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set151", set151, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get153", get153, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set154", set154, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get156", get156, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set157", set157, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get159", get159, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set160", set160, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get162", get162, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set163", set163, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get165", get165, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set166", set166, 0, NULL);
TypeExport* ste=new TypeExport(typeid(SDL_MouseButtonEvent)),
                           * ete=new TypeExport(typeid(TclSDL_MouseButtonEvent));
ste->isAObject=ete->isAObject=false;
ste->tclClassName=ete->tclClassName="SDL_MouseButtonEvent";
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(SDL_MouseButtonEvent));
typeExports[&typeid(SDL_MouseButtonEvent)]=ste;
typeExports[&typeid(TclSDL_MouseButtonEvent)]=ete;
}
};
void classdec149(bool safe, Tcl_Interp* interp) throw() {
  TclSDL_MouseButtonEvent::cppDecCode(safe,interp);
}

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline168 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
SDLKey arg0; bool arg0Init=false;
const char* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
        const char* tmp = Tcl_GetStringFromObj(objv[0], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "k_unknown")) {arg0=SDLK_UNKNOWN; goto done1604;}
        
          if (0 == strcmp(tmp, "k_enter")) {arg0=SDLK_RETURN; goto done1604;}
        
          if (0 == strcmp(tmp, "k_scrolllock")) {arg0=SDLK_SCROLLOCK; goto done1604;}
        
          if (0 == strcmp(tmp, "k_backspace")) {arg0=SDLK_BACKSPACE; goto done1604;}
        
          if (0 == strcmp(tmp, "k_tab")) {arg0=SDLK_TAB; goto done1604;}
        
          if (0 == strcmp(tmp, "k_clear")) {arg0=SDLK_CLEAR; goto done1604;}
        
          if (0 == strcmp(tmp, "k_pause")) {arg0=SDLK_PAUSE; goto done1604;}
        
          if (0 == strcmp(tmp, "k_escape")) {arg0=SDLK_ESCAPE; goto done1604;}
        
          if (0 == strcmp(tmp, "k_space")) {arg0=SDLK_SPACE; goto done1604;}
        
          if (0 == strcmp(tmp, "k_exclaim")) {arg0=SDLK_EXCLAIM; goto done1604;}
        
          if (0 == strcmp(tmp, "k_quotedbl")) {arg0=SDLK_QUOTEDBL; goto done1604;}
        
          if (0 == strcmp(tmp, "k_hash")) {arg0=SDLK_HASH; goto done1604;}
        
          if (0 == strcmp(tmp, "k_dollar")) {arg0=SDLK_DOLLAR; goto done1604;}
        
          if (0 == strcmp(tmp, "k_ampersand")) {arg0=SDLK_AMPERSAND; goto done1604;}
        
          if (0 == strcmp(tmp, "k_quote")) {arg0=SDLK_QUOTE; goto done1604;}
        
          if (0 == strcmp(tmp, "k_leftparen")) {arg0=SDLK_LEFTPAREN; goto done1604;}
        
          if (0 == strcmp(tmp, "k_rightparen")) {arg0=SDLK_RIGHTPAREN; goto done1604;}
        
          if (0 == strcmp(tmp, "k_asterisk")) {arg0=SDLK_ASTERISK; goto done1604;}
        
          if (0 == strcmp(tmp, "k_plus")) {arg0=SDLK_PLUS; goto done1604;}
        
          if (0 == strcmp(tmp, "k_comma")) {arg0=SDLK_COMMA; goto done1604;}
        
          if (0 == strcmp(tmp, "k_minus")) {arg0=SDLK_MINUS; goto done1604;}
        
          if (0 == strcmp(tmp, "k_period")) {arg0=SDLK_PERIOD; goto done1604;}
        
          if (0 == strcmp(tmp, "k_slash")) {arg0=SDLK_SLASH; goto done1604;}
        
          if (0 == strcmp(tmp, "k_0")) {arg0=SDLK_0; goto done1604;}
        
          if (0 == strcmp(tmp, "k_1")) {arg0=SDLK_1; goto done1604;}
        
          if (0 == strcmp(tmp, "k_2")) {arg0=SDLK_2; goto done1604;}
        
          if (0 == strcmp(tmp, "k_3")) {arg0=SDLK_3; goto done1604;}
        
          if (0 == strcmp(tmp, "k_4")) {arg0=SDLK_4; goto done1604;}
        
          if (0 == strcmp(tmp, "k_5")) {arg0=SDLK_5; goto done1604;}
        
          if (0 == strcmp(tmp, "k_6")) {arg0=SDLK_6; goto done1604;}
        
          if (0 == strcmp(tmp, "k_7")) {arg0=SDLK_7; goto done1604;}
        
          if (0 == strcmp(tmp, "k_8")) {arg0=SDLK_8; goto done1604;}
        
          if (0 == strcmp(tmp, "k_9")) {arg0=SDLK_9; goto done1604;}
        
          if (0 == strcmp(tmp, "k_colon")) {arg0=SDLK_COLON; goto done1604;}
        
          if (0 == strcmp(tmp, "k_semicolon")) {arg0=SDLK_SEMICOLON; goto done1604;}
        
          if (0 == strcmp(tmp, "k_less")) {arg0=SDLK_LESS; goto done1604;}
        
          if (0 == strcmp(tmp, "k_equals")) {arg0=SDLK_EQUALS; goto done1604;}
        
          if (0 == strcmp(tmp, "k_greater")) {arg0=SDLK_GREATER; goto done1604;}
        
          if (0 == strcmp(tmp, "k_question")) {arg0=SDLK_QUESTION; goto done1604;}
        
          if (0 == strcmp(tmp, "k_at")) {arg0=SDLK_AT; goto done1604;}
        
          if (0 == strcmp(tmp, "k_leftbracket")) {arg0=SDLK_LEFTBRACKET; goto done1604;}
        
          if (0 == strcmp(tmp, "k_backslash")) {arg0=SDLK_BACKSLASH; goto done1604;}
        
          if (0 == strcmp(tmp, "k_rightbracket")) {arg0=SDLK_RIGHTBRACKET; goto done1604;}
        
          if (0 == strcmp(tmp, "k_caret")) {arg0=SDLK_CARET; goto done1604;}
        
          if (0 == strcmp(tmp, "k_underscore")) {arg0=SDLK_UNDERSCORE; goto done1604;}
        
          if (0 == strcmp(tmp, "k_backquote")) {arg0=SDLK_BACKQUOTE; goto done1604;}
        
          if (0 == strcmp(tmp, "k_delete")) {arg0=SDLK_DELETE; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp0")) {arg0=SDLK_KP0; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp1")) {arg0=SDLK_KP1; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp2")) {arg0=SDLK_KP2; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp3")) {arg0=SDLK_KP3; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp4")) {arg0=SDLK_KP4; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp5")) {arg0=SDLK_KP5; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp6")) {arg0=SDLK_KP6; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp7")) {arg0=SDLK_KP7; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp8")) {arg0=SDLK_KP8; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp9")) {arg0=SDLK_KP9; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp_period")) {arg0=SDLK_KP_PERIOD; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp_divide")) {arg0=SDLK_KP_DIVIDE; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp_multiply")) {arg0=SDLK_KP_MULTIPLY; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp_minus")) {arg0=SDLK_KP_MINUS; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp_plus")) {arg0=SDLK_KP_PLUS; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp_enter")) {arg0=SDLK_KP_ENTER; goto done1604;}
        
          if (0 == strcmp(tmp, "k_kp_equals")) {arg0=SDLK_KP_EQUALS; goto done1604;}
        
          if (0 == strcmp(tmp, "k_up")) {arg0=SDLK_UP; goto done1604;}
        
          if (0 == strcmp(tmp, "k_down")) {arg0=SDLK_DOWN; goto done1604;}
        
          if (0 == strcmp(tmp, "k_right")) {arg0=SDLK_RIGHT; goto done1604;}
        
          if (0 == strcmp(tmp, "k_left")) {arg0=SDLK_LEFT; goto done1604;}
        
          if (0 == strcmp(tmp, "k_insert")) {arg0=SDLK_INSERT; goto done1604;}
        
          if (0 == strcmp(tmp, "k_home")) {arg0=SDLK_HOME; goto done1604;}
        
          if (0 == strcmp(tmp, "k_end")) {arg0=SDLK_END; goto done1604;}
        
          if (0 == strcmp(tmp, "k_pageup")) {arg0=SDLK_PAGEUP; goto done1604;}
        
          if (0 == strcmp(tmp, "k_pagedown")) {arg0=SDLK_PAGEDOWN; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f1")) {arg0=SDLK_F1; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f2")) {arg0=SDLK_F2; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f3")) {arg0=SDLK_F3; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f4")) {arg0=SDLK_F4; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f5")) {arg0=SDLK_F5; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f6")) {arg0=SDLK_F6; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f7")) {arg0=SDLK_F7; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f8")) {arg0=SDLK_F8; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f9")) {arg0=SDLK_F9; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f10")) {arg0=SDLK_F10; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f11")) {arg0=SDLK_F11; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f12")) {arg0=SDLK_F12; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f13")) {arg0=SDLK_F13; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f14")) {arg0=SDLK_F14; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f15")) {arg0=SDLK_F15; goto done1604;}
        
          if (0 == strcmp(tmp, "k_numlock")) {arg0=SDLK_NUMLOCK; goto done1604;}
        
          if (0 == strcmp(tmp, "k_capslock")) {arg0=SDLK_CAPSLOCK; goto done1604;}
        
          if (0 == strcmp(tmp, "k_rshift")) {arg0=SDLK_RSHIFT; goto done1604;}
        
          if (0 == strcmp(tmp, "k_lshift")) {arg0=SDLK_LSHIFT; goto done1604;}
        
          if (0 == strcmp(tmp, "k_rctrl")) {arg0=SDLK_RCTRL; goto done1604;}
        
          if (0 == strcmp(tmp, "k_lctrl")) {arg0=SDLK_LCTRL; goto done1604;}
        
          if (0 == strcmp(tmp, "k_ralt")) {arg0=SDLK_RALT; goto done1604;}
        
          if (0 == strcmp(tmp, "k_lalt")) {arg0=SDLK_LALT; goto done1604;}
        
          if (0 == strcmp(tmp, "k_rmeta")) {arg0=SDLK_RMETA; goto done1604;}
        
          if (0 == strcmp(tmp, "k_lmeta")) {arg0=SDLK_LMETA; goto done1604;}
        
          if (0 == strcmp(tmp, "k_lsuper")) {arg0=SDLK_LSUPER; goto done1604;}
        
          if (0 == strcmp(tmp, "k_rsuper")) {arg0=SDLK_RSUPER; goto done1604;}
        
          if (0 == strcmp(tmp, "k_mode")) {arg0=SDLK_MODE; goto done1604;}
        
          if (0 == strcmp(tmp, "k_compose")) {arg0=SDLK_COMPOSE; goto done1604;}
        
          if (0 == strcmp(tmp, "k_help")) {arg0=SDLK_HELP; goto done1604;}
        
          if (0 == strcmp(tmp, "k_print")) {arg0=SDLK_PRINT; goto done1604;}
        
          if (0 == strcmp(tmp, "k_sysreq")) {arg0=SDLK_SYSREQ; goto done1604;}
        
          if (0 == strcmp(tmp, "k_break")) {arg0=SDLK_BREAK; goto done1604;}
        
          if (0 == strcmp(tmp, "k_menu")) {arg0=SDLK_MENU; goto done1604;}
        
          if (0 == strcmp(tmp, "k_power")) {arg0=SDLK_POWER; goto done1604;}
        
          if (0 == strcmp(tmp, "k_euro")) {arg0=SDLK_EURO; goto done1604;}
        
          if (0 == strcmp(tmp, "k_undo")) {arg0=SDLK_UNDO; goto done1604;}
        
          if (0 == strcmp(tmp, "k_a")) {arg0=SDLK_a; goto done1604;}
        
          if (0 == strcmp(tmp, "k_b")) {arg0=SDLK_b; goto done1604;}
        
          if (0 == strcmp(tmp, "k_c")) {arg0=SDLK_c; goto done1604;}
        
          if (0 == strcmp(tmp, "k_d")) {arg0=SDLK_d; goto done1604;}
        
          if (0 == strcmp(tmp, "k_e")) {arg0=SDLK_e; goto done1604;}
        
          if (0 == strcmp(tmp, "k_f")) {arg0=SDLK_f; goto done1604;}
        
          if (0 == strcmp(tmp, "k_g")) {arg0=SDLK_g; goto done1604;}
        
          if (0 == strcmp(tmp, "k_h")) {arg0=SDLK_h; goto done1604;}
        
          if (0 == strcmp(tmp, "k_i")) {arg0=SDLK_i; goto done1604;}
        
          if (0 == strcmp(tmp, "k_j")) {arg0=SDLK_j; goto done1604;}
        
          if (0 == strcmp(tmp, "k_k")) {arg0=SDLK_k; goto done1604;}
        
          if (0 == strcmp(tmp, "k_l")) {arg0=SDLK_l; goto done1604;}
        
          if (0 == strcmp(tmp, "k_m")) {arg0=SDLK_m; goto done1604;}
        
          if (0 == strcmp(tmp, "k_n")) {arg0=SDLK_n; goto done1604;}
        
          if (0 == strcmp(tmp, "k_o")) {arg0=SDLK_o; goto done1604;}
        
          if (0 == strcmp(tmp, "k_p")) {arg0=SDLK_p; goto done1604;}
        
          if (0 == strcmp(tmp, "k_q")) {arg0=SDLK_q; goto done1604;}
        
          if (0 == strcmp(tmp, "k_r")) {arg0=SDLK_r; goto done1604;}
        
          if (0 == strcmp(tmp, "k_s")) {arg0=SDLK_s; goto done1604;}
        
          if (0 == strcmp(tmp, "k_t")) {arg0=SDLK_t; goto done1604;}
        
          if (0 == strcmp(tmp, "k_u")) {arg0=SDLK_u; goto done1604;}
        
          if (0 == strcmp(tmp, "k_v")) {arg0=SDLK_v; goto done1604;}
        
          if (0 == strcmp(tmp, "k_w")) {arg0=SDLK_w; goto done1604;}
        
          if (0 == strcmp(tmp, "k_x")) {arg0=SDLK_x; goto done1604;}
        
          if (0 == strcmp(tmp, "k_y")) {arg0=SDLK_y; goto done1604;}
        
          if (0 == strcmp(tmp, "k_z")) {arg0=SDLK_z; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_0")) {arg0=SDLK_WORLD_0; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_1")) {arg0=SDLK_WORLD_1; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_2")) {arg0=SDLK_WORLD_2; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_3")) {arg0=SDLK_WORLD_3; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_4")) {arg0=SDLK_WORLD_4; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_5")) {arg0=SDLK_WORLD_5; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_6")) {arg0=SDLK_WORLD_6; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_7")) {arg0=SDLK_WORLD_7; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_8")) {arg0=SDLK_WORLD_8; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_9")) {arg0=SDLK_WORLD_9; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_10")) {arg0=SDLK_WORLD_10; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_11")) {arg0=SDLK_WORLD_11; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_12")) {arg0=SDLK_WORLD_12; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_13")) {arg0=SDLK_WORLD_13; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_14")) {arg0=SDLK_WORLD_14; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_15")) {arg0=SDLK_WORLD_15; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_16")) {arg0=SDLK_WORLD_16; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_17")) {arg0=SDLK_WORLD_17; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_18")) {arg0=SDLK_WORLD_18; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_19")) {arg0=SDLK_WORLD_19; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_20")) {arg0=SDLK_WORLD_20; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_21")) {arg0=SDLK_WORLD_21; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_22")) {arg0=SDLK_WORLD_22; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_23")) {arg0=SDLK_WORLD_23; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_24")) {arg0=SDLK_WORLD_24; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_25")) {arg0=SDLK_WORLD_25; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_26")) {arg0=SDLK_WORLD_26; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_27")) {arg0=SDLK_WORLD_27; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_28")) {arg0=SDLK_WORLD_28; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_29")) {arg0=SDLK_WORLD_29; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_30")) {arg0=SDLK_WORLD_30; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_31")) {arg0=SDLK_WORLD_31; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_32")) {arg0=SDLK_WORLD_32; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_33")) {arg0=SDLK_WORLD_33; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_34")) {arg0=SDLK_WORLD_34; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_35")) {arg0=SDLK_WORLD_35; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_36")) {arg0=SDLK_WORLD_36; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_37")) {arg0=SDLK_WORLD_37; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_38")) {arg0=SDLK_WORLD_38; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_39")) {arg0=SDLK_WORLD_39; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_40")) {arg0=SDLK_WORLD_40; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_41")) {arg0=SDLK_WORLD_41; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_42")) {arg0=SDLK_WORLD_42; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_43")) {arg0=SDLK_WORLD_43; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_44")) {arg0=SDLK_WORLD_44; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_45")) {arg0=SDLK_WORLD_45; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_46")) {arg0=SDLK_WORLD_46; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_47")) {arg0=SDLK_WORLD_47; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_48")) {arg0=SDLK_WORLD_48; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_49")) {arg0=SDLK_WORLD_49; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_50")) {arg0=SDLK_WORLD_50; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_51")) {arg0=SDLK_WORLD_51; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_52")) {arg0=SDLK_WORLD_52; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_53")) {arg0=SDLK_WORLD_53; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_54")) {arg0=SDLK_WORLD_54; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_55")) {arg0=SDLK_WORLD_55; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_56")) {arg0=SDLK_WORLD_56; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_57")) {arg0=SDLK_WORLD_57; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_58")) {arg0=SDLK_WORLD_58; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_59")) {arg0=SDLK_WORLD_59; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_60")) {arg0=SDLK_WORLD_60; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_61")) {arg0=SDLK_WORLD_61; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_62")) {arg0=SDLK_WORLD_62; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_63")) {arg0=SDLK_WORLD_63; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_64")) {arg0=SDLK_WORLD_64; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_65")) {arg0=SDLK_WORLD_65; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_66")) {arg0=SDLK_WORLD_66; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_67")) {arg0=SDLK_WORLD_67; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_68")) {arg0=SDLK_WORLD_68; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_69")) {arg0=SDLK_WORLD_69; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_70")) {arg0=SDLK_WORLD_70; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_71")) {arg0=SDLK_WORLD_71; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_72")) {arg0=SDLK_WORLD_72; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_73")) {arg0=SDLK_WORLD_73; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_74")) {arg0=SDLK_WORLD_74; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_75")) {arg0=SDLK_WORLD_75; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_76")) {arg0=SDLK_WORLD_76; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_77")) {arg0=SDLK_WORLD_77; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_78")) {arg0=SDLK_WORLD_78; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_79")) {arg0=SDLK_WORLD_79; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_80")) {arg0=SDLK_WORLD_80; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_81")) {arg0=SDLK_WORLD_81; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_82")) {arg0=SDLK_WORLD_82; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_83")) {arg0=SDLK_WORLD_83; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_84")) {arg0=SDLK_WORLD_84; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_85")) {arg0=SDLK_WORLD_85; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_86")) {arg0=SDLK_WORLD_86; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_87")) {arg0=SDLK_WORLD_87; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_88")) {arg0=SDLK_WORLD_88; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_89")) {arg0=SDLK_WORLD_89; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_90")) {arg0=SDLK_WORLD_90; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_91")) {arg0=SDLK_WORLD_91; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_92")) {arg0=SDLK_WORLD_92; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_93")) {arg0=SDLK_WORLD_93; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_94")) {arg0=SDLK_WORLD_94; goto done1604;}
        
          if (0 == strcmp(tmp, "k_world_95")) {arg0=SDLK_WORLD_95; goto done1604;}
         {
          char* end;
          arg0 = (SDLKey)strtol(tmp, &end, 10);
          if (*end) {
            sprintf(staticError, "Unable to convert %s to SDLKey", tmp);
            scriptError(staticError);
          }
          goto done1604;
        } 
done1604:;};
arg0Init=true;
try {
      ret =
     
     
     SDL_GetKeyName(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(ret? ret : "", -1, &dstr);
        retTcl = Tcl_NewUnicodeObj(tuc, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline170 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
Uint16 arg0; bool arg0Init=false;
Uint16 arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (Uint16)tmp;};
arg0Init=true;
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (Uint16)tmp;};
arg1Init=true;
try {
      
     
     
     SDL_WarpMouse(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline172 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
Uint32 ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      ret =
     
     
     SDL_GetTicks();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError








class TclDynFun2_leftangle_void_comma_Ship_asterix_u_comma_bool_rightangle_ : public DynFun2<void,Ship*,bool> {
      public:
TclDynFun2_leftangle_void_comma_Ship_asterix_u_comma_bool_rightangle_() : DynFun2<void,Ship*,bool>() {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static DynFun2<void,Ship*,bool>* constructorTcldefault
    (const string& name, const string& magicCookie ) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      TclDynFun2_leftangle_void_comma_Ship_asterix_u_comma_bool_rightangle_* ret;
      ret=new TclDynFun2_leftangle_void_comma_Ship_asterix_u_comma_bool_rightangle_();
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(TclDynFun2_leftangle_void_comma_Ship_asterix_u_comma_bool_rightangle_)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline460 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
DynFun2<void,Ship*,bool>* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      ret =
     
     
     constructorTcldefault(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       invoke (Ship* arg0 ,bool arg1 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "invoke";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
Tcl_Obj* arg0Tcl = NULL;
Tcl_Obj* arg1Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {if (!(arg0)) {
      arg0Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg0));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg0)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg0))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg0)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg0Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg0Tcl);
        {arg1Tcl = Tcl_NewBooleanObj(arg1);}
          Tcl_IncrRefCount(arg1Tcl);
         {
        Tcl_Obj* objv[4] = {
          thisTcl,
          meth,
          arg0Tcl, arg1Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;
Tcl_DecrRefCount(arg1Tcl);
arg1Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
if (arg1Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg1Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline462 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynFun2<void,Ship*,bool>* parent=NULL;
Ship* arg0; bool arg0Init=false;
bool arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynFun2<void,Ship*,bool>)
        &&  0==ex->type->superclasses.count(&typeid(DynFun2<void,Ship*,bool>))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynFun2<void,Ship*,bool>, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynFun2<void,Ship*,bool>* tmp=(DynFun2<void,Ship*,bool>*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{int gen1772;
            int err = Tcl_GetBooleanFromObj(interp, objv[2], (int*)&gen1772);
            arg1=gen1772;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg1Init=true;
try {
      
     parent->
     
     invoke(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline464 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
DynFun2<void,Ship*,bool>::fun_t* arg0; bool arg0Init=false;
Ship* arg1; bool arg1Init=false;
bool arg2; bool arg2Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynFun2<void,Ship*,bool>::fun_t)
        &&  0==ex->type->superclasses.count(&typeid(DynFun2<void,Ship*,bool>::fun_t))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynFun2<void,Ship*,bool>::fun_t, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynFun2<void,Ship*,bool>::fun_t* tmp=(DynFun2<void,Ship*,bool>::fun_t*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        arg1 = tmp;
    } else arg1=NULL;
};
arg1Init=true;
{int gen1775;
            int err = Tcl_GetBooleanFromObj(interp, objv[2], (int*)&gen1775);
            arg2=gen1775;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg2Init=true;
try {
      
     
     
     call(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline466 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynFun2<void,Ship*,bool>* parent=NULL;
DynFun2<void,Ship*,bool>::fun_t* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynFun2<void,Ship*,bool>)
        &&  0==ex->type->superclasses.count(&typeid(DynFun2<void,Ship*,bool>))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynFun2<void,Ship*,bool>, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynFun2<void,Ship*,bool>* tmp=(DynFun2<void,Ship*,bool>*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     get();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(DynFun2<void,Ship*,bool>::fun_t)];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline460", trampoline460, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline462", trampoline462, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline464", trampoline464, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline466", trampoline466, 0, NULL);
TypeExport* ste=new TypeExport(typeid(DynFun2<void,Ship*,bool>)),
                           * ete=new TypeExport(typeid(TclDynFun2_leftangle_void_comma_Ship_asterix_u_comma_bool_rightangle_));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="fun<void:Ship*,bool>";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(DynFun2<void,Ship*,bool>));
typeExports[&typeid(DynFun2<void,Ship*,bool>)]=ste;
typeExports[&typeid(TclDynFun2_leftangle_void_comma_Ship_asterix_u_comma_bool_rightangle_)]=ete;
}
};
void classdec459(bool safe, Tcl_Interp* interp) throw() {
  TclDynFun2_leftangle_void_comma_Ship_asterix_u_comma_bool_rightangle_::cppDecCode(safe,interp);
}
class Tclradar_t : public radar_t {
      public:
Tclradar_t() : radar_t() {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static radar_t* constructordefault
    (const string& name, const string& magicCookie ) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      radar_t* ret;
      ret=new radar_t();
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(radar_t)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline469 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
radar_t* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      ret =
     
     
     constructordefault(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline469", trampoline469, 0, NULL);
TypeExport* ste=new TypeExport(typeid(radar_t)),
                           * ete=new TypeExport(typeid(Tclradar_t));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="radar_t";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(radar_t));
typeExports[&typeid(radar_t)]=ste;
typeExports[&typeid(Tclradar_t)]=ete;
}
};
void classdec468(bool safe, Tcl_Interp* interp) throw() {
  Tclradar_t::cppDecCode(safe,interp);
}
class TclCamera : public Camera {
      public:
TclCamera(GameObject* arg2) : Camera(arg2) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Camera* constructorTcldefault
    (const string& name, const string& magicCookie,  GameObject* arg2) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      TclCamera* ret;
      ret=new TclCamera(arg2);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(TclCamera)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline740 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameObject* arg2; bool arg2Init=false;
Camera* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameObject)
        &&  0==ex->type->superclasses.count(&typeid(GameObject))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameObject, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameObject* tmp=(GameObject*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
try {
      ret =
     
     
     constructorTcldefault(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static int get742 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get742", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Camera* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Camera)
        &&  0==ex->type->superclasses.count(&typeid(Camera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Camera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Camera* tmp=(Camera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {if (!(parent->reference)) {
      objout=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(parent->reference));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (parent->reference)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(parent->reference))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(parent->reference)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      objout=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set743 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set743", TCL_VOLATILE);
        return TCL_ERROR;
      }
      GameObject* newVal;
      Camera* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Camera)
        &&  0==ex->type->superclasses.count(&typeid(Camera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Camera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Camera* tmp=(Camera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameObject)
        &&  0==ex->type->superclasses.count(&typeid(GameObject))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameObject, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameObject* tmp=(GameObject*)ex->ptr;
        
        newVal = tmp;
    } else newVal=NULL;
}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->reference = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       doSetup ()  noth { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "doSetup";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
       {
        Tcl_Obj* objv[2] = {
          thisTcl,
          meth,
          };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      
      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      }
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline745 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Camera* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Camera)
        &&  0==ex->type->superclasses.count(&typeid(Camera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Camera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Camera* tmp=(Camera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     doSetup();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       update (float arg0 )  noth { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "update";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
Tcl_Obj* arg0Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {arg0Tcl = Tcl_NewDoubleObj((double)arg0);}
          Tcl_IncrRefCount(arg0Tcl);
         {
        Tcl_Obj* objv[3] = {
          thisTcl,
          meth,
          arg0Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline747 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Camera* parent=NULL;
float arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Camera)
        &&  0==ex->type->superclasses.count(&typeid(Camera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Camera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Camera* tmp=(Camera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      
     parent->
     
     update(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     deftramp748 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Camera* parent=NULL;
float arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Camera)
        &&  0==ex->type->superclasses.count(&typeid(Camera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Camera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Camera* tmp=(Camera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      if (parent->tclExtended) 
     parent->
     Camera::
     update(arg0);
 else 
     parent->
     
     update(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       drawOverlays ()  noth { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "drawOverlays";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
       {
        Tcl_Obj* objv[2] = {
          thisTcl,
          meth,
          };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      
      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      }
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline749 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Camera* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Camera)
        &&  0==ex->type->superclasses.count(&typeid(Camera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Camera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Camera* tmp=(Camera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     drawOverlays();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     deftramp750 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Camera* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Camera)
        &&  0==ex->type->superclasses.count(&typeid(Camera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Camera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Camera* tmp=(Camera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      if (parent->tclExtended) 
     parent->
     Camera::
     drawOverlays();
 else 
     parent->
     
     drawOverlays();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       reset ()  noth { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "reset";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
       {
        Tcl_Obj* objv[2] = {
          thisTcl,
          meth,
          };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      
      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      }
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline751 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Camera* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Camera)
        &&  0==ex->type->superclasses.count(&typeid(Camera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Camera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Camera* tmp=(Camera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     reset();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     deftramp752 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Camera* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Camera)
        &&  0==ex->type->superclasses.count(&typeid(Camera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Camera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Camera* tmp=(Camera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      if (parent->tclExtended) 
     parent->
     Camera::
     reset();
 else 
     parent->
     
     reset();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline753 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Camera* parent=NULL;
bool arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Camera)
        &&  0==ex->type->superclasses.count(&typeid(Camera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Camera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Camera* tmp=(Camera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int gen1942;
            int err = Tcl_GetBooleanFromObj(interp, objv[1], (int*)&gen1942);
            arg0=gen1942;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg0Init=true;
try {
      
     parent->
     
     setup(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline740", trampoline740, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get742", get742, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set743", set743, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline745", trampoline745, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline747", trampoline747, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ deftramp748", deftramp748, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline749", trampoline749, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ deftramp750", deftramp750, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline751", trampoline751, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ deftramp752", deftramp752, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline753", trampoline753, 0, NULL);
TypeExport* ste=new TypeExport(typeid(Camera)),
                           * ete=new TypeExport(typeid(TclCamera));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="Camera";
ste->superclasses.insert(&typeid(EffectsHandler));
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(Camera));
typeExports[&typeid(Camera)]=ste;
typeExports[&typeid(TclCamera)]=ete;
}
};
void classdec739(bool safe, Tcl_Interp* interp) throw() {
  TclCamera::cppDecCode(safe,interp);
}

 int get1077 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1077", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {if (!(state)) {
      objout=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(state));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (state)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(state))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(state)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      objout=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1078 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1078", TCL_VOLATILE);
        return TCL_ERROR;
      }
      GameState* newVal;
      

      //Extract value
      {
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameState)
        &&  0==ex->type->superclasses.count(&typeid(GameState))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameState, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameState* tmp=(GameState*)ex->ptr;
        if (tmp) switch (tmp->ownStat) {
          case AObject::Cpp: 
          case AObject::Tcl:
            tmp->ownStatBak=tmp->ownStat;
            tmp->ownStat=AObject::Cpp;
            //So undo works properly
            tmp->ownerBak.interpreter=tmp->owner.interpreter;
            break;
          case AObject::Container:
            scriptError("Change of ownership of automatic C++ value");
            break;
        }
        newVal = tmp;
    } else newVal=NULL;
}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {if ((state)) switch ((state)->ownStat) {
            case AObject::Tcl:
              if (interp == (state)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (state)->ownStatBak=(state)->ownStat;
              (state)->ownerBak.interpreter = (state)->owner.interpreter;
              (state)->ownStat=AObject::Tcl;
              (state)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }}

      //Set
      state = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }


 int get1080 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1080", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(PLATFORM? PLATFORM : "", -1, &dstr);
        objout = Tcl_NewUnicodeObj(tuc, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1082 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1082", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)screenW);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1084 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1084", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)screenH);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1086 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1086", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)vheight);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1088 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1088", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewBooleanObj(generalAlphaBlending);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1089 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1089", TCL_VOLATILE);
        return TCL_ERROR;
      }
      bool newVal;
      

      //Extract value
      {int gen2083;
            int err = Tcl_GetBooleanFromObj(interp, objv[0], (int*)&gen2083);
            newVal=gen2083;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      generalAlphaBlending = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1091 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1091", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewBooleanObj(alphaBlendingEnabled);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1092 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1092", TCL_VOLATILE);
        return TCL_ERROR;
      }
      bool newVal;
      

      //Extract value
      {int gen2084;
            int err = Tcl_GetBooleanFromObj(interp, objv[0], (int*)&gen2084);
            newVal=gen2084;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      alphaBlendingEnabled = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1094 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1094", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewBooleanObj(smoothScaling);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1095 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1095", TCL_VOLATILE);
        return TCL_ERROR;
      }
      bool newVal;
      

      //Extract value
      {int gen2085;
            int err = Tcl_GetBooleanFromObj(interp, objv[0], (int*)&gen2085);
            newVal=gen2085;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      smoothScaling = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1097 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1097", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewBooleanObj(highQuality);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1098 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1098", TCL_VOLATILE);
        return TCL_ERROR;
      }
      bool newVal;
      

      //Extract value
      {int gen2086;
            int err = Tcl_GetBooleanFromObj(interp, objv[0], (int*)&gen2086);
            newVal=gen2086;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      highQuality = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1100 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1100", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewBooleanObj(antialiasing);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1101 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1101", TCL_VOLATILE);
        return TCL_ERROR;
      }
      bool newVal;
      

      //Extract value
      {int gen2087;
            int err = Tcl_GetBooleanFromObj(interp, objv[0], (int*)&gen2087);
            newVal=gen2087;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      antialiasing = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }


 int get1103 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1103", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewBooleanObj(headless);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1105 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1105", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)cameraX1);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1106 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1106", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      cameraX1 = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1108 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1108", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)cameraX2);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1109 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1109", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      cameraX2 = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1111 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1111", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)cameraY1);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1112 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1112", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      cameraY1 = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1114 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1114", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)cameraY2);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1115 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1115", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      cameraY2 = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1117 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1117", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)cameraCX);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1118 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1118", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      cameraCX = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1120 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1120", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)cameraCY);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1121 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1121", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      cameraCY = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1123 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1123", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)cameraZoom);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1124 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1124", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      cameraZoom = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1126 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1126", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)cursorX);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1127 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1127", TCL_VOLATILE);
        return TCL_ERROR;
      }
      int newVal;
      

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (int)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      cursorX = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1129 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1129", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)cursorY);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1130 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1130", TCL_VOLATILE);
        return TCL_ERROR;
      }
      int newVal;
      

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (int)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      cursorY = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1132 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1132", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)oldCursorX);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1133 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1133", TCL_VOLATILE);
        return TCL_ERROR;
      }
      int newVal;
      

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (int)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      oldCursorX = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1135 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1135", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)oldCursorY);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
 int set1136 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set1136", TCL_VOLATILE);
        return TCL_ERROR;
      }
      int newVal;
      

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (int)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      oldCursorY = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[0]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }


 int get1138 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1138", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)currentFrameTime);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1140 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1140", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)currentFrameTimeLeft);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1142 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1142", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewBooleanObj(currentVFrameLast);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1144 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1144", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)frameRate);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1146 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1146", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)sparkCountMultiplier);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get1148 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1148", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)gameClock);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

class TclPeer : public Peer {
      public:
static int get1289 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1289", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Peer* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {if (!(&parent->gid)) {
      objout=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(&parent->gid));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (&parent->gid)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(&parent->gid))];
        ex->interp=interp;
        (&parent->gid)->ownStat = AObject::Container;

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(&parent->gid)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      objout=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1291 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1291", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Peer* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->nid);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1293 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1293", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Peer* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewBooleanObj(parent->overseerReady);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1295 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1295", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Peer* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->connectionAttempts);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1297 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1297", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Peer* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {if (!(parent->cxn)) {
      objout=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(parent->cxn));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (parent->cxn)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(parent->cxn))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(parent->cxn)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      objout=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1299 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1299", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Peer* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(parent->screenName.c_str(), -1, &dstr);
        objout = Tcl_NewUnicodeObj(tuc, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get1301 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1301", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Peer* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewBooleanObj(parent->receivedStx);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ get1289", get1289, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1291", get1291, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1293", get1293, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1295", get1295, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1297", get1297, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1299", get1299, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get1301", get1301, 0, NULL);
TypeExport* ste=new TypeExport(typeid(Peer)),
                           * ete=new TypeExport(typeid(TclPeer));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="Peer";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(Peer));
typeExports[&typeid(Peer)]=ste;
typeExports[&typeid(TclPeer)]=ete;
}
};
void classdec1288(bool safe, Tcl_Interp* interp) throw() {
  TclPeer::cppDecCode(safe,interp);
}
class TclNetIface : public NetIface {
      public:
TclNetIface() : NetIface() {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static NetIface* constructorTcldefault
    (const string& name, const string& magicCookie ) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      TclNetIface* ret;
      ret=new TclNetIface();
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(TclNetIface)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1304 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
NetIface* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      ret =
     
     
     constructorTcldefault(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       addPeer (Peer* arg0 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "addPeer";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
Tcl_Obj* arg0Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {if (!(arg0)) {
      arg0Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg0));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg0)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg0))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg0)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg0Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg0Tcl);
         {
        Tcl_Obj* objv[3] = {
          thisTcl,
          meth,
          arg0Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1306 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
Peer* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      
     parent->
     
     addPeer(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       delPeer (Peer* arg0 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "delPeer";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
Tcl_Obj* arg0Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {if (!(arg0)) {
      arg0Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg0));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg0)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg0))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg0)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg0Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg0Tcl);
         {
        Tcl_Obj* objv[3] = {
          thisTcl,
          meth,
          arg0Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1308 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
Peer* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      
     parent->
     
     delPeer(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       setOverseer (Peer* arg0 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "setOverseer";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
Tcl_Obj* arg0Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {if (!(arg0)) {
      arg0Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg0));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg0)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg0))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg0)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg0Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg0Tcl);
         {
        Tcl_Obj* objv[3] = {
          thisTcl,
          meth,
          arg0Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1310 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
Peer* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      
     parent->
     
     setOverseer(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       receiveBroadcast (Peer* arg0 ,const char* arg1 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "receiveBroadcast";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
Tcl_Obj* arg0Tcl = NULL;
Tcl_Obj* arg1Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {if (!(arg0)) {
      arg0Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg0));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg0)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg0))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg0)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg0Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg0Tcl);
        {
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(arg1? arg1 : "", -1, &dstr);
        arg1Tcl = Tcl_NewUnicodeObj(tuc, -1);
      }
          Tcl_IncrRefCount(arg1Tcl);
         {
        Tcl_Obj* objv[4] = {
          thisTcl,
          meth,
          arg0Tcl, arg1Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;
Tcl_DecrRefCount(arg1Tcl);
arg1Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
if (arg1Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg1Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1312 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
Peer* arg0; bool arg0Init=false;
const char* arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
          arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg1Init=true;
try {
      
     parent->
     
     receiveBroadcast(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       receiveOverseer (Peer* arg0 ,const char* arg1 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "receiveOverseer";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
Tcl_Obj* arg0Tcl = NULL;
Tcl_Obj* arg1Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {if (!(arg0)) {
      arg0Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg0));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg0)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg0))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg0)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg0Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg0Tcl);
        {
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(arg1? arg1 : "", -1, &dstr);
        arg1Tcl = Tcl_NewUnicodeObj(tuc, -1);
      }
          Tcl_IncrRefCount(arg1Tcl);
         {
        Tcl_Obj* objv[4] = {
          thisTcl,
          meth,
          arg0Tcl, arg1Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;
Tcl_DecrRefCount(arg1Tcl);
arg1Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
if (arg1Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg1Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1314 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
Peer* arg0; bool arg0Init=false;
const char* arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
          arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg1Init=true;
try {
      
     parent->
     
     receiveOverseer(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       receiveUnicast (Peer* arg0 ,const char* arg1 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "receiveUnicast";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
Tcl_Obj* arg0Tcl = NULL;
Tcl_Obj* arg1Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {if (!(arg0)) {
      arg0Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg0));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg0)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg0))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg0)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg0Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg0Tcl);
        {
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(arg1? arg1 : "", -1, &dstr);
        arg1Tcl = Tcl_NewUnicodeObj(tuc, -1);
      }
          Tcl_IncrRefCount(arg1Tcl);
         {
        Tcl_Obj* objv[4] = {
          thisTcl,
          meth,
          arg0Tcl, arg1Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;
Tcl_DecrRefCount(arg1Tcl);
arg1Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
if (arg1Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg1Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1316 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
Peer* arg0; bool arg0Init=false;
const char* arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
          arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg1Init=true;
try {
      
     parent->
     
     receiveUnicast(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       bool
       alterDatp (Peer* arg0 ,const char* arg1 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "alterDatp";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);

          Tcl_Obj* returnValueTcl=NULL;
          bool returnValue;
Tcl_Obj* arg0Tcl = NULL;
Tcl_Obj* arg1Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {if (!(arg0)) {
      arg0Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg0));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg0)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg0))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg0)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg0Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg0Tcl);
        {
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(arg1? arg1 : "", -1, &dstr);
        arg1Tcl = Tcl_NewUnicodeObj(tuc, -1);
      }
          Tcl_IncrRefCount(arg1Tcl);
         {
        Tcl_Obj* objv[4] = {
          thisTcl,
          meth,
          arg0Tcl, arg1Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;
Tcl_DecrRefCount(arg1Tcl);
arg1Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
returnValueTcl = Tcl_GetObjResult(interp);
        {int gen2170;
            int err = Tcl_GetBooleanFromObj(interp, returnValueTcl, (int*)&gen2170);
            returnValue=gen2170;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }}
        //Run any check code we may have
        { bool ok=true;
          #define val returnValue
          
          #undef val
          if (!ok) {
            //Cancel import and fail
            
            scriptingErrorMessage = "Unacceptable return value from Tcl override";
            goto long_jump;
          }
        }
        return returnValue;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
if (arg1Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg1Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1318 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
Peer* arg0; bool arg0Init=false;
const char* arg1; bool arg1Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
          arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg1Init=true;
try {
      ret =
     parent->
     
     alterDatp(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       bool
       alterDats (const char* arg0 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "alterDats";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);

          Tcl_Obj* returnValueTcl=NULL;
          bool returnValue;
Tcl_Obj* arg0Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(arg0? arg0 : "", -1, &dstr);
        arg0Tcl = Tcl_NewUnicodeObj(tuc, -1);
      }
          Tcl_IncrRefCount(arg0Tcl);
         {
        Tcl_Obj* objv[3] = {
          thisTcl,
          meth,
          arg0Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
returnValueTcl = Tcl_GetObjResult(interp);
        {int gen2173;
            int err = Tcl_GetBooleanFromObj(interp, returnValueTcl, (int*)&gen2173);
            returnValue=gen2173;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }}
        //Run any check code we may have
        { bool ok=true;
          #define val returnValue
          
          #undef val
          if (!ok) {
            //Cancel import and fail
            
            scriptingErrorMessage = "Unacceptable return value from Tcl override";
            goto long_jump;
          }
        }
        return returnValue;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1320 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
const char* arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
          arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg0Init=true;
try {
      ret =
     parent->
     
     alterDats(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       setGameMode (const char* arg0 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "setGameMode";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
Tcl_Obj* arg0Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(arg0? arg0 : "", -1, &dstr);
        arg0Tcl = Tcl_NewUnicodeObj(tuc, -1);
      }
          Tcl_IncrRefCount(arg0Tcl);
         {
        Tcl_Obj* objv[3] = {
          thisTcl,
          meth,
          arg0Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1322 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
const char* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
          arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg0Init=true;
try {
      
     parent->
     
     setGameMode(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       const char*
       getGameMode ()   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "getGameMode";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);

          Tcl_Obj* returnValueTcl=NULL;
          const char* returnValue;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
       {
        Tcl_Obj* objv[2] = {
          thisTcl,
          meth,
          };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      
      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
returnValueTcl = Tcl_GetObjResult(interp);
        {
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(returnValueTcl, &length);
          returnValue = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        }
        //Run any check code we may have
        { bool ok=true;
          #define val returnValue
          
          #undef val
          if (!ok) {
            //Cancel import and fail
            
            scriptingErrorMessage = "Unacceptable return value from Tcl override";
            goto long_jump;
          }
        }
        return returnValue;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      }
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1324 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
const char* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getGameMode();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(ret? ret : "", -1, &dstr);
        retTcl = Tcl_NewUnicodeObj(tuc, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       connectionLost (const char* arg0 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "connectionLost";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
Tcl_Obj* arg0Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(arg0? arg0 : "", -1, &dstr);
        arg0Tcl = Tcl_NewUnicodeObj(tuc, -1);
      }
          Tcl_IncrRefCount(arg0Tcl);
         {
        Tcl_Obj* objv[3] = {
          thisTcl,
          meth,
          arg0Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1326 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
const char* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
          arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg0Init=true;
try {
      
     parent->
     
     connectionLost(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       string
       getFullDats ()   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "getFullDats";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);

          Tcl_Obj* returnValueTcl=NULL;
          string returnValue;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
       {
        Tcl_Obj* objv[2] = {
          thisTcl,
          meth,
          };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      
      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
returnValueTcl = Tcl_GetObjResult(interp);
        {
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(returnValueTcl, &length);
      returnValue = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    }
        //Run any check code we may have
        { bool ok=true;
          #define val returnValue
          
          #undef val
          if (!ok) {
            //Cancel import and fail
            
            scriptingErrorMessage = "Unacceptable return value from Tcl override";
            goto long_jump;
          }
        }
        return returnValue;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      }
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1328 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
string ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getFullDats();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(ret.c_str(), -1, &dstr);
        retTcl = Tcl_NewUnicodeObj(tuc, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       void
       receiveShip (NetworkConnection* arg0 ,Ship* arg1 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "receiveShip";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);
Tcl_Obj* arg0Tcl = NULL;
Tcl_Obj* arg1Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {if (!(arg0)) {
      arg0Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg0));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg0)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg0))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg0)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg0Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg0Tcl);
        {if (!(arg1)) {
      arg1Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg1));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg1)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg1))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg1)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg1Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg1Tcl);
         {
        Tcl_Obj* objv[4] = {
          thisTcl,
          meth,
          arg0Tcl, arg1Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;
Tcl_DecrRefCount(arg1Tcl);
arg1Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
return;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
if (arg1Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg1Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1330 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetIface* parent=NULL;
NetworkConnection* arg0; bool arg0Init=false;
Ship* arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkConnection)
        &&  0==ex->type->superclasses.count(&typeid(NetworkConnection))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkConnection, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkConnection* tmp=(NetworkConnection*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        arg1 = tmp;
    } else arg1=NULL;
};
arg1Init=true;
try {
      
     parent->
     
     receiveShip(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline1304", trampoline1304, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1306", trampoline1306, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1308", trampoline1308, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1310", trampoline1310, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1312", trampoline1312, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1314", trampoline1314, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1316", trampoline1316, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1318", trampoline1318, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1320", trampoline1320, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1322", trampoline1322, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1324", trampoline1324, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1326", trampoline1326, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1328", trampoline1328, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1330", trampoline1330, 0, NULL);
TypeExport* ste=new TypeExport(typeid(NetIface)),
                           * ete=new TypeExport(typeid(TclNetIface));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="NetIface";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(NetIface));
typeExports[&typeid(NetIface)]=ste;
typeExports[&typeid(TclNetIface)]=ete;
}
};
void classdec1303(bool safe, Tcl_Interp* interp) throw() {
  TclNetIface::cppDecCode(safe,interp);
}
class TclNetworkGame : public NetworkGame {
      public:
TclNetworkGame(GameField* arg2) : NetworkGame(arg2) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static NetworkGame* constructordefault
    (const string& name, const string& magicCookie,  GameField* arg2) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      NetworkGame* ret;
      ret=new NetworkGame(arg2);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(NetworkGame)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1333 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
NetworkGame* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
try {
      ret =
     
     
     constructordefault(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1335 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
Peer* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getLocalPeer();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1337 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
Peer* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getOverseer();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1339 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
NetworkConnection* arg0; bool arg0Init=false;
Peer* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkConnection)
        &&  0==ex->type->superclasses.count(&typeid(NetworkConnection))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkConnection, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkConnection* tmp=(NetworkConnection*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      ret =
     parent->
     
     getPeerByConnection(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1341 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
unsigned arg0; bool arg0Init=false;
Peer* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (unsigned)tmp;};
arg0Init=true;
try {
      ret =
     parent->
     
     getPeerByNid(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1343 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
string ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getDisconnectReason();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(ret.c_str(), -1, &dstr);
        retTcl = Tcl_NewUnicodeObj(tuc, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1345 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
NetIface* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetIface)
        &&  0==ex->type->superclasses.count(&typeid(NetIface))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetIface, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetIface* tmp=(NetIface*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      
     parent->
     
     setNetIface(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1347 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
const char* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
          arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg0Init=true;
try {
      
     parent->
     
     setAdvertising(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1349 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     stopAdvertising();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1351 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     startDiscoveryScan();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1353 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     discoveryScanProgress();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1355 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     discoveryScanDone();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1357 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
bool arg0; bool arg0Init=false;
string ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int gen2197;
            int err = Tcl_GetBooleanFromObj(interp, objv[1], (int*)&gen2197);
            arg0=gen2197;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg0Init=true;
try {
      ret =
     parent->
     
     getDiscoveryResults(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(ret.c_str(), -1, &dstr);
        retTcl = Tcl_NewUnicodeObj(tuc, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1359 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
const char* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
          arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg0Init=true;
try {
      
     parent->
     
     setLocalPeerName(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1361 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
unsigned arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (unsigned)tmp;};
arg0Init=true;
try {
      
     parent->
     
     setLocalPeerNID(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1363 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     setLocalPeerNIDAuto();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1365 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
bool arg0; bool arg0Init=false;
bool arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int gen2202;
            int err = Tcl_GetBooleanFromObj(interp, objv[1], (int*)&gen2202);
            arg0=gen2202;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg0Init=true;
{int gen2203;
            int err = Tcl_GetBooleanFromObj(interp, objv[2], (int*)&gen2203);
            arg1=gen2203;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg1Init=true;
try {
      
     parent->
     
     connectToNothing(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1367 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
unsigned arg0; bool arg0Init=false;
bool arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (unsigned)tmp;};
arg0Init=true;
{int gen2205;
            int err = Tcl_GetBooleanFromObj(interp, objv[2], (int*)&gen2205);
            arg1=gen2205;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg1Init=true;
try {
      
     parent->
     
     connectToDiscovery(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1369 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
const char* arg0; bool arg0Init=false;
unsigned arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
          arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg0Init=true;
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (unsigned)tmp;};
arg1Init=true;
try {
      
     parent->
     
     connectToLan(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1371 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
unsigned arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (unsigned)tmp;};
arg0Init=true;
try {
      
     parent->
     
     update(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1373 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     updateFieldSize();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1375 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
GameField* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      
     parent->
     
     changeField(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1377 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
string arg0; bool arg0Init=false;
Peer* arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg1 = tmp;
    } else arg1=NULL;
};
arg1Init=true;
try {
      
     parent->
     
     alterDats(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1379 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
string arg0; bool arg0Init=false;
Peer* arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg1 = tmp;
    } else arg1=NULL;
};
arg1Init=true;
try {
      
     parent->
     
     alterDatp(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1381 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
string arg0; bool arg0Init=false;
Peer* arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg1 = tmp;
    } else arg1=NULL;
};
arg1Init=true;
try {
      
     parent->
     
     sendUnicast(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1383 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
string arg0; bool arg0Init=false;
Peer* arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg1 = tmp;
    } else arg1=NULL;
};
arg1Init=true;
try {
      
     parent->
     
     sendOverseer(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1385 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
string arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      
     parent->
     
     sendBroadcast(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1387 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
Peer* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      
     parent->
     
     sendGameMode(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1389 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       NetworkGame* parent=NULL;
Peer* arg0; bool arg0Init=false;
unsigned arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkGame)
        &&  0==ex->type->superclasses.count(&typeid(NetworkGame))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkGame, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkGame* tmp=(NetworkGame*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Peer)
        &&  0==ex->type->superclasses.count(&typeid(Peer))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Peer, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Peer* tmp=(Peer*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (unsigned)tmp;};
arg1Init=true;
try {
      
     parent->
     
     setBlameMask(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline1333", trampoline1333, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1335", trampoline1335, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1337", trampoline1337, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1339", trampoline1339, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1341", trampoline1341, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1343", trampoline1343, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1345", trampoline1345, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1347", trampoline1347, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1349", trampoline1349, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1351", trampoline1351, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1353", trampoline1353, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1355", trampoline1355, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1357", trampoline1357, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1359", trampoline1359, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1361", trampoline1361, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1363", trampoline1363, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1365", trampoline1365, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1367", trampoline1367, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1369", trampoline1369, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1371", trampoline1371, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1373", trampoline1373, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1375", trampoline1375, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1377", trampoline1377, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1379", trampoline1379, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1381", trampoline1381, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1383", trampoline1383, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1385", trampoline1385, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1387", trampoline1387, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1389", trampoline1389, 0, NULL);
TypeExport* ste=new TypeExport(typeid(NetworkGame)),
                           * ete=new TypeExport(typeid(TclNetworkGame));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="NetworkGame";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(NetworkGame));
typeExports[&typeid(NetworkGame)]=ste;
typeExports[&typeid(TclNetworkGame)]=ete;
}
};
void classdec1332(bool safe, Tcl_Interp* interp) throw() {
  TclNetworkGame::cppDecCode(safe,interp);
}

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1391 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
unsigned arg0; bool arg0Init=false;
const char* arg1; bool arg1Init=false;
unsigned arg2; bool arg2Init=false;
const char* arg3; bool arg3Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (unsigned)tmp;};
arg0Init=true;
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
          arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg1Init=true;
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg2 = (unsigned)tmp;};
arg2Init=true;
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[3], &length);
          arg3 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg3Init=true;
try {
      
     
     
     abuhops::connect(arg0, arg1, arg2, arg3);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1393 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      ret =
     
     
     abuhops::ready();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1395 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      
     
     
     abuhops::list();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


