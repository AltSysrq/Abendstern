
  /**
   * @file
   * @author C++-Tcl Bridge Code Generator
   * @brief Autogenerated bindings; <b>not intended for human consumption</b>
   *
   * AUTOGENERATED BY generate.tcl. DO NOT EDIT DIRECTLY.
   * @see src/tcl_iface/readme.txt
   */

  #include <map>
  #include <set>
  #include <vector>
  #include <string>
  #include <cstring>
  #include <cstdio>
  #include <cstdlib>
  #include <iostream>

  #include <GL/gl.h>
  #include <SDL.h>
  #include <tcl.h>
  #include <itcl.h>
  #include <libconfig.h++>

  #include "src/tcl_iface/bridge.hxx"
  #include "src/tcl_iface/implementation.hxx"
  #include "src/tcl_iface/dynfun.hxx"
  #include "src/exit_conditions.hxx"
  #include "src/globals.hxx"

  #pragma GCC diagnostic ignored "-Wunused-label"
  #pragma GCC diagnostic ignored "-Waddress"
  using namespace std;
  using namespace tcl_glue_implementation;
  using namespace libconfig;

  //Commands get their zeroth argument as their own name;
  //code generation is simpler if we drop this
  #define SHIFT ++objv, --objc

#include "src/ship/ship.hxx"
#include "src/sim/game_field.hxx"
#include "src/control/controller.hxx"
#include "src/camera/effects_handler.hxx"
#include "src/ship/cell/cell.hxx"
#include "src/camera/dynamic_camera.hxx"
#include "src/ship/cell/cell.hxx"
#include "src/secondary/confreg.hxx"
 int get59 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get59", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_NONE);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get61 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get61", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_LSHIFT);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get63 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get63", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_RSHIFT);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get65 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get65", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_LCTRL);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get67 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get67", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_RCTRL);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get69 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get69", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_LALT);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get71 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get71", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_RALT);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get73 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get73", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_LMETA);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get75 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get75", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_RMETA);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get77 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get77", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_NUM);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get79 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get79", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_CAPS);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get81 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get81", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_MODE);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get83 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get83", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)KMOD_RESERVED);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

class TclSDL_keysym : public SDL_keysym {
      public:
static int get86 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get86", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->scancode);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set87 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set87", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint8)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->scancode = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get89 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get89", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->sym)
      {

          case SDLK_UNKNOWN: tmp="k_unknown"; break;
          case SDLK_RETURN: tmp="k_enter"; break;
          case SDLK_SCROLLOCK: tmp="k_scrolllock"; break;
          case SDLK_BACKSPACE: tmp="k_backspace"; break;
          case SDLK_TAB: tmp="k_tab"; break;
          case SDLK_CLEAR: tmp="k_clear"; break;
          case SDLK_PAUSE: tmp="k_pause"; break;
          case SDLK_ESCAPE: tmp="k_escape"; break;
          case SDLK_SPACE: tmp="k_space"; break;
          case SDLK_EXCLAIM: tmp="k_exclaim"; break;
          case SDLK_QUOTEDBL: tmp="k_quotedbl"; break;
          case SDLK_HASH: tmp="k_hash"; break;
          case SDLK_DOLLAR: tmp="k_dollar"; break;
          case SDLK_AMPERSAND: tmp="k_ampersand"; break;
          case SDLK_QUOTE: tmp="k_quote"; break;
          case SDLK_LEFTPAREN: tmp="k_leftparen"; break;
          case SDLK_RIGHTPAREN: tmp="k_rightparen"; break;
          case SDLK_ASTERISK: tmp="k_asterisk"; break;
          case SDLK_PLUS: tmp="k_plus"; break;
          case SDLK_COMMA: tmp="k_comma"; break;
          case SDLK_MINUS: tmp="k_minus"; break;
          case SDLK_PERIOD: tmp="k_period"; break;
          case SDLK_SLASH: tmp="k_slash"; break;
          case SDLK_0: tmp="k_0"; break;
          case SDLK_1: tmp="k_1"; break;
          case SDLK_2: tmp="k_2"; break;
          case SDLK_3: tmp="k_3"; break;
          case SDLK_4: tmp="k_4"; break;
          case SDLK_5: tmp="k_5"; break;
          case SDLK_6: tmp="k_6"; break;
          case SDLK_7: tmp="k_7"; break;
          case SDLK_8: tmp="k_8"; break;
          case SDLK_9: tmp="k_9"; break;
          case SDLK_COLON: tmp="k_colon"; break;
          case SDLK_SEMICOLON: tmp="k_semicolon"; break;
          case SDLK_LESS: tmp="k_less"; break;
          case SDLK_EQUALS: tmp="k_equals"; break;
          case SDLK_GREATER: tmp="k_greater"; break;
          case SDLK_QUESTION: tmp="k_question"; break;
          case SDLK_AT: tmp="k_at"; break;
          case SDLK_LEFTBRACKET: tmp="k_leftbracket"; break;
          case SDLK_BACKSLASH: tmp="k_backslash"; break;
          case SDLK_RIGHTBRACKET: tmp="k_rightbracket"; break;
          case SDLK_CARET: tmp="k_caret"; break;
          case SDLK_UNDERSCORE: tmp="k_underscore"; break;
          case SDLK_BACKQUOTE: tmp="k_backquote"; break;
          case SDLK_DELETE: tmp="k_delete"; break;
          case SDLK_KP0: tmp="k_kp0"; break;
          case SDLK_KP1: tmp="k_kp1"; break;
          case SDLK_KP2: tmp="k_kp2"; break;
          case SDLK_KP3: tmp="k_kp3"; break;
          case SDLK_KP4: tmp="k_kp4"; break;
          case SDLK_KP5: tmp="k_kp5"; break;
          case SDLK_KP6: tmp="k_kp6"; break;
          case SDLK_KP7: tmp="k_kp7"; break;
          case SDLK_KP8: tmp="k_kp8"; break;
          case SDLK_KP9: tmp="k_kp9"; break;
          case SDLK_KP_PERIOD: tmp="k_kp_period"; break;
          case SDLK_KP_DIVIDE: tmp="k_kp_divide"; break;
          case SDLK_KP_MULTIPLY: tmp="k_kp_multiply"; break;
          case SDLK_KP_MINUS: tmp="k_kp_minus"; break;
          case SDLK_KP_PLUS: tmp="k_kp_plus"; break;
          case SDLK_KP_ENTER: tmp="k_kp_enter"; break;
          case SDLK_KP_EQUALS: tmp="k_kp_equals"; break;
          case SDLK_UP: tmp="k_up"; break;
          case SDLK_DOWN: tmp="k_down"; break;
          case SDLK_RIGHT: tmp="k_right"; break;
          case SDLK_LEFT: tmp="k_left"; break;
          case SDLK_INSERT: tmp="k_insert"; break;
          case SDLK_HOME: tmp="k_home"; break;
          case SDLK_END: tmp="k_end"; break;
          case SDLK_PAGEUP: tmp="k_pageup"; break;
          case SDLK_PAGEDOWN: tmp="k_pagedown"; break;
          case SDLK_F1: tmp="k_f1"; break;
          case SDLK_F2: tmp="k_f2"; break;
          case SDLK_F3: tmp="k_f3"; break;
          case SDLK_F4: tmp="k_f4"; break;
          case SDLK_F5: tmp="k_f5"; break;
          case SDLK_F6: tmp="k_f6"; break;
          case SDLK_F7: tmp="k_f7"; break;
          case SDLK_F8: tmp="k_f8"; break;
          case SDLK_F9: tmp="k_f9"; break;
          case SDLK_F10: tmp="k_f10"; break;
          case SDLK_F11: tmp="k_f11"; break;
          case SDLK_F12: tmp="k_f12"; break;
          case SDLK_F13: tmp="k_f13"; break;
          case SDLK_F14: tmp="k_f14"; break;
          case SDLK_F15: tmp="k_f15"; break;
          case SDLK_NUMLOCK: tmp="k_numlock"; break;
          case SDLK_CAPSLOCK: tmp="k_capslock"; break;
          case SDLK_RSHIFT: tmp="k_rshift"; break;
          case SDLK_LSHIFT: tmp="k_lshift"; break;
          case SDLK_RCTRL: tmp="k_rctrl"; break;
          case SDLK_LCTRL: tmp="k_lctrl"; break;
          case SDLK_RALT: tmp="k_ralt"; break;
          case SDLK_LALT: tmp="k_lalt"; break;
          case SDLK_RMETA: tmp="k_rmeta"; break;
          case SDLK_LMETA: tmp="k_lmeta"; break;
          case SDLK_LSUPER: tmp="k_lsuper"; break;
          case SDLK_RSUPER: tmp="k_rsuper"; break;
          case SDLK_MODE: tmp="k_mode"; break;
          case SDLK_COMPOSE: tmp="k_compose"; break;
          case SDLK_HELP: tmp="k_help"; break;
          case SDLK_PRINT: tmp="k_print"; break;
          case SDLK_SYSREQ: tmp="k_sysreq"; break;
          case SDLK_BREAK: tmp="k_break"; break;
          case SDLK_MENU: tmp="k_menu"; break;
          case SDLK_POWER: tmp="k_power"; break;
          case SDLK_EURO: tmp="k_euro"; break;
          case SDLK_UNDO: tmp="k_undo"; break;
          case SDLK_a: tmp="k_a"; break;
          case SDLK_b: tmp="k_b"; break;
          case SDLK_c: tmp="k_c"; break;
          case SDLK_d: tmp="k_d"; break;
          case SDLK_e: tmp="k_e"; break;
          case SDLK_f: tmp="k_f"; break;
          case SDLK_g: tmp="k_g"; break;
          case SDLK_h: tmp="k_h"; break;
          case SDLK_i: tmp="k_i"; break;
          case SDLK_j: tmp="k_j"; break;
          case SDLK_k: tmp="k_k"; break;
          case SDLK_l: tmp="k_l"; break;
          case SDLK_m: tmp="k_m"; break;
          case SDLK_n: tmp="k_n"; break;
          case SDLK_o: tmp="k_o"; break;
          case SDLK_p: tmp="k_p"; break;
          case SDLK_q: tmp="k_q"; break;
          case SDLK_r: tmp="k_r"; break;
          case SDLK_s: tmp="k_s"; break;
          case SDLK_t: tmp="k_t"; break;
          case SDLK_u: tmp="k_u"; break;
          case SDLK_v: tmp="k_v"; break;
          case SDLK_w: tmp="k_w"; break;
          case SDLK_x: tmp="k_x"; break;
          case SDLK_y: tmp="k_y"; break;
          case SDLK_z: tmp="k_z"; break;
          case SDLK_WORLD_0: tmp="k_world_0"; break;
          case SDLK_WORLD_1: tmp="k_world_1"; break;
          case SDLK_WORLD_2: tmp="k_world_2"; break;
          case SDLK_WORLD_3: tmp="k_world_3"; break;
          case SDLK_WORLD_4: tmp="k_world_4"; break;
          case SDLK_WORLD_5: tmp="k_world_5"; break;
          case SDLK_WORLD_6: tmp="k_world_6"; break;
          case SDLK_WORLD_7: tmp="k_world_7"; break;
          case SDLK_WORLD_8: tmp="k_world_8"; break;
          case SDLK_WORLD_9: tmp="k_world_9"; break;
          case SDLK_WORLD_10: tmp="k_world_10"; break;
          case SDLK_WORLD_11: tmp="k_world_11"; break;
          case SDLK_WORLD_12: tmp="k_world_12"; break;
          case SDLK_WORLD_13: tmp="k_world_13"; break;
          case SDLK_WORLD_14: tmp="k_world_14"; break;
          case SDLK_WORLD_15: tmp="k_world_15"; break;
          case SDLK_WORLD_16: tmp="k_world_16"; break;
          case SDLK_WORLD_17: tmp="k_world_17"; break;
          case SDLK_WORLD_18: tmp="k_world_18"; break;
          case SDLK_WORLD_19: tmp="k_world_19"; break;
          case SDLK_WORLD_20: tmp="k_world_20"; break;
          case SDLK_WORLD_21: tmp="k_world_21"; break;
          case SDLK_WORLD_22: tmp="k_world_22"; break;
          case SDLK_WORLD_23: tmp="k_world_23"; break;
          case SDLK_WORLD_24: tmp="k_world_24"; break;
          case SDLK_WORLD_25: tmp="k_world_25"; break;
          case SDLK_WORLD_26: tmp="k_world_26"; break;
          case SDLK_WORLD_27: tmp="k_world_27"; break;
          case SDLK_WORLD_28: tmp="k_world_28"; break;
          case SDLK_WORLD_29: tmp="k_world_29"; break;
          case SDLK_WORLD_30: tmp="k_world_30"; break;
          case SDLK_WORLD_31: tmp="k_world_31"; break;
          case SDLK_WORLD_32: tmp="k_world_32"; break;
          case SDLK_WORLD_33: tmp="k_world_33"; break;
          case SDLK_WORLD_34: tmp="k_world_34"; break;
          case SDLK_WORLD_35: tmp="k_world_35"; break;
          case SDLK_WORLD_36: tmp="k_world_36"; break;
          case SDLK_WORLD_37: tmp="k_world_37"; break;
          case SDLK_WORLD_38: tmp="k_world_38"; break;
          case SDLK_WORLD_39: tmp="k_world_39"; break;
          case SDLK_WORLD_40: tmp="k_world_40"; break;
          case SDLK_WORLD_41: tmp="k_world_41"; break;
          case SDLK_WORLD_42: tmp="k_world_42"; break;
          case SDLK_WORLD_43: tmp="k_world_43"; break;
          case SDLK_WORLD_44: tmp="k_world_44"; break;
          case SDLK_WORLD_45: tmp="k_world_45"; break;
          case SDLK_WORLD_46: tmp="k_world_46"; break;
          case SDLK_WORLD_47: tmp="k_world_47"; break;
          case SDLK_WORLD_48: tmp="k_world_48"; break;
          case SDLK_WORLD_49: tmp="k_world_49"; break;
          case SDLK_WORLD_50: tmp="k_world_50"; break;
          case SDLK_WORLD_51: tmp="k_world_51"; break;
          case SDLK_WORLD_52: tmp="k_world_52"; break;
          case SDLK_WORLD_53: tmp="k_world_53"; break;
          case SDLK_WORLD_54: tmp="k_world_54"; break;
          case SDLK_WORLD_55: tmp="k_world_55"; break;
          case SDLK_WORLD_56: tmp="k_world_56"; break;
          case SDLK_WORLD_57: tmp="k_world_57"; break;
          case SDLK_WORLD_58: tmp="k_world_58"; break;
          case SDLK_WORLD_59: tmp="k_world_59"; break;
          case SDLK_WORLD_60: tmp="k_world_60"; break;
          case SDLK_WORLD_61: tmp="k_world_61"; break;
          case SDLK_WORLD_62: tmp="k_world_62"; break;
          case SDLK_WORLD_63: tmp="k_world_63"; break;
          case SDLK_WORLD_64: tmp="k_world_64"; break;
          case SDLK_WORLD_65: tmp="k_world_65"; break;
          case SDLK_WORLD_66: tmp="k_world_66"; break;
          case SDLK_WORLD_67: tmp="k_world_67"; break;
          case SDLK_WORLD_68: tmp="k_world_68"; break;
          case SDLK_WORLD_69: tmp="k_world_69"; break;
          case SDLK_WORLD_70: tmp="k_world_70"; break;
          case SDLK_WORLD_71: tmp="k_world_71"; break;
          case SDLK_WORLD_72: tmp="k_world_72"; break;
          case SDLK_WORLD_73: tmp="k_world_73"; break;
          case SDLK_WORLD_74: tmp="k_world_74"; break;
          case SDLK_WORLD_75: tmp="k_world_75"; break;
          case SDLK_WORLD_76: tmp="k_world_76"; break;
          case SDLK_WORLD_77: tmp="k_world_77"; break;
          case SDLK_WORLD_78: tmp="k_world_78"; break;
          case SDLK_WORLD_79: tmp="k_world_79"; break;
          case SDLK_WORLD_80: tmp="k_world_80"; break;
          case SDLK_WORLD_81: tmp="k_world_81"; break;
          case SDLK_WORLD_82: tmp="k_world_82"; break;
          case SDLK_WORLD_83: tmp="k_world_83"; break;
          case SDLK_WORLD_84: tmp="k_world_84"; break;
          case SDLK_WORLD_85: tmp="k_world_85"; break;
          case SDLK_WORLD_86: tmp="k_world_86"; break;
          case SDLK_WORLD_87: tmp="k_world_87"; break;
          case SDLK_WORLD_88: tmp="k_world_88"; break;
          case SDLK_WORLD_89: tmp="k_world_89"; break;
          case SDLK_WORLD_90: tmp="k_world_90"; break;
          case SDLK_WORLD_91: tmp="k_world_91"; break;
          case SDLK_WORLD_92: tmp="k_world_92"; break;
          case SDLK_WORLD_93: tmp="k_world_93"; break;
          case SDLK_WORLD_94: tmp="k_world_94"; break;
          case SDLK_WORLD_95: tmp="k_world_95"; break;
          default:
          tmp = "k_unknown"; break;
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set90 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set90", TCL_VOLATILE);
        return TCL_ERROR;
      }
      SDLKey newVal;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "k_unknown")) {newVal=SDLK_UNKNOWN; goto done1517;}
        
          if (0 == strcmp(tmp, "k_enter")) {newVal=SDLK_RETURN; goto done1517;}
        
          if (0 == strcmp(tmp, "k_scrolllock")) {newVal=SDLK_SCROLLOCK; goto done1517;}
        
          if (0 == strcmp(tmp, "k_backspace")) {newVal=SDLK_BACKSPACE; goto done1517;}
        
          if (0 == strcmp(tmp, "k_tab")) {newVal=SDLK_TAB; goto done1517;}
        
          if (0 == strcmp(tmp, "k_clear")) {newVal=SDLK_CLEAR; goto done1517;}
        
          if (0 == strcmp(tmp, "k_pause")) {newVal=SDLK_PAUSE; goto done1517;}
        
          if (0 == strcmp(tmp, "k_escape")) {newVal=SDLK_ESCAPE; goto done1517;}
        
          if (0 == strcmp(tmp, "k_space")) {newVal=SDLK_SPACE; goto done1517;}
        
          if (0 == strcmp(tmp, "k_exclaim")) {newVal=SDLK_EXCLAIM; goto done1517;}
        
          if (0 == strcmp(tmp, "k_quotedbl")) {newVal=SDLK_QUOTEDBL; goto done1517;}
        
          if (0 == strcmp(tmp, "k_hash")) {newVal=SDLK_HASH; goto done1517;}
        
          if (0 == strcmp(tmp, "k_dollar")) {newVal=SDLK_DOLLAR; goto done1517;}
        
          if (0 == strcmp(tmp, "k_ampersand")) {newVal=SDLK_AMPERSAND; goto done1517;}
        
          if (0 == strcmp(tmp, "k_quote")) {newVal=SDLK_QUOTE; goto done1517;}
        
          if (0 == strcmp(tmp, "k_leftparen")) {newVal=SDLK_LEFTPAREN; goto done1517;}
        
          if (0 == strcmp(tmp, "k_rightparen")) {newVal=SDLK_RIGHTPAREN; goto done1517;}
        
          if (0 == strcmp(tmp, "k_asterisk")) {newVal=SDLK_ASTERISK; goto done1517;}
        
          if (0 == strcmp(tmp, "k_plus")) {newVal=SDLK_PLUS; goto done1517;}
        
          if (0 == strcmp(tmp, "k_comma")) {newVal=SDLK_COMMA; goto done1517;}
        
          if (0 == strcmp(tmp, "k_minus")) {newVal=SDLK_MINUS; goto done1517;}
        
          if (0 == strcmp(tmp, "k_period")) {newVal=SDLK_PERIOD; goto done1517;}
        
          if (0 == strcmp(tmp, "k_slash")) {newVal=SDLK_SLASH; goto done1517;}
        
          if (0 == strcmp(tmp, "k_0")) {newVal=SDLK_0; goto done1517;}
        
          if (0 == strcmp(tmp, "k_1")) {newVal=SDLK_1; goto done1517;}
        
          if (0 == strcmp(tmp, "k_2")) {newVal=SDLK_2; goto done1517;}
        
          if (0 == strcmp(tmp, "k_3")) {newVal=SDLK_3; goto done1517;}
        
          if (0 == strcmp(tmp, "k_4")) {newVal=SDLK_4; goto done1517;}
        
          if (0 == strcmp(tmp, "k_5")) {newVal=SDLK_5; goto done1517;}
        
          if (0 == strcmp(tmp, "k_6")) {newVal=SDLK_6; goto done1517;}
        
          if (0 == strcmp(tmp, "k_7")) {newVal=SDLK_7; goto done1517;}
        
          if (0 == strcmp(tmp, "k_8")) {newVal=SDLK_8; goto done1517;}
        
          if (0 == strcmp(tmp, "k_9")) {newVal=SDLK_9; goto done1517;}
        
          if (0 == strcmp(tmp, "k_colon")) {newVal=SDLK_COLON; goto done1517;}
        
          if (0 == strcmp(tmp, "k_semicolon")) {newVal=SDLK_SEMICOLON; goto done1517;}
        
          if (0 == strcmp(tmp, "k_less")) {newVal=SDLK_LESS; goto done1517;}
        
          if (0 == strcmp(tmp, "k_equals")) {newVal=SDLK_EQUALS; goto done1517;}
        
          if (0 == strcmp(tmp, "k_greater")) {newVal=SDLK_GREATER; goto done1517;}
        
          if (0 == strcmp(tmp, "k_question")) {newVal=SDLK_QUESTION; goto done1517;}
        
          if (0 == strcmp(tmp, "k_at")) {newVal=SDLK_AT; goto done1517;}
        
          if (0 == strcmp(tmp, "k_leftbracket")) {newVal=SDLK_LEFTBRACKET; goto done1517;}
        
          if (0 == strcmp(tmp, "k_backslash")) {newVal=SDLK_BACKSLASH; goto done1517;}
        
          if (0 == strcmp(tmp, "k_rightbracket")) {newVal=SDLK_RIGHTBRACKET; goto done1517;}
        
          if (0 == strcmp(tmp, "k_caret")) {newVal=SDLK_CARET; goto done1517;}
        
          if (0 == strcmp(tmp, "k_underscore")) {newVal=SDLK_UNDERSCORE; goto done1517;}
        
          if (0 == strcmp(tmp, "k_backquote")) {newVal=SDLK_BACKQUOTE; goto done1517;}
        
          if (0 == strcmp(tmp, "k_delete")) {newVal=SDLK_DELETE; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp0")) {newVal=SDLK_KP0; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp1")) {newVal=SDLK_KP1; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp2")) {newVal=SDLK_KP2; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp3")) {newVal=SDLK_KP3; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp4")) {newVal=SDLK_KP4; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp5")) {newVal=SDLK_KP5; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp6")) {newVal=SDLK_KP6; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp7")) {newVal=SDLK_KP7; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp8")) {newVal=SDLK_KP8; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp9")) {newVal=SDLK_KP9; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp_period")) {newVal=SDLK_KP_PERIOD; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp_divide")) {newVal=SDLK_KP_DIVIDE; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp_multiply")) {newVal=SDLK_KP_MULTIPLY; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp_minus")) {newVal=SDLK_KP_MINUS; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp_plus")) {newVal=SDLK_KP_PLUS; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp_enter")) {newVal=SDLK_KP_ENTER; goto done1517;}
        
          if (0 == strcmp(tmp, "k_kp_equals")) {newVal=SDLK_KP_EQUALS; goto done1517;}
        
          if (0 == strcmp(tmp, "k_up")) {newVal=SDLK_UP; goto done1517;}
        
          if (0 == strcmp(tmp, "k_down")) {newVal=SDLK_DOWN; goto done1517;}
        
          if (0 == strcmp(tmp, "k_right")) {newVal=SDLK_RIGHT; goto done1517;}
        
          if (0 == strcmp(tmp, "k_left")) {newVal=SDLK_LEFT; goto done1517;}
        
          if (0 == strcmp(tmp, "k_insert")) {newVal=SDLK_INSERT; goto done1517;}
        
          if (0 == strcmp(tmp, "k_home")) {newVal=SDLK_HOME; goto done1517;}
        
          if (0 == strcmp(tmp, "k_end")) {newVal=SDLK_END; goto done1517;}
        
          if (0 == strcmp(tmp, "k_pageup")) {newVal=SDLK_PAGEUP; goto done1517;}
        
          if (0 == strcmp(tmp, "k_pagedown")) {newVal=SDLK_PAGEDOWN; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f1")) {newVal=SDLK_F1; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f2")) {newVal=SDLK_F2; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f3")) {newVal=SDLK_F3; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f4")) {newVal=SDLK_F4; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f5")) {newVal=SDLK_F5; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f6")) {newVal=SDLK_F6; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f7")) {newVal=SDLK_F7; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f8")) {newVal=SDLK_F8; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f9")) {newVal=SDLK_F9; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f10")) {newVal=SDLK_F10; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f11")) {newVal=SDLK_F11; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f12")) {newVal=SDLK_F12; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f13")) {newVal=SDLK_F13; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f14")) {newVal=SDLK_F14; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f15")) {newVal=SDLK_F15; goto done1517;}
        
          if (0 == strcmp(tmp, "k_numlock")) {newVal=SDLK_NUMLOCK; goto done1517;}
        
          if (0 == strcmp(tmp, "k_capslock")) {newVal=SDLK_CAPSLOCK; goto done1517;}
        
          if (0 == strcmp(tmp, "k_rshift")) {newVal=SDLK_RSHIFT; goto done1517;}
        
          if (0 == strcmp(tmp, "k_lshift")) {newVal=SDLK_LSHIFT; goto done1517;}
        
          if (0 == strcmp(tmp, "k_rctrl")) {newVal=SDLK_RCTRL; goto done1517;}
        
          if (0 == strcmp(tmp, "k_lctrl")) {newVal=SDLK_LCTRL; goto done1517;}
        
          if (0 == strcmp(tmp, "k_ralt")) {newVal=SDLK_RALT; goto done1517;}
        
          if (0 == strcmp(tmp, "k_lalt")) {newVal=SDLK_LALT; goto done1517;}
        
          if (0 == strcmp(tmp, "k_rmeta")) {newVal=SDLK_RMETA; goto done1517;}
        
          if (0 == strcmp(tmp, "k_lmeta")) {newVal=SDLK_LMETA; goto done1517;}
        
          if (0 == strcmp(tmp, "k_lsuper")) {newVal=SDLK_LSUPER; goto done1517;}
        
          if (0 == strcmp(tmp, "k_rsuper")) {newVal=SDLK_RSUPER; goto done1517;}
        
          if (0 == strcmp(tmp, "k_mode")) {newVal=SDLK_MODE; goto done1517;}
        
          if (0 == strcmp(tmp, "k_compose")) {newVal=SDLK_COMPOSE; goto done1517;}
        
          if (0 == strcmp(tmp, "k_help")) {newVal=SDLK_HELP; goto done1517;}
        
          if (0 == strcmp(tmp, "k_print")) {newVal=SDLK_PRINT; goto done1517;}
        
          if (0 == strcmp(tmp, "k_sysreq")) {newVal=SDLK_SYSREQ; goto done1517;}
        
          if (0 == strcmp(tmp, "k_break")) {newVal=SDLK_BREAK; goto done1517;}
        
          if (0 == strcmp(tmp, "k_menu")) {newVal=SDLK_MENU; goto done1517;}
        
          if (0 == strcmp(tmp, "k_power")) {newVal=SDLK_POWER; goto done1517;}
        
          if (0 == strcmp(tmp, "k_euro")) {newVal=SDLK_EURO; goto done1517;}
        
          if (0 == strcmp(tmp, "k_undo")) {newVal=SDLK_UNDO; goto done1517;}
        
          if (0 == strcmp(tmp, "k_a")) {newVal=SDLK_a; goto done1517;}
        
          if (0 == strcmp(tmp, "k_b")) {newVal=SDLK_b; goto done1517;}
        
          if (0 == strcmp(tmp, "k_c")) {newVal=SDLK_c; goto done1517;}
        
          if (0 == strcmp(tmp, "k_d")) {newVal=SDLK_d; goto done1517;}
        
          if (0 == strcmp(tmp, "k_e")) {newVal=SDLK_e; goto done1517;}
        
          if (0 == strcmp(tmp, "k_f")) {newVal=SDLK_f; goto done1517;}
        
          if (0 == strcmp(tmp, "k_g")) {newVal=SDLK_g; goto done1517;}
        
          if (0 == strcmp(tmp, "k_h")) {newVal=SDLK_h; goto done1517;}
        
          if (0 == strcmp(tmp, "k_i")) {newVal=SDLK_i; goto done1517;}
        
          if (0 == strcmp(tmp, "k_j")) {newVal=SDLK_j; goto done1517;}
        
          if (0 == strcmp(tmp, "k_k")) {newVal=SDLK_k; goto done1517;}
        
          if (0 == strcmp(tmp, "k_l")) {newVal=SDLK_l; goto done1517;}
        
          if (0 == strcmp(tmp, "k_m")) {newVal=SDLK_m; goto done1517;}
        
          if (0 == strcmp(tmp, "k_n")) {newVal=SDLK_n; goto done1517;}
        
          if (0 == strcmp(tmp, "k_o")) {newVal=SDLK_o; goto done1517;}
        
          if (0 == strcmp(tmp, "k_p")) {newVal=SDLK_p; goto done1517;}
        
          if (0 == strcmp(tmp, "k_q")) {newVal=SDLK_q; goto done1517;}
        
          if (0 == strcmp(tmp, "k_r")) {newVal=SDLK_r; goto done1517;}
        
          if (0 == strcmp(tmp, "k_s")) {newVal=SDLK_s; goto done1517;}
        
          if (0 == strcmp(tmp, "k_t")) {newVal=SDLK_t; goto done1517;}
        
          if (0 == strcmp(tmp, "k_u")) {newVal=SDLK_u; goto done1517;}
        
          if (0 == strcmp(tmp, "k_v")) {newVal=SDLK_v; goto done1517;}
        
          if (0 == strcmp(tmp, "k_w")) {newVal=SDLK_w; goto done1517;}
        
          if (0 == strcmp(tmp, "k_x")) {newVal=SDLK_x; goto done1517;}
        
          if (0 == strcmp(tmp, "k_y")) {newVal=SDLK_y; goto done1517;}
        
          if (0 == strcmp(tmp, "k_z")) {newVal=SDLK_z; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_0")) {newVal=SDLK_WORLD_0; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_1")) {newVal=SDLK_WORLD_1; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_2")) {newVal=SDLK_WORLD_2; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_3")) {newVal=SDLK_WORLD_3; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_4")) {newVal=SDLK_WORLD_4; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_5")) {newVal=SDLK_WORLD_5; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_6")) {newVal=SDLK_WORLD_6; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_7")) {newVal=SDLK_WORLD_7; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_8")) {newVal=SDLK_WORLD_8; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_9")) {newVal=SDLK_WORLD_9; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_10")) {newVal=SDLK_WORLD_10; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_11")) {newVal=SDLK_WORLD_11; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_12")) {newVal=SDLK_WORLD_12; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_13")) {newVal=SDLK_WORLD_13; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_14")) {newVal=SDLK_WORLD_14; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_15")) {newVal=SDLK_WORLD_15; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_16")) {newVal=SDLK_WORLD_16; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_17")) {newVal=SDLK_WORLD_17; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_18")) {newVal=SDLK_WORLD_18; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_19")) {newVal=SDLK_WORLD_19; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_20")) {newVal=SDLK_WORLD_20; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_21")) {newVal=SDLK_WORLD_21; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_22")) {newVal=SDLK_WORLD_22; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_23")) {newVal=SDLK_WORLD_23; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_24")) {newVal=SDLK_WORLD_24; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_25")) {newVal=SDLK_WORLD_25; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_26")) {newVal=SDLK_WORLD_26; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_27")) {newVal=SDLK_WORLD_27; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_28")) {newVal=SDLK_WORLD_28; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_29")) {newVal=SDLK_WORLD_29; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_30")) {newVal=SDLK_WORLD_30; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_31")) {newVal=SDLK_WORLD_31; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_32")) {newVal=SDLK_WORLD_32; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_33")) {newVal=SDLK_WORLD_33; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_34")) {newVal=SDLK_WORLD_34; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_35")) {newVal=SDLK_WORLD_35; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_36")) {newVal=SDLK_WORLD_36; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_37")) {newVal=SDLK_WORLD_37; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_38")) {newVal=SDLK_WORLD_38; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_39")) {newVal=SDLK_WORLD_39; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_40")) {newVal=SDLK_WORLD_40; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_41")) {newVal=SDLK_WORLD_41; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_42")) {newVal=SDLK_WORLD_42; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_43")) {newVal=SDLK_WORLD_43; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_44")) {newVal=SDLK_WORLD_44; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_45")) {newVal=SDLK_WORLD_45; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_46")) {newVal=SDLK_WORLD_46; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_47")) {newVal=SDLK_WORLD_47; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_48")) {newVal=SDLK_WORLD_48; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_49")) {newVal=SDLK_WORLD_49; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_50")) {newVal=SDLK_WORLD_50; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_51")) {newVal=SDLK_WORLD_51; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_52")) {newVal=SDLK_WORLD_52; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_53")) {newVal=SDLK_WORLD_53; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_54")) {newVal=SDLK_WORLD_54; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_55")) {newVal=SDLK_WORLD_55; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_56")) {newVal=SDLK_WORLD_56; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_57")) {newVal=SDLK_WORLD_57; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_58")) {newVal=SDLK_WORLD_58; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_59")) {newVal=SDLK_WORLD_59; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_60")) {newVal=SDLK_WORLD_60; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_61")) {newVal=SDLK_WORLD_61; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_62")) {newVal=SDLK_WORLD_62; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_63")) {newVal=SDLK_WORLD_63; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_64")) {newVal=SDLK_WORLD_64; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_65")) {newVal=SDLK_WORLD_65; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_66")) {newVal=SDLK_WORLD_66; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_67")) {newVal=SDLK_WORLD_67; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_68")) {newVal=SDLK_WORLD_68; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_69")) {newVal=SDLK_WORLD_69; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_70")) {newVal=SDLK_WORLD_70; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_71")) {newVal=SDLK_WORLD_71; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_72")) {newVal=SDLK_WORLD_72; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_73")) {newVal=SDLK_WORLD_73; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_74")) {newVal=SDLK_WORLD_74; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_75")) {newVal=SDLK_WORLD_75; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_76")) {newVal=SDLK_WORLD_76; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_77")) {newVal=SDLK_WORLD_77; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_78")) {newVal=SDLK_WORLD_78; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_79")) {newVal=SDLK_WORLD_79; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_80")) {newVal=SDLK_WORLD_80; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_81")) {newVal=SDLK_WORLD_81; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_82")) {newVal=SDLK_WORLD_82; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_83")) {newVal=SDLK_WORLD_83; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_84")) {newVal=SDLK_WORLD_84; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_85")) {newVal=SDLK_WORLD_85; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_86")) {newVal=SDLK_WORLD_86; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_87")) {newVal=SDLK_WORLD_87; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_88")) {newVal=SDLK_WORLD_88; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_89")) {newVal=SDLK_WORLD_89; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_90")) {newVal=SDLK_WORLD_90; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_91")) {newVal=SDLK_WORLD_91; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_92")) {newVal=SDLK_WORLD_92; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_93")) {newVal=SDLK_WORLD_93; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_94")) {newVal=SDLK_WORLD_94; goto done1517;}
        
          if (0 == strcmp(tmp, "k_world_95")) {newVal=SDLK_WORLD_95; goto done1517;}
         {
        sprintf(staticError, "Unable to convert %s to SDLKey", tmp);
        scriptError(staticError);
      } 
done1517:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->sym = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get92 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get92", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->mod);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set93 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set93", TCL_VOLATILE);
        return TCL_ERROR;
      }
      SDLMod newVal;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (SDLMod)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->mod = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get95 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get95", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->unicode);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set96 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set96", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint16 newVal;
      SDL_keysym* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->unicode = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ get86", get86, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set87", set87, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get89", get89, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set90", set90, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get92", get92, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set93", set93, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get95", get95, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set96", set96, 0, NULL);
TypeExport* ste=new TypeExport(typeid(SDL_keysym)),
                           * ete=new TypeExport(typeid(TclSDL_keysym));
ste->isAObject=ete->isAObject=false;
ste->tclClassName=ete->tclClassName="SDL_keysym";
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(SDL_keysym));
typeExports[&typeid(SDL_keysym)]=ste;
typeExports[&typeid(TclSDL_keysym)]=ete;
}
};
void classdec85(bool safe, Tcl_Interp* interp) throw() {
  TclSDL_keysym::cppDecCode(safe,interp);
}
class TclSDL_KeyboardEvent : public SDL_KeyboardEvent {
      public:
static int get99 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get99", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->type)
      {

          case SDL_KEYDOWN: tmp="DOWN"; break;
          case SDL_KEYUP: tmp="UP"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration Uint8 value "
               << (int)parent->type << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set100 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set100", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "DOWN")) {newVal=SDL_KEYDOWN; goto done1521;}
        
          if (0 == strcmp(tmp, "UP")) {newVal=SDL_KEYUP; goto done1521;}
         {
        sprintf(staticError, "Unable to convert %s to Uint8", tmp);
        scriptError(staticError);
      } 
done1521:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->type = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get102 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get102", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->state)
      {

          case SDL_PRESSED: tmp="PRESSED"; break;
          case SDL_RELEASED: tmp="RELEASED"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration Uint8 value "
               << (int)parent->state << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set103 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set103", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "PRESSED")) {newVal=SDL_PRESSED; goto done1523;}
        
          if (0 == strcmp(tmp, "RELEASED")) {newVal=SDL_RELEASED; goto done1523;}
         {
        sprintf(staticError, "Unable to convert %s to Uint8", tmp);
        scriptError(staticError);
      } 
done1523:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->state = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get105 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get105", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {if (!(&parent->keysym)) {
      objout=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(&parent->keysym));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(SDL_keysym)];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(&parent->keysym)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      objout=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set106 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set106", TCL_VOLATILE);
        return TCL_ERROR;
      }
      SDL_keysym* newVal;
      SDL_KeyboardEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_KeyboardEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_KeyboardEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_KeyboardEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_KeyboardEvent* tmp=(SDL_KeyboardEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_keysym)
        &&  0==ex->type->superclasses.count(&typeid(SDL_keysym))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_keysym, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_keysym* tmp=(SDL_keysym*)ex->ptr;
        
        newVal = tmp;
    } else {scriptError("Null pointer assigned to immediate");}
}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->keysym = *newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ get99", get99, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set100", set100, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get102", get102, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set103", set103, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get105", get105, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set106", set106, 0, NULL);
TypeExport* ste=new TypeExport(typeid(SDL_KeyboardEvent)),
                           * ete=new TypeExport(typeid(TclSDL_KeyboardEvent));
ste->isAObject=ete->isAObject=false;
ste->tclClassName=ete->tclClassName="SDL_KeyboardEvent";
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(SDL_KeyboardEvent));
typeExports[&typeid(SDL_KeyboardEvent)]=ste;
typeExports[&typeid(TclSDL_KeyboardEvent)]=ete;
}
};
void classdec98(bool safe, Tcl_Interp* interp) throw() {
  TclSDL_KeyboardEvent::cppDecCode(safe,interp);
}
 int get108 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get108", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_BUTTON(1));}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get110 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get110", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_BUTTON(2));}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get112 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get112", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_BUTTON(3));}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get114 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get114", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_BUTTON(4));}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get116 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get116", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_BUTTON(5));}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline118 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
SDLMod ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      ret =
     
     
     SDL_GetModState();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

 int get120 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get120", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_DEFAULT_REPEAT_INTERVAL);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

 int get122 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get122", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewIntObj((int)SDL_DEFAULT_REPEAT_DELAY);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline124 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
int arg0; bool arg0Init=false;
int arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (int)tmp;};
arg0Init=true;
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (int)tmp;};
arg1Init=true;
try {
      
     
     
     SDL_EnableKeyRepeat(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


class TclSDL_MouseMotionEvent : public SDL_MouseMotionEvent {
      public:
static int get127 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get127", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->type);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set128 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set128", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint8)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->type = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get130 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get130", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->state);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set131 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set131", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint8)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->state = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get133 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get133", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->x);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set134 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set134", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint16 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->x = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get136 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get136", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->y);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set137 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set137", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint16 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->y = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get139 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get139", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->xrel);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set140 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set140", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Sint16 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Sint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->xrel = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get142 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get142", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->yrel);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set143 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set143", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Sint16 newVal;
      SDL_MouseMotionEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseMotionEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseMotionEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseMotionEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseMotionEvent* tmp=(SDL_MouseMotionEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Sint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->yrel = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ get127", get127, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set128", set128, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get130", get130, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set131", set131, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get133", get133, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set134", set134, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get136", get136, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set137", set137, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get139", get139, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set140", set140, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get142", get142, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set143", set143, 0, NULL);
TypeExport* ste=new TypeExport(typeid(SDL_MouseMotionEvent)),
                           * ete=new TypeExport(typeid(TclSDL_MouseMotionEvent));
ste->isAObject=ete->isAObject=false;
ste->tclClassName=ete->tclClassName="SDL_MouseMotionEvent";
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(SDL_MouseMotionEvent));
typeExports[&typeid(SDL_MouseMotionEvent)]=ste;
typeExports[&typeid(TclSDL_MouseMotionEvent)]=ete;
}
};
void classdec126(bool safe, Tcl_Interp* interp) throw() {
  TclSDL_MouseMotionEvent::cppDecCode(safe,interp);
}
class TclSDL_MouseButtonEvent : public SDL_MouseButtonEvent {
      public:
static int get146 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get146", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->type)
      {

          case SDL_MOUSEBUTTONDOWN: tmp="DOWN"; break;
          case SDL_MOUSEBUTTONUP: tmp="UP"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration Uint8 value "
               << (int)parent->type << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set147 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set147", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "DOWN")) {newVal=SDL_MOUSEBUTTONDOWN; goto done1533;}
        
          if (0 == strcmp(tmp, "UP")) {newVal=SDL_MOUSEBUTTONUP; goto done1533;}
         {
        sprintf(staticError, "Unable to convert %s to Uint8", tmp);
        scriptError(staticError);
      } 
done1533:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->type = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get149 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get149", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->which);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set150 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set150", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint8)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->which = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get152 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get152", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->button)
      {

          case SDL_BUTTON_LEFT: tmp="mb_left"; break;
          case SDL_BUTTON_MIDDLE: tmp="mb_mid"; break;
          case SDL_BUTTON_RIGHT: tmp="mb_right"; break;
          case SDL_BUTTON_WHEELUP: tmp="mb_wup"; break;
          case SDL_BUTTON_WHEELDOWN: tmp="mb_wdown"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration Uint8 value "
               << (int)parent->button << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set153 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set153", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "mb_left")) {newVal=SDL_BUTTON_LEFT; goto done1536;}
        
          if (0 == strcmp(tmp, "mb_mid")) {newVal=SDL_BUTTON_MIDDLE; goto done1536;}
        
          if (0 == strcmp(tmp, "mb_right")) {newVal=SDL_BUTTON_RIGHT; goto done1536;}
        
          if (0 == strcmp(tmp, "mb_wup")) {newVal=SDL_BUTTON_WHEELUP; goto done1536;}
        
          if (0 == strcmp(tmp, "mb_wdown")) {newVal=SDL_BUTTON_WHEELDOWN; goto done1536;}
         {
        sprintf(staticError, "Unable to convert %s to Uint8", tmp);
        scriptError(staticError);
      } 
done1536:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->button = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get155 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get155", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        const char* tmp=NULL;
        switch (parent->state)
      {

          case SDL_PRESSED: tmp="PRESSED"; break;
          case SDL_RELEASED: tmp="RELEASED"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration Uint8 value "
               << (int)parent->state << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        objout = Tcl_NewStringObj(tmp, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set156 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set156", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint8 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "PRESSED")) {newVal=SDL_PRESSED; goto done1538;}
        
          if (0 == strcmp(tmp, "RELEASED")) {newVal=SDL_RELEASED; goto done1538;}
         {
        sprintf(staticError, "Unable to convert %s to Uint8", tmp);
        scriptError(staticError);
      } 
done1538:;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->state = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get158 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get158", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->x);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set159 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set159", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint16 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->x = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get161 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get161", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->y);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set162 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set162", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Uint16 newVal;
      SDL_MouseButtonEvent* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(SDL_MouseButtonEvent)
        &&  0==ex->type->superclasses.count(&typeid(SDL_MouseButtonEvent))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " SDL_MouseButtonEvent, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        SDL_MouseButtonEvent* tmp=(SDL_MouseButtonEvent*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (Uint16)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->y = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ get146", get146, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set147", set147, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get149", get149, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set150", set150, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get152", get152, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set153", set153, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get155", get155, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set156", set156, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get158", get158, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set159", set159, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get161", get161, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set162", set162, 0, NULL);
TypeExport* ste=new TypeExport(typeid(SDL_MouseButtonEvent)),
                           * ete=new TypeExport(typeid(TclSDL_MouseButtonEvent));
ste->isAObject=ete->isAObject=false;
ste->tclClassName=ete->tclClassName="SDL_MouseButtonEvent";
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(SDL_MouseButtonEvent));
typeExports[&typeid(SDL_MouseButtonEvent)]=ste;
typeExports[&typeid(TclSDL_MouseButtonEvent)]=ete;
}
};
void classdec145(bool safe, Tcl_Interp* interp) throw() {
  TclSDL_MouseButtonEvent::cppDecCode(safe,interp);
}

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline164 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
Uint16 arg0; bool arg0Init=false;
Uint16 arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (Uint16)tmp;};
arg0Init=true;
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (Uint16)tmp;};
arg1Init=true;
try {
      
     
     
     SDL_WarpMouse(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline166 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
Uint32 ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      ret =
     
     
     SDL_GetTicks();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


class TclShip : public Ship {
      public:
static int get457 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get457", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {if (!(parent->controller)) {
      objout=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(parent->controller));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (parent->controller)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(parent->controller))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(parent->controller)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      objout=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set458 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set458", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Controller* newVal;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Controller)
        &&  0==ex->type->superclasses.count(&typeid(Controller))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Controller, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Controller* tmp=(Controller*)ex->ptr;
        if (tmp) switch (tmp->ownStat) {
          case AObject::Cpp: 
          case AObject::Tcl:
            tmp->ownStatBak=tmp->ownStat;
            tmp->ownStat=AObject::Cpp;
            //So undo works properly
            tmp->ownerBak.interpreter=tmp->owner.interpreter;
            break;
          case AObject::Container:
            scriptError("Change of ownership of automatic C++ value");
            break;
        }
        newVal = tmp;
    } else newVal=NULL;
}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {if ((parent->controller)) switch ((parent->controller)->ownStat) {
            case AObject::Tcl:
              if (interp == (parent->controller)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (parent->controller)->ownStatBak=(parent->controller)->ownStat;
              (parent->controller)->ownerBak.interpreter = (parent->controller)->owner.interpreter;
              (parent->controller)->ownStat=AObject::Tcl;
              (parent->controller)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }}

      //Set
      parent->controller = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get460 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get460", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {if (!(parent->effects)) {
      objout=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(parent->effects));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (parent->effects)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(parent->effects))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(parent->effects)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      objout=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set461 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set461", TCL_VOLATILE);
        return TCL_ERROR;
      }
      EffectsHandler* newVal;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(EffectsHandler)
        &&  0==ex->type->superclasses.count(&typeid(EffectsHandler))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " EffectsHandler, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        EffectsHandler* tmp=(EffectsHandler*)ex->ptr;
        if (tmp) switch (tmp->ownStat) {
          case AObject::Cpp: 
          case AObject::Tcl:
            tmp->ownStatBak=tmp->ownStat;
            tmp->ownStat=AObject::Cpp;
            //So undo works properly
            tmp->ownerBak.interpreter=tmp->owner.interpreter;
            break;
          case AObject::Container:
            scriptError("Change of ownership of automatic C++ value");
            break;
        }
        newVal = tmp;
    } else newVal=NULL;
}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {if ((parent->effects)) switch ((parent->effects)->ownStat) {
            case AObject::Tcl:
              if (interp == (parent->effects)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (parent->effects)->ownStatBak=(parent->effects)->ownStat;
              (parent->effects)->ownerBak.interpreter = (parent->effects)->owner.interpreter;
              (parent->effects)->ownStat=AObject::Tcl;
              (parent->effects)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }}

      //Set
      parent->effects = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get463 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get463", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {if (!(parent->shipExistenceFailure)) {
      objout=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(parent->shipExistenceFailure));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(DynFun2<void,Ship*,bool>::fun_t)];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(parent->shipExistenceFailure)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      objout=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set464 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set464", TCL_VOLATILE);
        return TCL_ERROR;
      }
      DynFun2<void,Ship*,bool>::fun_t* newVal;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynFun2<void,Ship*,bool>::fun_t)
        &&  0==ex->type->superclasses.count(&typeid(DynFun2<void,Ship*,bool>::fun_t))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynFun2<void,Ship*,bool>::fun_t, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynFun2<void,Ship*,bool>::fun_t* tmp=(DynFun2<void,Ship*,bool>::fun_t*)ex->ptr;
        
        newVal = tmp;
    } else newVal=NULL;
}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->shipExistenceFailure = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }



#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline466 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
Ship* arg0; bool arg0Init=false;
Cell* arg1; bool arg1Init=false;
pair<float,float> ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{bool ok=true;
          #define val arg0
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 0";
            goto error;
          }
        }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Cell)
        &&  0==ex->type->superclasses.count(&typeid(Cell))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Cell, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Cell* tmp=(Cell*)ex->ptr;
        
        arg1 = tmp;
    } else arg1=NULL;
};
arg1Init=true;
{bool ok=true;
          #define val arg1
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 1";
            goto error;
          }
        }
try {
      ret =
     
     
     cellCoord(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{Tcl_Obj* l; {l = Tcl_NewDoubleObj((double)ret.first);};
    Tcl_Obj* r; {r = Tcl_NewDoubleObj((double)ret.second);};
    Tcl_Obj* objv[2]={l,r};
    retTcl=Tcl_NewListObj(2, objv);
}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline468 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
Ship* arg0; bool arg0Init=false;
Cell* arg1; bool arg1Init=false;
float arg2; bool arg2Init=false;
float arg3; bool arg3Init=false;
pair<float,float> ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{bool ok=true;
          #define val arg0
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 0";
            goto error;
          }
        }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Cell)
        &&  0==ex->type->superclasses.count(&typeid(Cell))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Cell, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Cell* tmp=(Cell*)ex->ptr;
        
        arg1 = tmp;
    } else arg1=NULL;
};
arg1Init=true;
{bool ok=true;
          #define val arg1
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 1";
            goto error;
          }
        }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg2 = (float)tmp;};
arg2Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg3 = (float)tmp;};
arg3Init=true;
try {
      ret =
     
     
     cellCoord(arg0, arg1, arg2, arg3);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{Tcl_Obj* l; {l = Tcl_NewDoubleObj((double)ret.first);};
    Tcl_Obj* r; {r = Tcl_NewDoubleObj((double)ret.second);};
    Tcl_Obj* objv[2]={l,r};
    retTcl=Tcl_NewListObj(2, objv);
}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static int get470 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get470", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->insignia);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set471 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set471", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->insignia = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get473 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get473", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->blame);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set474 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set474", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->blame = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get476 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get476", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->score);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set477 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set477", TCL_VOLATILE);
        return TCL_ERROR;
      }
      unsigned newVal;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (unsigned)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->score = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get479 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get479", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewDoubleObj((double)parent->damageMultiplier);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }
static int set480 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1+1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function set480", TCL_VOLATILE);
        return TCL_ERROR;
      }
      float newVal;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }

      //Extract value
      {double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            newVal = (float)tmp;}

      //Any necessary checks
      

      //Transfer ownership of old value if necessary
      {}

      //Set
      parent->damageMultiplier = newVal;

      //Return successfully
      Tcl_SetObjResult(interp, objv[1]);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get482 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get482", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewBooleanObj(parent->diedSpontaneously);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

static int get484 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get484", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Ship* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(parent->typeName.c_str(), -1, &dstr);
        objout = Tcl_NewUnicodeObj(tuc, -1);
      }
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

TclShip(GameField* arg2) : Ship(arg2) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Ship* constructordefault
    (const string& name, const string& magicCookie,  GameField* arg2) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Ship* ret;
      ret=new Ship(arg2);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Ship)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline486 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
Ship* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
try {
      ret =
     
     
     constructordefault(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError



#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline488 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     refreshUpdates();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline490 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      ret =
     parent->
     
     update(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline492 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     draw();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError



#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline494 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getVRotation();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline496 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getMass();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline498 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     glSetColour();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline500 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      
     parent->
     
     glSetColour(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline502 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
try {
      
     parent->
     
     glSetColour(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline504 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      
     parent->
     
     setThrust(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline506 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getThrust();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline508 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getTrueThrust();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline510 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
bool arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int gen1741;
            int err = Tcl_GetBooleanFromObj(interp, objv[1], (int*)&gen1741);
            arg0=gen1741;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg0Init=true;
try {
      
     parent->
     
     setThrustOn(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline512 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     isThrustOn();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline514 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
bool arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int gen1744;
            int err = Tcl_GetBooleanFromObj(interp, objv[1], (int*)&gen1744);
            arg0=gen1744;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg0Init=true;
try {
      
     parent->
     
     setBrakeOn(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline516 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     isBrakeOn();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline518 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
bool arg0; bool arg0Init=false;
bool arg1; bool arg1Init=false;
float arg2; bool arg2Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int gen1747;
            int err = Tcl_GetBooleanFromObj(interp, objv[1], (int*)&gen1747);
            arg0=gen1747;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg0Init=true;
{int gen1748;
            int err = Tcl_GetBooleanFromObj(interp, objv[2], (int*)&gen1748);
            arg1=gen1748;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg1Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg2 = (float)tmp;};
arg2Init=true;
try {
      
     parent->
     
     configureEngines(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline520 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
bool arg0; bool arg0Init=false;
bool arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int gen1750;
            int err = Tcl_GetBooleanFromObj(interp, objv[1], (int*)&gen1750);
            arg0=gen1750;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg0Init=true;
{int gen1751;
            int err = Tcl_GetBooleanFromObj(interp, objv[2], (int*)&gen1751);
            arg1=gen1751;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg1Init=true;
try {
      
     parent->
     
     configureEngines(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline522 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getAcceleration();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline524 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getRotationRate();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline526 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getRotationAccel();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline528 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getRadius();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline530 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getPowerUsagePercent();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline532 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
unsigned ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getPowerSupply();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline534 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
unsigned ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getPowerDrain();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline536 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getCurrentCapacitance();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline538 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
unsigned ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getMaximumCapacitance();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline540 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getCapacitancePercent();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline542 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
float arg2; bool arg2Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg2 = (float)tmp;};
arg2Init=true;
try {
      
     parent->
     
     setColour(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline544 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     destroyGraphicsInfo();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline546 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getColourR();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline548 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getColourG();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline550 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getColourB();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline552 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      ret =
     parent->
     
     drawPower(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline554 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getReinforcement();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline556 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      
     parent->
     
     setReinforcement(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline558 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     enableSoundEffects();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError



#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline560 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     hasPower();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline562 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     spontaneouslyDie();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline564 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getCoolingMult();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline566 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
Cell* arg0; bool arg0Init=false;
pair<float,float> ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Cell)
        &&  0==ex->type->superclasses.count(&typeid(Cell))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Cell, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Cell* tmp=(Cell*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{bool ok=true;
          #define val arg0
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 0";
            goto error;
          }
        }
try {
      ret =
     parent->
     
     getCellVelocity(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{Tcl_Obj* l; {l = Tcl_NewDoubleObj((double)ret.first);};
    Tcl_Obj* r; {r = Tcl_NewDoubleObj((double)ret.second);};
    Tcl_Obj* objv[2]={l,r};
    retTcl=Tcl_NewListObj(2, objv);
}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError



#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline568 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      
     parent->
     
     spin(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline570 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     startTest();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline572 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     endTest();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError



#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline574 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 6) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
float arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
float arg2; bool arg2Init=false;
float arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg2 = (float)tmp;};
arg2Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg3 = (float)tmp;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
try {
      
     parent->
     
     applyCollision(arg0, arg1, arg2, arg3, arg4);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline576 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
unsigned ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     cellCount();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline578 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
radar_t* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getRadar();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline580 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
radar_t* arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(radar_t)
        &&  0==ex->type->superclasses.count(&typeid(radar_t))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " radar_t, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        radar_t* tmp=(radar_t*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      
     parent->
     
     setRadar(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline582 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Ship* parent=NULL;
const char* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getDeathAttributions();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(ret? ret : "", -1, &dstr);
        retTcl = Tcl_NewUnicodeObj(tuc, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {if (!safe) {
Tcl_CreateObjCommand(interp, "c++ get457", get457, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set458", set458, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get460", get460, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set461", set461, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get463", get463, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set464", set464, 0, NULL);
}
Tcl_CreateObjCommand(interp, "c++ trampoline466", trampoline466, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline468", trampoline468, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get470", get470, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set471", set471, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get473", get473, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set474", set474, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get476", get476, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set477", set477, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get479", get479, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ set480", set480, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get482", get482, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ get484", get484, 0, NULL);
if (!safe) {
Tcl_CreateObjCommand(interp, "c++ trampoline486", trampoline486, 0, NULL);
}
Tcl_CreateObjCommand(interp, "c++ trampoline488", trampoline488, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline490", trampoline490, 0, NULL);
if (!safe) {
Tcl_CreateObjCommand(interp, "c++ trampoline492", trampoline492, 0, NULL);
}
Tcl_CreateObjCommand(interp, "c++ trampoline494", trampoline494, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline496", trampoline496, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline498", trampoline498, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline500", trampoline500, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline502", trampoline502, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline504", trampoline504, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline506", trampoline506, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline508", trampoline508, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline510", trampoline510, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline512", trampoline512, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline514", trampoline514, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline516", trampoline516, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline518", trampoline518, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline520", trampoline520, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline522", trampoline522, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline524", trampoline524, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline526", trampoline526, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline528", trampoline528, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline530", trampoline530, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline532", trampoline532, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline534", trampoline534, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline536", trampoline536, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline538", trampoline538, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline540", trampoline540, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline542", trampoline542, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline544", trampoline544, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline546", trampoline546, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline548", trampoline548, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline550", trampoline550, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline552", trampoline552, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline554", trampoline554, 0, NULL);
if (!safe) {
Tcl_CreateObjCommand(interp, "c++ trampoline556", trampoline556, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline558", trampoline558, 0, NULL);
}
Tcl_CreateObjCommand(interp, "c++ trampoline560", trampoline560, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline562", trampoline562, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline564", trampoline564, 0, NULL);
if (!safe) {
Tcl_CreateObjCommand(interp, "c++ trampoline566", trampoline566, 0, NULL);
}
Tcl_CreateObjCommand(interp, "c++ trampoline568", trampoline568, 0, NULL);
if (!safe) {
Tcl_CreateObjCommand(interp, "c++ trampoline570", trampoline570, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline572", trampoline572, 0, NULL);
}
Tcl_CreateObjCommand(interp, "c++ trampoline574", trampoline574, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline576", trampoline576, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline578", trampoline578, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline580", trampoline580, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline582", trampoline582, 0, NULL);
TypeExport* ste=new TypeExport(typeid(Ship)),
                           * ete=new TypeExport(typeid(TclShip));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="Ship";
ste->superclasses.insert(&typeid(GameObject));
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(Ship));
typeExports[&typeid(Ship)]=ste;
typeExports[&typeid(TclShip)]=ete;
}
};
void classdec456(bool safe, Tcl_Interp* interp) throw() {
  TclShip::cppDecCode(safe,interp);
}
class TclDynamicCamera : public DynamicCamera {
      public:
TclDynamicCamera(GameObject* arg2, GameField* arg3) : DynamicCamera(arg2, arg3) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static DynamicCamera* constructordefault
    (const string& name, const string& magicCookie,  GameObject* arg2, GameField* arg3) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      DynamicCamera* ret;
      ret=new DynamicCamera(arg2, arg3);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(DynamicCamera)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline725 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameObject* arg2; bool arg2Init=false;
GameField* arg3; bool arg3Init=false;
DynamicCamera* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameObject)
        &&  0==ex->type->superclasses.count(&typeid(GameObject))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameObject, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameObject* tmp=(GameObject*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{
      string name(Tcl_GetStringFromObj(objv[3], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg3 = tmp;
    } else arg3=NULL;
};
arg3Init=true;
try {
      ret =
     
     
     constructordefault(arg0, arg1, arg2, arg3);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline727 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynamicCamera* parent=NULL;
float arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynamicCamera)
        &&  0==ex->type->superclasses.count(&typeid(DynamicCamera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynamicCamera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynamicCamera* tmp=(DynamicCamera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      
     parent->
     
     update(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline729 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynamicCamera* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynamicCamera)
        &&  0==ex->type->superclasses.count(&typeid(DynamicCamera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynamicCamera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynamicCamera* tmp=(DynamicCamera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     doSetup();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline731 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynamicCamera* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynamicCamera)
        &&  0==ex->type->superclasses.count(&typeid(DynamicCamera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynamicCamera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynamicCamera* tmp=(DynamicCamera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     reset();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline733 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynamicCamera* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynamicCamera)
        &&  0==ex->type->superclasses.count(&typeid(DynamicCamera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynamicCamera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynamicCamera* tmp=(DynamicCamera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getZoom();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline735 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynamicCamera* parent=NULL;
float arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynamicCamera)
        &&  0==ex->type->superclasses.count(&typeid(DynamicCamera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynamicCamera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynamicCamera* tmp=(DynamicCamera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      
     parent->
     
     setZoom(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline737 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynamicCamera* parent=NULL;
DynamicCamera::RotateMode ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynamicCamera)
        &&  0==ex->type->superclasses.count(&typeid(DynamicCamera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynamicCamera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynamicCamera* tmp=(DynamicCamera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getRotateMode();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        const char* tmp=NULL;
        switch (ret)
      {

          case DynamicCamera::None: tmp="DCRMNone"; break;
          case DynamicCamera::Direction: tmp="DCRMDirection"; break;
          case DynamicCamera::Velocity: tmp="DCRMVelocity"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration DynamicCamera::RotateMode value "
               << (int)ret << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        retTcl = Tcl_NewStringObj(tmp, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline739 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynamicCamera* parent=NULL;
DynamicCamera::RotateMode arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynamicCamera)
        &&  0==ex->type->superclasses.count(&typeid(DynamicCamera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynamicCamera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynamicCamera* tmp=(DynamicCamera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "DCRMNone")) {arg0=DynamicCamera::None; goto done1881;}
        
          if (0 == strcmp(tmp, "DCRMDirection")) {arg0=DynamicCamera::Direction; goto done1881;}
        
          if (0 == strcmp(tmp, "DCRMVelocity")) {arg0=DynamicCamera::Velocity; goto done1881;}
         {
        sprintf(staticError, "Unable to convert %s to DynamicCamera::RotateMode", tmp);
        scriptError(staticError);
      } 
done1881:;};
arg0Init=true;
try {
      
     parent->
     
     setRotateMode(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline741 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynamicCamera* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynamicCamera)
        &&  0==ex->type->superclasses.count(&typeid(DynamicCamera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynamicCamera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynamicCamera* tmp=(DynamicCamera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getLookAhead();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline743 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynamicCamera* parent=NULL;
float arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynamicCamera)
        &&  0==ex->type->superclasses.count(&typeid(DynamicCamera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynamicCamera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynamicCamera* tmp=(DynamicCamera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      
     parent->
     
     setLookAhead(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline745 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynamicCamera* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynamicCamera)
        &&  0==ex->type->superclasses.count(&typeid(DynamicCamera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynamicCamera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynamicCamera* tmp=(DynamicCamera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getVisualRotation();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline747 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynamicCamera* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynamicCamera)
        &&  0==ex->type->superclasses.count(&typeid(DynamicCamera))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynamicCamera, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynamicCamera* tmp=(DynamicCamera*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     hc_conf_bind();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline725", trampoline725, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline727", trampoline727, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline729", trampoline729, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline731", trampoline731, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline733", trampoline733, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline735", trampoline735, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline737", trampoline737, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline739", trampoline739, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline741", trampoline741, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline743", trampoline743, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline745", trampoline745, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline747", trampoline747, 0, NULL);
TypeExport* ste=new TypeExport(typeid(DynamicCamera)),
                           * ete=new TypeExport(typeid(TclDynamicCamera));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="DynamicCamera";
ste->superclasses.insert(&typeid(Camera));
ste->superclasses.insert(&typeid(EffectsHandler));
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(DynamicCamera));
typeExports[&typeid(DynamicCamera)]=ste;
typeExports[&typeid(TclDynamicCamera)]=ete;
}
};
void classdec724(bool safe, Tcl_Interp* interp) throw() {
  TclDynamicCamera::cppDecCode(safe,interp);
}

 int get1119 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1119", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {objout = Tcl_NewDoubleObj((double)STD_CELL_SZ);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

class TclConfReg : public ConfReg {
      public:

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1359 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      
     parent->
     
     open(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1361 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      
     parent->
     
     create(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1363 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      
     parent->
     
     close(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1365 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     closeAll();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1367 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      
     parent->
     
     modify(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1369 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      
     parent->
     
     unmodify(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1371 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      
     parent->
     
     sync(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1373 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     syncAll();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1375 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      
     parent->
     
     revert(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1377 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     revertAll();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1379 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      
     parent->
     
     addToWhitelist(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1381 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      
     parent->
     
     removeFromWhitelist(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1383 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     clearWhitelist();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1385 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
bool arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int gen2163;
            int err = Tcl_GetBooleanFromObj(interp, objv[1], (int*)&gen2163);
            arg0=gen2163;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg0Init=true;
try {
      
     parent->
     
     setWhitelistOnly(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1387 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      
     parent->
     
     renameFile(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError



#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1389 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     exists(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1391 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     getBool(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1393 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
int ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     getInt(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1395 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     getFloat(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1397 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     getStr(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(ret.c_str(), -1, &dstr);
        retTcl = Tcl_NewUnicodeObj(tuc, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1399 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
bool arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{int gen2171;
            int err = Tcl_GetBooleanFromObj(interp, objv[2], (int*)&gen2171);
            arg1=gen2171;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg1Init=true;
try {
      
     parent->
     
     setBool(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1401 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
int arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (int)tmp;};
arg1Init=true;
try {
      
     parent->
     
     setInt(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1403 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
try {
      
     parent->
     
     setFloat(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1405 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      
     parent->
     
     setString(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1407 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
Setting::Type arg2; bool arg2Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
        const char* tmp = Tcl_GetStringFromObj(objv[3], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "STInt")) {arg2=Setting::TypeInt; goto done2176;}
        
          if (0 == strcmp(tmp, "STInt64")) {arg2=Setting::TypeInt64; goto done2176;}
        
          if (0 == strcmp(tmp, "STFloat")) {arg2=Setting::TypeFloat; goto done2176;}
        
          if (0 == strcmp(tmp, "STBool")) {arg2=Setting::TypeBoolean; goto done2176;}
        
          if (0 == strcmp(tmp, "STString")) {arg2=Setting::TypeString; goto done2176;}
        
          if (0 == strcmp(tmp, "STArray")) {arg2=Setting::TypeArray; goto done2176;}
        
          if (0 == strcmp(tmp, "STList")) {arg2=Setting::TypeList; goto done2176;}
        
          if (0 == strcmp(tmp, "STGroup")) {arg2=Setting::TypeGroup; goto done2176;}
         {
        sprintf(staticError, "Unable to convert %s to Setting::Type", tmp);
        scriptError(staticError);
      } 
done2176:;};
arg2Init=true;
try {
      
     parent->
     
     add(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1409 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
bool arg2; bool arg2Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{int gen2178;
            int err = Tcl_GetBooleanFromObj(interp, objv[3], (int*)&gen2178);
            arg2=gen2178;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg2Init=true;
try {
      
     parent->
     
     addBool(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1411 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
int arg2; bool arg2Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg2 = (int)tmp;};
arg2Init=true;
try {
      
     parent->
     
     addInt(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1413 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
float arg2; bool arg2Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg2 = (float)tmp;};
arg2Init=true;
try {
      
     parent->
     
     addFloat(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1415 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
string arg2; bool arg2Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[3], &length);
      arg2 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg2Init=true;
try {
      
     parent->
     
     addString(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1417 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      
     parent->
     
     remove(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1419 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
Setting::Type arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
        const char* tmp = Tcl_GetStringFromObj(objv[2], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "STInt")) {arg1=Setting::TypeInt; goto done2184;}
        
          if (0 == strcmp(tmp, "STInt64")) {arg1=Setting::TypeInt64; goto done2184;}
        
          if (0 == strcmp(tmp, "STFloat")) {arg1=Setting::TypeFloat; goto done2184;}
        
          if (0 == strcmp(tmp, "STBool")) {arg1=Setting::TypeBoolean; goto done2184;}
        
          if (0 == strcmp(tmp, "STString")) {arg1=Setting::TypeString; goto done2184;}
        
          if (0 == strcmp(tmp, "STArray")) {arg1=Setting::TypeArray; goto done2184;}
        
          if (0 == strcmp(tmp, "STList")) {arg1=Setting::TypeList; goto done2184;}
        
          if (0 == strcmp(tmp, "STGroup")) {arg1=Setting::TypeGroup; goto done2184;}
         {
        sprintf(staticError, "Unable to convert %s to Setting::Type", tmp);
        scriptError(staticError);
      } 
done2184:;};
arg1Init=true;
try {
      
     parent->
     
     pushBack(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1421 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
bool arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{int gen2186;
            int err = Tcl_GetBooleanFromObj(interp, objv[2], (int*)&gen2186);
            arg1=gen2186;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg1Init=true;
try {
      
     parent->
     
     pushBackBool(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1423 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
int arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (int)tmp;};
arg1Init=true;
try {
      
     parent->
     
     pushBackInt(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1425 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
try {
      
     parent->
     
     pushBackFloat(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1427 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      
     parent->
     
     pushBackString(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1429 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
unsigned arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (unsigned)tmp;};
arg1Init=true;
try {
      
     parent->
     
     remix(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1431 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     getName(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(ret.c_str(), -1, &dstr);
        retTcl = Tcl_NewUnicodeObj(tuc, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1433 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      
     parent->
     
     copy(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1435 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
Setting::Type ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     getType(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        const char* tmp=NULL;
        switch (ret)
      {

          case Setting::TypeInt: tmp="STInt"; break;
          case Setting::TypeInt64: tmp="STInt64"; break;
          case Setting::TypeFloat: tmp="STFloat"; break;
          case Setting::TypeBoolean: tmp="STBool"; break;
          case Setting::TypeString: tmp="STString"; break;
          case Setting::TypeArray: tmp="STArray"; break;
          case Setting::TypeList: tmp="STList"; break;
          case Setting::TypeGroup: tmp="STGroup"; break;
          default:
          cerr << "FATAL: Unable to convert enumeration Setting::Type value "
               << (int)ret << " (invalid!)!" << endl;
          ::exit(EXIT_PROGRAM_BUG);
        
}

        retTcl = Tcl_NewStringObj(tmp, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1437 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
int ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     getLength(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1439 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     isGroup(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1441 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     isArray(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1443 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     isList(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1445 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     isAggregate(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1447 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     isScalar(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1449 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     isNumber(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1451 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       ConfReg* parent=NULL;
string arg0; bool arg0Init=false;
int ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(ConfReg)
        &&  0==ex->type->superclasses.count(&typeid(ConfReg))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " ConfReg, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        ConfReg* tmp=(ConfReg*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
try {
      ret =
     parent->
     
     getSourceLine(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {if (!safe) {
Tcl_CreateObjCommand(interp, "c++ trampoline1359", trampoline1359, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1361", trampoline1361, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1363", trampoline1363, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1365", trampoline1365, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1367", trampoline1367, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1369", trampoline1369, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1371", trampoline1371, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1373", trampoline1373, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1375", trampoline1375, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1377", trampoline1377, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1379", trampoline1379, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1381", trampoline1381, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1383", trampoline1383, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1385", trampoline1385, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1387", trampoline1387, 0, NULL);
}
Tcl_CreateObjCommand(interp, "c++ trampoline1389", trampoline1389, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1391", trampoline1391, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1393", trampoline1393, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1395", trampoline1395, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1397", trampoline1397, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1399", trampoline1399, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1401", trampoline1401, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1403", trampoline1403, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1405", trampoline1405, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1407", trampoline1407, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1409", trampoline1409, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1411", trampoline1411, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1413", trampoline1413, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1415", trampoline1415, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1417", trampoline1417, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1419", trampoline1419, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1421", trampoline1421, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1423", trampoline1423, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1425", trampoline1425, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1427", trampoline1427, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1429", trampoline1429, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1431", trampoline1431, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1433", trampoline1433, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1435", trampoline1435, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1437", trampoline1437, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1439", trampoline1439, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1441", trampoline1441, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1443", trampoline1443, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1445", trampoline1445, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1447", trampoline1447, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1449", trampoline1449, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1451", trampoline1451, 0, NULL);
TypeExport* ste=new TypeExport(typeid(ConfReg)),
                           * ete=new TypeExport(typeid(TclConfReg));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="ConfReg";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(ConfReg));
typeExports[&typeid(ConfReg)]=ste;
typeExports[&typeid(TclConfReg)]=ete;
}
};
void classdec1358(bool safe, Tcl_Interp* interp) throw() {
  TclConfReg::cppDecCode(safe,interp);
}
 int get1453 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 0) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get1453", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      
      {if (!(&conf)) {
      objout=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(&conf));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (&conf)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(&conf))];
        ex->interp=interp;
        (&conf)->ownStat = AObject::Container;

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(&conf)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      objout=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1455 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      
     
     
     confcpy(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

