
  /**
   * @file
   * @author C++-Tcl Bridge Code Generator
   * @brief Autogenerated bindings; <b>not intended for human consumption</b>
   *
   * AUTOGENERATED BY generate.tcl. DO NOT EDIT DIRECTLY.
   * @see src/tcl_iface/readme.txt
   */

  #include <map>
  #include <set>
  #include <vector>
  #include <string>
  #include <cstring>
  #include <cstdio>
  #include <cstdlib>
  #include <iostream>

  #include <GL/gl.h>
  #include <SDL.h>
  #include <tcl.h>
  #include <itcl.h>
  #include <libconfig.h++>

  #include "src/tcl_iface/bridge.hxx"
  #include "src/tcl_iface/implementation.hxx"
  #include "src/tcl_iface/dynfun.hxx"
  #include "src/exit_conditions.hxx"
  #include "src/globals.hxx"

  #pragma GCC diagnostic ignored "-Wunused-label"
  #pragma GCC diagnostic ignored "-Waddress"
  using namespace std;
  using namespace tcl_glue_implementation;
  using namespace libconfig;

  //Commands get their zeroth argument as their own name;
  //code generation is simpler if we drop this
  #define SHIFT ++objv, --objc

#include "src/sim/blast.hxx"
#include "src/weapon/missile.hxx"
#include "src/ship/ship.hxx"
#include "src/sim/game_field.hxx"
#include "src/camera/spectator.hxx"
#include "src/ship/ship.hxx"
#include "src/sim/game_field.hxx"
#include "src/net/network_geraet.hxx"
#include "src/net/network_connection.hxx"
#include "src/control/joystick.hxx"
class TclBlast : public Blast {
      public:
static int get360 (ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
      SHIFT;
      #define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
      if (objc != 1) {
        Tcl_SetResult(interp, "Invalid usage of internal glue function get360", TCL_VOLATILE);
        return TCL_ERROR;
      }
      Tcl_Obj* objout;
      Blast* parent; {
       
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Blast)
        &&  0==ex->type->superclasses.count(&typeid(Blast))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Blast, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Blast* tmp=(Blast*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;

      } if (!parent) { scriptError("NULL this passed into C++"); }
      {objout = Tcl_NewIntObj((int)parent->blame);}
      Tcl_SetObjResult(interp, objout);
      return TCL_OK;

      error:
      Tcl_SetResult(interp, scriptingErrorMessage, TCL_VOLATILE);
      return TCL_ERROR;
      #undef scriptError
    }

TclBlast(GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7) : Blast(arg2, arg3, arg4, arg5, arg6, arg7) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Blast* constructordefault
    (const string& name, const string& magicCookie,  GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Blast* ret;
      ret=new Blast(arg2, arg3, arg4, arg5, arg6, arg7);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Blast)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline362 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 8) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
unsigned arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
float arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
Blast* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{bool ok=true;
          #define val arg2
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 2";
            goto error;
          }
        }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg3 = (unsigned)tmp;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg5 = (float)tmp;};
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
try {
      ret =
     
     
     constructordefault(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

TclBlast(GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7, bool arg8) : Blast(arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Blast* constructorwithDirect
    (const string& name, const string& magicCookie,  GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7, bool arg8) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Blast* ret;
      ret=new Blast(arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Blast)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline364 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 9) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
unsigned arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
float arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
bool arg8; bool arg8Init=false;
Blast* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{bool ok=true;
          #define val arg2
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 2";
            goto error;
          }
        }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg3 = (unsigned)tmp;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg5 = (float)tmp;};
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
{int gen1704;
            int err = Tcl_GetBooleanFromObj(interp, objv[8], (int*)&gen1704);
            arg8=gen1704;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg8Init=true;
try {
      ret =
     
     
     constructorwithDirect(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
if (arg8Init) {arg8Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

TclBlast(GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7, bool arg8, float arg9) : Blast(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Blast* constructorwithSize
    (const string& name, const string& magicCookie,  GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7, bool arg8, float arg9) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Blast* ret;
      ret=new Blast(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Blast)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline366 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 10) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
unsigned arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
float arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
bool arg8; bool arg8Init=false;
float arg9; bool arg9Init=false;
Blast* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{bool ok=true;
          #define val arg2
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 2";
            goto error;
          }
        }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg3 = (unsigned)tmp;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg5 = (float)tmp;};
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
{int gen1706;
            int err = Tcl_GetBooleanFromObj(interp, objv[8], (int*)&gen1706);
            arg8=gen1706;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg8Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[9], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg9 = (float)tmp;};
arg9Init=true;
try {
      ret =
     
     
     constructorwithSize(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
if (arg8Init) {arg8Init=false; }
if (arg9Init) {arg9Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

TclBlast(GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7, bool arg8, float arg9, bool arg10) : Blast(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Blast* constructorwithADC
    (const string& name, const string& magicCookie,  GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7, bool arg8, float arg9, bool arg10) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Blast* ret;
      ret=new Blast(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Blast)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline368 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 11) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
unsigned arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
float arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
bool arg8; bool arg8Init=false;
float arg9; bool arg9Init=false;
bool arg10; bool arg10Init=false;
Blast* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{bool ok=true;
          #define val arg2
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 2";
            goto error;
          }
        }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg3 = (unsigned)tmp;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg5 = (float)tmp;};
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
{int gen1708;
            int err = Tcl_GetBooleanFromObj(interp, objv[8], (int*)&gen1708);
            arg8=gen1708;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg8Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[9], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg9 = (float)tmp;};
arg9Init=true;
{int gen1709;
            int err = Tcl_GetBooleanFromObj(interp, objv[10], (int*)&gen1709);
            arg10=gen1709;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg10Init=true;
try {
      ret =
     
     
     constructorwithADC(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
if (arg8Init) {arg8Init=false; }
if (arg9Init) {arg9Init=false; }
if (arg10Init) {arg10Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

TclBlast(GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7, bool arg8, float arg9, bool arg10, bool arg11) : Blast(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Blast* constructorwithDecor
    (const string& name, const string& magicCookie,  GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7, bool arg8, float arg9, bool arg10, bool arg11) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Blast* ret;
      ret=new Blast(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Blast)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline370 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 12) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
unsigned arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
float arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
bool arg8; bool arg8Init=false;
float arg9; bool arg9Init=false;
bool arg10; bool arg10Init=false;
bool arg11; bool arg11Init=false;
Blast* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{bool ok=true;
          #define val arg2
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 2";
            goto error;
          }
        }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg3 = (unsigned)tmp;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg5 = (float)tmp;};
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
{int gen1711;
            int err = Tcl_GetBooleanFromObj(interp, objv[8], (int*)&gen1711);
            arg8=gen1711;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg8Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[9], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg9 = (float)tmp;};
arg9Init=true;
{int gen1712;
            int err = Tcl_GetBooleanFromObj(interp, objv[10], (int*)&gen1712);
            arg10=gen1712;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg10Init=true;
{int gen1713;
            int err = Tcl_GetBooleanFromObj(interp, objv[11], (int*)&gen1713);
            arg11=gen1713;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg11Init=true;
try {
      ret =
     
     
     constructorwithDecor(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
if (arg8Init) {arg8Init=false; }
if (arg9Init) {arg9Init=false; }
if (arg10Init) {arg10Init=false; }
if (arg11Init) {arg11Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

TclBlast(GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7, bool arg8, float arg9, bool arg10, bool arg11, bool arg12) : Blast(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Blast* constructorwithDamage
    (const string& name, const string& magicCookie,  GameField* arg2, unsigned arg3, float arg4, float arg5, float arg6, float arg7, bool arg8, float arg9, bool arg10, bool arg11, bool arg12) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Blast* ret;
      ret=new Blast(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Blast)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline372 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 13) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
unsigned arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
float arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
bool arg8; bool arg8Init=false;
float arg9; bool arg9Init=false;
bool arg10; bool arg10Init=false;
bool arg11; bool arg11Init=false;
bool arg12; bool arg12Init=false;
Blast* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{bool ok=true;
          #define val arg2
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 2";
            goto error;
          }
        }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg3 = (unsigned)tmp;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg5 = (float)tmp;};
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
{int gen1715;
            int err = Tcl_GetBooleanFromObj(interp, objv[8], (int*)&gen1715);
            arg8=gen1715;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg8Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[9], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg9 = (float)tmp;};
arg9Init=true;
{int gen1716;
            int err = Tcl_GetBooleanFromObj(interp, objv[10], (int*)&gen1716);
            arg10=gen1716;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg10Init=true;
{int gen1717;
            int err = Tcl_GetBooleanFromObj(interp, objv[11], (int*)&gen1717);
            arg11=gen1717;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg11Init=true;
{int gen1718;
            int err = Tcl_GetBooleanFromObj(interp, objv[12], (int*)&gen1718);
            arg12=gen1718;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg12Init=true;
try {
      ret =
     
     
     constructorwithDamage(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
if (arg8Init) {arg8Init=false; }
if (arg9Init) {arg9Init=false; }
if (arg10Init) {arg10Init=false; }
if (arg11Init) {arg11Init=false; }
if (arg12Init) {arg12Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

TclBlast(Blast* arg2, bool arg3) : Blast(arg2, arg3) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Blast* constructornonDamageCopy
    (const string& name, const string& magicCookie,  Blast* arg2, bool arg3) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Blast* ret;
      ret=new Blast(arg2, arg3);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Blast)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline374 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
Blast* arg2; bool arg2Init=false;
bool arg3; bool arg3Init=false;
Blast* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Blast)
        &&  0==ex->type->superclasses.count(&typeid(Blast))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Blast, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Blast* tmp=(Blast*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{bool ok=true;
          #define val arg2
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 2";
            goto error;
          }
        }
{int gen1720;
            int err = Tcl_GetBooleanFromObj(interp, objv[3], (int*)&gen1720);
            arg3=gen1720;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg3Init=true;
try {
      ret =
     
     
     constructornonDamageCopy(arg0, arg1, arg2, arg3);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline376 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Blast* parent=NULL;
float arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Blast)
        &&  0==ex->type->superclasses.count(&typeid(Blast))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Blast, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Blast* tmp=(Blast*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      ret =
     parent->
     
     update(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline378 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Blast* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Blast)
        &&  0==ex->type->superclasses.count(&typeid(Blast))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Blast, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Blast* tmp=(Blast*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     draw();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline380 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Blast* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Blast)
        &&  0==ex->type->superclasses.count(&typeid(Blast))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Blast, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Blast* tmp=(Blast*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getFalloff();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline382 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Blast* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Blast)
        &&  0==ex->type->superclasses.count(&typeid(Blast))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Blast, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Blast* tmp=(Blast*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getStrength();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline384 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Blast* parent=NULL;
float arg0; bool arg0Init=false;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Blast)
        &&  0==ex->type->superclasses.count(&typeid(Blast))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Blast, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Blast* tmp=(Blast*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      ret =
     parent->
     
     getStrength(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline386 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Blast* parent=NULL;
GameObject* arg0; bool arg0Init=false;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Blast)
        &&  0==ex->type->superclasses.count(&typeid(Blast))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Blast, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Blast* tmp=(Blast*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameObject)
        &&  0==ex->type->superclasses.count(&typeid(GameObject))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameObject, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameObject* tmp=(GameObject*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{bool ok=true;
          #define val arg0
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 0";
            goto error;
          }
        }
try {
      ret =
     parent->
     
     getStrength(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline388 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Blast* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Blast)
        &&  0==ex->type->superclasses.count(&typeid(Blast))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Blast, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Blast* tmp=(Blast*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getSize();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline390 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Blast* parent=NULL;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Blast)
        &&  0==ex->type->superclasses.count(&typeid(Blast))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Blast, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Blast* tmp=(Blast*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     isDirect();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline392 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Blast* parent=NULL;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Blast)
        &&  0==ex->type->superclasses.count(&typeid(Blast))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Blast, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Blast* tmp=(Blast*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     causesDamage();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ get360", get360, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline362", trampoline362, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline364", trampoline364, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline366", trampoline366, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline368", trampoline368, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline370", trampoline370, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline372", trampoline372, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline374", trampoline374, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline376", trampoline376, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline378", trampoline378, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline380", trampoline380, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline382", trampoline382, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline384", trampoline384, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline386", trampoline386, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline388", trampoline388, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline390", trampoline390, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline392", trampoline392, 0, NULL);
TypeExport* ste=new TypeExport(typeid(Blast)),
                           * ete=new TypeExport(typeid(TclBlast));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="Blast";
ste->superclasses.insert(&typeid(GameObject));
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(Blast));
typeExports[&typeid(Blast)]=ste;
typeExports[&typeid(TclBlast)]=ete;
}
};
void classdec359(bool safe, Tcl_Interp* interp) throw() {
  TclBlast::cppDecCode(safe,interp);
}
class TclMissile : public Missile {
      public:
TclMissile(GameField* arg2, int arg3, float arg4, float arg5, float arg6, float arg7, Ship* arg8, GameObject* arg9) : Missile(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Missile* constructordefault
    (const string& name, const string& magicCookie,  GameField* arg2, int arg3, float arg4, float arg5, float arg6, float arg7, Ship* arg8, GameObject* arg9) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Missile* ret;
      ret=new Missile(arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Missile)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline692 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 10) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
int arg3; bool arg3Init=false;
float arg4; bool arg4Init=false;
float arg5; bool arg5Init=false;
float arg6; bool arg6Init=false;
float arg7; bool arg7Init=false;
Ship* arg8; bool arg8Init=false;
GameObject* arg9; bool arg9Init=false;
Missile* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{bool ok=true;
          #define val arg2
          ok=val;
          #undef val
          if (!ok) {
            scriptingErrorMessage = "Unacceptable value to argument 2";
            goto error;
          }
        }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg3 = (int)tmp;};
arg3Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg4 = (float)tmp;};
arg4Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[5], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg5 = (float)tmp;};
arg5Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[6], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg6 = (float)tmp;};
arg6Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[7], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg7 = (float)tmp;};
arg7Init=true;
{
      string name(Tcl_GetStringFromObj(objv[8], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        arg8 = tmp;
    } else arg8=NULL;
};
arg8Init=true;
{
      string name(Tcl_GetStringFromObj(objv[9], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameObject)
        &&  0==ex->type->superclasses.count(&typeid(GameObject))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameObject, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameObject* tmp=(GameObject*)ex->ptr;
        
        arg9 = tmp;
    } else arg9=NULL;
};
arg9Init=true;
try {
      ret =
     
     
     constructordefault(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
if (arg4Init) {arg4Init=false; }
if (arg5Init) {arg5Init=false; }
if (arg6Init) {arg6Init=false; }
if (arg7Init) {arg7Init=false; }
if (arg8Init) {arg8Init=false; }
if (arg9Init) {arg9Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline692", trampoline692, 0, NULL);
TypeExport* ste=new TypeExport(typeid(Missile)),
                           * ete=new TypeExport(typeid(TclMissile));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="Missile";
ste->superclasses.insert(&typeid(GameObject));
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(Missile));
typeExports[&typeid(Missile)]=ste;
typeExports[&typeid(TclMissile)]=ete;
}
};
void classdec691(bool safe, Tcl_Interp* interp) throw() {
  TclMissile::cppDecCode(safe,interp);
}
class TclSpectator : public Spectator {
      public:
TclSpectator(Ship* arg2) : Spectator(arg2) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Spectator* constructordefault
    (const string& name, const string& magicCookie,  Ship* arg2) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Spectator* ret;
      ret=new Spectator(arg2);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Spectator)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline874 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
Ship* arg2; bool arg2Init=false;
Spectator* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
try {
      ret =
     
     
     constructordefault(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

TclSpectator(Ship* arg2, bool arg3) : Spectator(arg2, arg3) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Spectator* constructorexplicit
    (const string& name, const string& magicCookie,  Ship* arg2, bool arg3) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Spectator* ret;
      ret=new Spectator(arg2, arg3);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Spectator)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline876 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 4) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
Ship* arg2; bool arg2Init=false;
bool arg3; bool arg3Init=false;
Spectator* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Ship)
        &&  0==ex->type->superclasses.count(&typeid(Ship))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Ship, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Ship* tmp=(Ship*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
{int gen2004;
            int err = Tcl_GetBooleanFromObj(interp, objv[3], (int*)&gen2004);
            arg3=gen2004;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg3Init=true;
try {
      ret =
     
     
     constructorexplicit(arg0, arg1, arg2, arg3);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

TclSpectator(GameField* arg2) : Spectator(arg2) {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Spectator* constructorempty
    (const string& name, const string& magicCookie,  GameField* arg2) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Spectator* ret;
      ret=new Spectator(arg2);
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Spectator)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline878 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
GameField* arg2; bool arg2Init=false;
Spectator* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
{
      string name(Tcl_GetStringFromObj(objv[2], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameField)
        &&  0==ex->type->superclasses.count(&typeid(GameField))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameField, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameField* tmp=(GameField*)ex->ptr;
        
        arg2 = tmp;
    } else arg2=NULL;
};
arg2Init=true;
try {
      ret =
     
     
     constructorempty(arg0, arg1, arg2);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline880 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Spectator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Spectator)
        &&  0==ex->type->superclasses.count(&typeid(Spectator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Spectator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Spectator* tmp=(Spectator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     nextReference();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline882 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Spectator* parent=NULL;
unsigned arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Spectator)
        &&  0==ex->type->superclasses.count(&typeid(Spectator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Spectator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Spectator* tmp=(Spectator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (unsigned)tmp;};
arg0Init=true;
try {
      
     parent->
     
     requireInsignia(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline884 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Spectator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Spectator)
        &&  0==ex->type->superclasses.count(&typeid(Spectator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Spectator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Spectator* tmp=(Spectator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     kill();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline886 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Spectator* parent=NULL;
Ship* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Spectator)
        &&  0==ex->type->superclasses.count(&typeid(Spectator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Spectator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Spectator* tmp=(Spectator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getReference();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline874", trampoline874, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline876", trampoline876, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline878", trampoline878, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline880", trampoline880, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline882", trampoline882, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline884", trampoline884, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline886", trampoline886, 0, NULL);
TypeExport* ste=new TypeExport(typeid(Spectator)),
                           * ete=new TypeExport(typeid(TclSpectator));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="Spectator";
ste->superclasses.insert(&typeid(GameObject));
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(Spectator));
typeExports[&typeid(Spectator)]=ste;
typeExports[&typeid(TclSpectator)]=ete;
}
};
void classdec873(bool safe, Tcl_Interp* interp) throw() {
  TclSpectator::cppDecCode(safe,interp);
}
class TclInputNetworkGeraet : public InputNetworkGeraet {
      public:
static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {TypeExport* ste=new TypeExport(typeid(InputNetworkGeraet)),
                           * ete=new TypeExport(typeid(TclInputNetworkGeraet));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="InputNetworkGeraet";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(InputNetworkGeraet));
typeExports[&typeid(InputNetworkGeraet)]=ste;
typeExports[&typeid(TclInputNetworkGeraet)]=ete;
}
};
void classdec1245(bool safe, Tcl_Interp* interp) throw() {
  TclInputNetworkGeraet::cppDecCode(safe,interp);
}
class TclOutputNetworkGeraet : public OutputNetworkGeraet {
      public:
static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {TypeExport* ste=new TypeExport(typeid(OutputNetworkGeraet)),
                           * ete=new TypeExport(typeid(TclOutputNetworkGeraet));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="OutputNetworkGeraet";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(OutputNetworkGeraet));
typeExports[&typeid(OutputNetworkGeraet)]=ste;
typeExports[&typeid(TclOutputNetworkGeraet)]=ete;
}
};
void classdec1246(bool safe, Tcl_Interp* interp) throw() {
  TclOutputNetworkGeraet::cppDecCode(safe,interp);
}

class TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_ : public DynFun1<InputNetworkGeraet*,NetworkConnection*> {
      public:
TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_() : DynFun1<InputNetworkGeraet*,NetworkConnection*>() {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static DynFun1<InputNetworkGeraet*,NetworkConnection*>* constructorTcldefault
    (const string& name, const string& magicCookie ) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_* ret;
      ret=new TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_();
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1248 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
DynFun1<InputNetworkGeraet*,NetworkConnection*>* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      ret =
     
     
     constructorTcldefault(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       InputNetworkGeraet*
       invoke (NetworkConnection* arg0 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "invoke";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);

          Tcl_Obj* returnValueTcl=NULL;
          InputNetworkGeraet* returnValue;
Tcl_Obj* arg0Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {if (!(arg0)) {
      arg0Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg0));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg0)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg0))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg0)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg0Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg0Tcl);
         {
        Tcl_Obj* objv[3] = {
          thisTcl,
          meth,
          arg0Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
returnValueTcl = Tcl_GetObjResult(interp);
        {
      string name(Tcl_GetStringFromObj(returnValueTcl, NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(InputNetworkGeraet)
        &&  0==ex->type->superclasses.count(&typeid(InputNetworkGeraet))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " InputNetworkGeraet, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        InputNetworkGeraet* tmp=(InputNetworkGeraet*)ex->ptr;
        
        returnValue = tmp;
    } else returnValue=NULL;
}
        //Run any check code we may have
        { bool ok=true;
          #define val returnValue
          
          #undef val
          if (!ok) {
            //Cancel import and fail
            
            scriptingErrorMessage = "Unacceptable return value from Tcl override";
            goto long_jump;
          }
        }
        return returnValue;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1250 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynFun1<InputNetworkGeraet*,NetworkConnection*>* parent=NULL;
NetworkConnection* arg0; bool arg0Init=false;
InputNetworkGeraet* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>)
        &&  0==ex->type->superclasses.count(&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynFun1<InputNetworkGeraet*,NetworkConnection*>, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynFun1<InputNetworkGeraet*,NetworkConnection*>* tmp=(DynFun1<InputNetworkGeraet*,NetworkConnection*>*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkConnection)
        &&  0==ex->type->superclasses.count(&typeid(NetworkConnection))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkConnection, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkConnection* tmp=(NetworkConnection*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      ret =
     parent->
     
     invoke(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1252 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t* arg0; bool arg0Init=false;
NetworkConnection* arg1; bool arg1Init=false;
InputNetworkGeraet* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t)
        &&  0==ex->type->superclasses.count(&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t* tmp=(DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkConnection)
        &&  0==ex->type->superclasses.count(&typeid(NetworkConnection))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkConnection, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkConnection* tmp=(NetworkConnection*)ex->ptr;
        
        arg1 = tmp;
    } else arg1=NULL;
};
arg1Init=true;
try {
      ret =
     
     
     call(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1254 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynFun1<InputNetworkGeraet*,NetworkConnection*>* parent=NULL;
DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>)
        &&  0==ex->type->superclasses.count(&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynFun1<InputNetworkGeraet*,NetworkConnection*>, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynFun1<InputNetworkGeraet*,NetworkConnection*>* tmp=(DynFun1<InputNetworkGeraet*,NetworkConnection*>*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     get();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t)];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline1248", trampoline1248, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1250", trampoline1250, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1252", trampoline1252, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1254", trampoline1254, 0, NULL);
TypeExport* ste=new TypeExport(typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>)),
                           * ete=new TypeExport(typeid(TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="fun<InputNetworkGeraet*:NetworkConnection*>";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>));
typeExports[&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>)]=ste;
typeExports[&typeid(TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_)]=ete;
}
};
void classdec1247(bool safe, Tcl_Interp* interp) throw() {
  TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_::cppDecCode(safe,interp);
}


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1547 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 0) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
unsigned ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

try {
      ret =
     
     
     joystick::count();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1549 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
unsigned arg0; bool arg0Init=false;
const char* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (unsigned)tmp;};
arg0Init=true;
try {
      ret =
     
     
     joystick::name(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(ret? ret : "", -1, &dstr);
        retTcl = Tcl_NewUnicodeObj(tuc, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1551 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
unsigned arg0; bool arg0Init=false;
joystick::AxisType arg1; bool arg1Init=false;
unsigned ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (unsigned)tmp;};
arg0Init=true;
{
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "Axis")) {arg1=joystick::Axis; goto done2271;}
        
          if (0 == strcmp(tmp, "BallX")) {arg1=joystick::BallX; goto done2271;}
        
          if (0 == strcmp(tmp, "BallY")) {arg1=joystick::BallY; goto done2271;}
         {
          sprintf(staticError, "Unable to convert %s to joystick::AxisType", tmp);
          scriptError(staticError);
        } 
done2271:;};
arg1Init=true;
try {
      ret =
     
     
     joystick::axisCount(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
 int
     trampoline1553 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
unsigned arg0; bool arg0Init=false;
joystick::ButtonType arg1; bool arg1Init=false;
unsigned ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[0], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (unsigned)tmp;};
arg0Init=true;
{
        const char* tmp = Tcl_GetStringFromObj(objv[1], NULL);
        //Protect from buffer overflows in static error messages
        if (strlen(tmp) > 100) { scriptError("Enumeration value too long"); }
      
          if (0 == strcmp(tmp, "Button")) {arg1=joystick::Button; goto done2272;}
        
          if (0 == strcmp(tmp, "HatUp")) {arg1=joystick::HatUp; goto done2272;}
        
          if (0 == strcmp(tmp, "HatDown")) {arg1=joystick::HatDown; goto done2272;}
        
          if (0 == strcmp(tmp, "HatLeft")) {arg1=joystick::HatLeft; goto done2272;}
        
          if (0 == strcmp(tmp, "HatRight")) {arg1=joystick::HatRight; goto done2272;}
         {
          sprintf(staticError, "Unable to convert %s to joystick::ButtonType", tmp);
          scriptError(staticError);
        } 
done2272:;};
arg1Init=true;
try {
      ret =
     
     
     joystick::buttonCount(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewIntObj((int)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


