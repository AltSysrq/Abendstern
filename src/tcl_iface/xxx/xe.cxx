
  /**
   * @file
   * @author C++-Tcl Bridge Code Generator
   * @brief Autogenerated bindings; <b>not intended for human consumption</b>
   *
   * AUTOGENERATED BY generate.tcl. DO NOT EDIT DIRECTLY.
   * @see src/tcl_iface/readme.txt
   */

  #include <map>
  #include <set>
  #include <vector>
  #include <string>
  #include <cstring>
  #include <cstdio>
  #include <cstdlib>
  #include <iostream>

  #include <GL/gl.h>
  #include <SDL.h>
  #include <tcl.h>
  #include <itcl.h>
  #include <libconfig.h++>

  #include "src/tcl_iface/bridge.hxx"
  #include "src/tcl_iface/implementation.hxx"
  #include "src/tcl_iface/dynfun.hxx"
  #include "src/exit_conditions.hxx"
  #include "src/globals.hxx"

  #pragma GCC diagnostic ignored "-Wunused-label"
  #pragma GCC diagnostic ignored "-Waddress"
  using namespace std;
  using namespace tcl_glue_implementation;
  using namespace libconfig;

  //Commands get their zeroth argument as their own name;
  //code generation is simpler if we drop this
  #define SHIFT ++objv, --objc

#include "src/ship/auxobj/plasma_fire.hxx"
#include "src/background/background.hxx"
#include "src/sim/game_object.hxx"
#include "src/ship/editor/manipulator.hxx"
#include "src/ship/ship.hxx"
#include "src/ship/cell/cell.hxx"
#include "src/net/network_geraet.hxx"
#include "src/net/network_connection.hxx"
class TclPlasmaFire : public PlasmaFire {
      public:

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline385 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       PlasmaFire* parent=NULL;
float arg0; bool arg0Init=false;
bool ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(PlasmaFire)
        &&  0==ex->type->superclasses.count(&typeid(PlasmaFire))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " PlasmaFire, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        PlasmaFire* tmp=(PlasmaFire*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      ret =
     parent->
     
     update(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewBooleanObj(ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline387 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       PlasmaFire* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(PlasmaFire)
        &&  0==ex->type->superclasses.count(&typeid(PlasmaFire))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " PlasmaFire, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        PlasmaFire* tmp=(PlasmaFire*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     draw();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline389 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       PlasmaFire* parent=NULL;
float ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(PlasmaFire)
        &&  0==ex->type->superclasses.count(&typeid(PlasmaFire))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " PlasmaFire, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        PlasmaFire* tmp=(PlasmaFire*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     getRadius();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{retTcl = Tcl_NewDoubleObj((double)ret);}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline385", trampoline385, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline387", trampoline387, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline389", trampoline389, 0, NULL);
TypeExport* ste=new TypeExport(typeid(PlasmaFire)),
                           * ete=new TypeExport(typeid(TclPlasmaFire));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="PlasmaFire";
ste->superclasses.insert(&typeid(GameObject));
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(PlasmaFire));
typeExports[&typeid(PlasmaFire)]=ste;
typeExports[&typeid(TclPlasmaFire)]=ete;
}
};
void classdec384(bool safe, Tcl_Interp* interp) throw() {
  TclPlasmaFire::cppDecCode(safe,interp);
}
class TclBackground : public Background {
      public:

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline673 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Background* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Background)
        &&  0==ex->type->superclasses.count(&typeid(Background))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Background, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Background* tmp=(Background*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     draw();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline675 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Background* parent=NULL;
float arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Background)
        &&  0==ex->type->superclasses.count(&typeid(Background))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Background, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Background* tmp=(Background*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
try {
      
     parent->
     
     update(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline677 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Background* parent=NULL;
GameObject* arg0; bool arg0Init=false;
bool arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Background)
        &&  0==ex->type->superclasses.count(&typeid(Background))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Background, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Background* tmp=(Background*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(GameObject)
        &&  0==ex->type->superclasses.count(&typeid(GameObject))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " GameObject, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        GameObject* tmp=(GameObject*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{int gen1730;
            int err = Tcl_GetBooleanFromObj(interp, objv[2], (int*)&gen1730);
            arg1=gen1730;
            if (err == TCL_ERROR) {
              scriptError(Tcl_GetStringResult(interp));
            }};
arg1Init=true;
try {
      
     parent->
     
     updateReference(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline679 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Background* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Background)
        &&  0==ex->type->superclasses.count(&typeid(Background))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Background, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Background* tmp=(Background*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     repopulate();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline673", trampoline673, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline675", trampoline675, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline677", trampoline677, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline679", trampoline679, 0, NULL);
TypeExport* ste=new TypeExport(typeid(Background)),
                           * ete=new TypeExport(typeid(TclBackground));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="Background";
ste->superclasses.insert(&typeid(EffectsHandler));
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(Background));
typeExports[&typeid(Background)]=ste;
typeExports[&typeid(TclBackground)]=ete;
}
};
void classdec672(bool safe, Tcl_Interp* interp) throw() {
  TclBackground::cppDecCode(safe,interp);
}

class TclManipulator : public Manipulator {
      public:
TclManipulator() : Manipulator() {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static Manipulator* constructordefault
    (const string& name, const string& magicCookie ) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      Manipulator* ret;
      ret=new Manipulator();
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(Manipulator)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline874 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
Manipulator* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      ret =
     
     
     constructordefault(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline876 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     update();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline878 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     draw();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline880 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
float arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
try {
      
     parent->
     
     primaryDown(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline882 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
float arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
try {
      
     parent->
     
     primaryUp(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline884 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
float arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
try {
      
     parent->
     
     secondaryDown(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline886 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
float arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
try {
      
     parent->
     
     secondaryUp(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline888 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
float arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
try {
      
     parent->
     
     scrollUp(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline890 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
float arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
try {
      
     parent->
     
     scrollDown(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline892 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 5) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
float arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
float arg2; bool arg2Init=false;
float arg3; bool arg3Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[3], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg2 = (float)tmp;};
arg2Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[4], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg3 = (float)tmp;};
arg3Init=true;
try {
      
     parent->
     
     motion(arg0, arg1, arg2, arg3);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
if (arg2Init) {arg2Init=false; }
if (arg3Init) {arg3Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline894 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     resetView();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline896 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     pushUndo();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline898 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     popUndo();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline900 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     commitUndo();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline902 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     deactivateMode();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline904 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     activateMode();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline906 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     addToHistory();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline908 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
unsigned arg0; bool arg0Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{int tmp;
            int err = Tcl_GetIntFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (unsigned)tmp;};
arg0Init=true;
try {
      
     parent->
     
     revertToHistory(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline910 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
const char* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     reloadShip();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{
        static Tcl_DString dstr;
        static bool hasDstr=false;
        if (!hasDstr) {
          hasDstr = true;
          Tcl_DStringInit(&dstr);
        } else {
          Tcl_DStringSetLength(&dstr, 0);
        }
        Tcl_UniChar* tuc = Tcl_UtfToUniCharDString(ret? ret : "", -1, &dstr);
        retTcl = Tcl_NewUnicodeObj(tuc, -1);
      }
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline912 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      
     parent->
     
     deleteShip();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline914 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
const char* arg0; bool arg0Init=false;
const char* arg1; bool arg1Init=false;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
          arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg0Init=true;
{
          static Tcl_DString dstr;
          static bool hasDstr=false;
          if (!hasDstr) {
            Tcl_DStringInit(&dstr);
            hasDstr=true;
          } else {
            Tcl_DStringSetLength(&dstr, 0);
          }
          int length;
          Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[2], &length);
          arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
        };
arg1Init=true;
try {
      
     parent->
     
     copyMounts(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline916 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 3) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       Manipulator* parent=NULL;
float arg0; bool arg0Init=false;
float arg1; bool arg1Init=false;
Cell* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(Manipulator)
        &&  0==ex->type->superclasses.count(&typeid(Manipulator))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " Manipulator, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        Manipulator* tmp=(Manipulator*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[1], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg0 = (float)tmp;};
arg0Init=true;
{double tmp;
            int err = Tcl_GetDoubleFromObj(interp, objv[2], &tmp);
            if (err == TCL_ERROR)
              scriptError(Tcl_GetStringResult(interp));
            arg1 = (float)tmp;};
arg1Init=true;
try {
      ret =
     parent->
     
     getCellAt(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline874", trampoline874, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline876", trampoline876, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline878", trampoline878, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline880", trampoline880, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline882", trampoline882, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline884", trampoline884, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline886", trampoline886, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline888", trampoline888, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline890", trampoline890, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline892", trampoline892, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline894", trampoline894, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline896", trampoline896, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline898", trampoline898, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline900", trampoline900, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline902", trampoline902, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline904", trampoline904, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline906", trampoline906, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline908", trampoline908, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline910", trampoline910, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline912", trampoline912, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline914", trampoline914, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline916", trampoline916, 0, NULL);
TypeExport* ste=new TypeExport(typeid(Manipulator)),
                           * ete=new TypeExport(typeid(TclManipulator));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="Manipulator";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(Manipulator));
typeExports[&typeid(Manipulator)]=ste;
typeExports[&typeid(TclManipulator)]=ete;
}
};
void classdec873(bool safe, Tcl_Interp* interp) throw() {
  TclManipulator::cppDecCode(safe,interp);
}

class TclInputNetworkGeraet : public InputNetworkGeraet {
      public:
static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {TypeExport* ste=new TypeExport(typeid(InputNetworkGeraet)),
                           * ete=new TypeExport(typeid(TclInputNetworkGeraet));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="InputNetworkGeraet";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(InputNetworkGeraet));
typeExports[&typeid(InputNetworkGeraet)]=ste;
typeExports[&typeid(TclInputNetworkGeraet)]=ete;
}
};
void classdec1222(bool safe, Tcl_Interp* interp) throw() {
  TclInputNetworkGeraet::cppDecCode(safe,interp);
}
class TclOutputNetworkGeraet : public OutputNetworkGeraet {
      public:
static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {TypeExport* ste=new TypeExport(typeid(OutputNetworkGeraet)),
                           * ete=new TypeExport(typeid(TclOutputNetworkGeraet));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="OutputNetworkGeraet";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(OutputNetworkGeraet));
typeExports[&typeid(OutputNetworkGeraet)]=ste;
typeExports[&typeid(TclOutputNetworkGeraet)]=ete;
}
};
void classdec1223(bool safe, Tcl_Interp* interp) throw() {
  TclOutputNetworkGeraet::cppDecCode(safe,interp);
}

class TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_ : public DynFun1<InputNetworkGeraet*,NetworkConnection*> {
      public:
TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_() : DynFun1<InputNetworkGeraet*,NetworkConnection*>() {
        tclExtended=invokingInterpreter;
        tclKnown=true;
      }
static DynFun1<InputNetworkGeraet*,NetworkConnection*>* constructorTcldefault
    (const string& name, const string& magicCookie ) {
      InterpInfo* info=interpreters[invokingInterpreter];
      //Validate magic cookie
      if (magicCookie != info->magicCookie) {
        scriptError("Call to c++ new with invalid magic cookie!");
      }

      //Refuse if we enforce allocation and the interpreter knows too much
      if (info->enforceAllocationLimit && info->exports.size() > MAX_EXPORTS) {
        scriptError("Interpreter allocation limit exceeded");
      }

      //Refuse duplicate allocation
      if (info->exportsByName[name]) {
        scriptError("Double allocation");
      }
      TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_* ret;
      ret=new TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_();
      if (ret) {
        ret->tclKnown = true;
        //The trampoline will take care of assigning ownership to Tcl, we
        //just need to create the export so it has the correct name
        Export* ex=new Export;
        info->exports[(void*)ret]=ex;
        info->exportsByName[name]=ex;
        ex->ptr = (void*)ret;
        ex->type = typeExports[&typeid(TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_)];
        ex->interp = invokingInterpreter;
        ex->tclrep=name;
      }

      return ret;
    }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1225 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
string arg0; bool arg0Init=false;
string arg1; bool arg1Init=false;
DynFun1<InputNetworkGeraet*,NetworkConnection*>* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[0], &length);
      arg0 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg0Init=true;
{
      static Tcl_DString dstr;
      static bool hasDstr=false;
      if (!hasDstr) {
        Tcl_DStringInit(&dstr);
        hasDstr=true;
      } else {
        Tcl_DStringSetLength(&dstr, 0);
      }
      int length;
      Tcl_UniChar* tuc = Tcl_GetUnicodeFromObj(objv[1], &length);
      arg1 = Tcl_UniCharToUtfDString(tuc, length, &dstr);
    };
arg1Init=true;
try {
      ret =
     
     
     constructorTcldefault(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      if ((ret)) switch ((ret)->ownStat) {
            case AObject::Tcl:
              if (interp == (ret)->owner.interpreter) {
                
              }
              //fall through
            case AObject::Cpp:
              (ret)->ownStatBak=(ret)->ownStat;
              (ret)->ownerBak.interpreter = (ret)->owner.interpreter;
              (ret)->ownStat=AObject::Tcl;
              (ret)->owner.interpreter=interp;
              break;
            case AObject::Container:
              cerr <<
"FATAL: Attempt by C++ to give Tcl ownership of automatic value" << endl;
              ::exit(EXIT_PROGRAM_BUG);
          }

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
virtual
       InputNetworkGeraet*
       invoke (NetworkConnection* arg0 )   { {
        //Forward to Tcl
        int status;
        Tcl_Interp* interp=tclExtended;
        Tcl_Obj* thisTcl=NULL;
        const char*const methodName = "invoke";
        Tcl_Obj* meth=Tcl_NewStringObj(methodName, -1);
        Tcl_IncrRefCount(meth);

          Tcl_Obj* returnValueTcl=NULL;
          InputNetworkGeraet* returnValue;
Tcl_Obj* arg0Tcl = NULL;
{if (!(this)) {
      thisTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(this));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (this)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(this))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(this)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      thisTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
        Tcl_IncrRefCount(thisTcl);
      {if (!(arg0)) {
      arg0Tcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(arg0));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (arg0)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(arg0))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(arg0)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      arg0Tcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
          Tcl_IncrRefCount(arg0Tcl);
         {
        Tcl_Obj* objv[3] = {
          thisTcl,
          meth,
          arg0Tcl, };
      status = Tcl_EvalObjv(interp, sizeof(objv)/sizeof(Tcl_Obj*), objv, TCL_EVAL_GLOBAL);
      }
      //Before checking status, decrement all ref counts.
      Tcl_DecrRefCount(thisTcl);
      thisTcl=NULL;
      Tcl_DecrRefCount(meth);
      meth=NULL;
      Tcl_DecrRefCount(arg0Tcl);
arg0Tcl=NULL;

      if (status == TCL_ERROR) {
        /* It's hard to reason about how the memory model should respond to this.
         * However, deexporting the arguments is probably a worse idea than
         * leaving them be.
         * So just get out.
         */
        scriptingErrorMessage = Tcl_GetStringResult(interp);
        goto long_jump;
      }

      //OK!
returnValueTcl = Tcl_GetObjResult(interp);
        {
      string name(Tcl_GetStringFromObj(returnValueTcl, NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(InputNetworkGeraet)
        &&  0==ex->type->superclasses.count(&typeid(InputNetworkGeraet))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " InputNetworkGeraet, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        InputNetworkGeraet* tmp=(InputNetworkGeraet*)ex->ptr;
        
        returnValue = tmp;
    } else returnValue=NULL;
}
        //Run any check code we may have
        { bool ok=true;
          #define val returnValue
          
          #undef val
          if (!ok) {
            //Cancel import and fail
            
            scriptingErrorMessage = "Unacceptable return value from Tcl override";
            goto long_jump;
          }
        }
        return returnValue;

      error:
      //Decref anything existing
      if (thisTcl) Tcl_DecrRefCount(thisTcl);
      if (meth) Tcl_DecrRefCount(meth);
      if (arg0Tcl) {
          //Deimport as well
          {}
          Tcl_DecrRefCount(arg0Tcl);
        }
}
        long_jump:
        longjmp(currentTclErrorHandler, 1);
      }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1227 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynFun1<InputNetworkGeraet*,NetworkConnection*>* parent=NULL;
NetworkConnection* arg0; bool arg0Init=false;
InputNetworkGeraet* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>)
        &&  0==ex->type->superclasses.count(&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynFun1<InputNetworkGeraet*,NetworkConnection*>, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynFun1<InputNetworkGeraet*,NetworkConnection*>* tmp=(DynFun1<InputNetworkGeraet*,NetworkConnection*>*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkConnection)
        &&  0==ex->type->superclasses.count(&typeid(NetworkConnection))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkConnection, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkConnection* tmp=(NetworkConnection*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
try {
      ret =
     parent->
     
     invoke(arg0);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
if (arg0Init) {arg0Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1229 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 2) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       
DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t* arg0; bool arg0Init=false;
NetworkConnection* arg1; bool arg1Init=false;
InputNetworkGeraet* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;

{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t)
        &&  0==ex->type->superclasses.count(&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t* tmp=(DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t*)ex->ptr;
        
        arg0 = tmp;
    } else arg0=NULL;
};
arg0Init=true;
{
      string name(Tcl_GetStringFromObj(objv[1], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(NetworkConnection)
        &&  0==ex->type->superclasses.count(&typeid(NetworkConnection))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " NetworkConnection, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        NetworkConnection* tmp=(NetworkConnection*)ex->ptr;
        
        arg1 = tmp;
    } else arg1=NULL;
};
arg1Init=true;
try {
      ret =
     
     
     call(arg0, arg1);

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        (ret)->tclKnown=true;
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(*(ret))];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      
if (arg0Init) {arg0Init=false; }
if (arg1Init) {arg1Init=false; }
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError


#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }

#define scriptError(desc) { scriptingErrorMessage=desc; goto error; }
static int
     trampoline1231 (
     ClientData, Tcl_Interp* interp, int objc, Tcl_Obj*const objv[]) throw() {
       SHIFT;
       if (objc != 1) {
         Tcl_SetResult(interp, "Incorrect number of arguments passed to internal function", TCL_VOLATILE);
         return TCL_ERROR;
       }
       invokingInterpreter=interp;
       DynFun1<InputNetworkGeraet*,NetworkConnection*>* parent=NULL;
DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t* ret; Tcl_Obj* retTcl=NULL;
PUSH_TCL_ERROR_HANDLER(errorOccurred); if (errorOccurred) goto error;
{
      string name(Tcl_GetStringFromObj(objv[0], NULL));
      if (name != "0") {
        //Does it exist?
        InterpInfo* info=interpreters[interp];
        map<string,Export*>::iterator it=info->exportsByName.find(name);
        if (it == info->exportsByName.end()) {
          for (it=info->exportsByName.begin();
               it != info->exportsByName.end(); ++it) {
            cout << (*it).first << endl;
          }
          sprintf(staticError, "Invalid export passed to C++: %s",
                  name.c_str());
          scriptError(staticError);
        }
        Export* ex=(*it).second;
        //OK, is the type correct?
        if (ex->type->theType != typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>)
        &&  0==ex->type->superclasses.count(&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>))) {
          //Nope
          sprintf(staticError, "Wrong type passed to C++ function; expected"
                               " DynFun1<InputNetworkGeraet*,NetworkConnection*>, "
                               "got %s", ex->type->tclClassName.c_str());
          scriptError(staticError);
        }

        //All is well, transfer ownership now
        DynFun1<InputNetworkGeraet*,NetworkConnection*>* tmp=(DynFun1<InputNetworkGeraet*,NetworkConnection*>*)ex->ptr;
        
        parent = tmp;
    } else parent=NULL;
}
      if (!parent) { scriptError("NULL this passed into C++"); }
try {
      ret =
     parent->
     
     get();

    } catch (exception& ex) {
      sprintf(staticError, "%s: %s", typeid(ex).name(), ex.what());
      scriptError(staticError);
    }
{if (!(ret)) {
      retTcl=Tcl_NewStringObj("0", 1);
    } else {
      InterpInfo* info=interpreters[interp];
      //Is it a valid export already?
      void* ptr=const_cast<void*>((void*)(ret));
      map<void*,Export*>::iterator it=info->exports.find(ptr);
      Export* ex;
      if (it == info->exports.end()) {
        //No, create new one
        
        ex=new Export;
        ex->ptr=ptr;
        ex->type=typeExports[&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>::fun_t)];
        ex->interp=interp;
        

        //Create the new Tcl-side object with
        //  new Type {}
        Tcl_Obj* cmd[3] = {
          Tcl_NewStringObj("new", 3),
          Tcl_NewStringObj(ex->type->tclClassName.c_str(),
                           ex->type->tclClassName.size()),
          Tcl_NewObj(),
        };
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_IncrRefCount(cmd[i]);
        int status=Tcl_EvalObjv(interp, lenof(cmd), cmd, TCL_EVAL_GLOBAL);
        for (unsigned i=0; i<lenof(cmd); ++i)
          Tcl_DecrRefCount(cmd[i]);
        if (status == TCL_ERROR) {
          sprintf(staticError, "Error exporting C++ object to Tcl: %s",
                  Tcl_GetStringResult(interp));
          scriptError(staticError);
        }

        //We can now get the name, and then have a fully-usable export
        ex->tclrep=Tcl_GetStringResult(interp);
        //Register
        info->exports[(void*)(ret)]=ex;
        info->exportsByName[ex->tclrep]=ex;
      } else {
        //Yes, use directly
        ex = (*it).second;
      }

      //Ownership
      

      //Done
      retTcl=Tcl_NewStringObj(ex->tclrep.c_str(), ex->tclrep.size());
    }}
Tcl_SetObjResult(interp, retTcl);
POP_TCL_ERROR_HANDLER;
      return TCL_OK;
error:
      POP_TCL_ERROR_HANDLER;
      double_error:
      #undef scriptError
      #define scriptError(msg) { \
        cerr << "Double-error; old message: " << scriptingErrorMessage << \
        ", new message: " << msg << endl; \
        scriptingErrorMessage = msg; goto double_error; \
      }
      if (parent) {}
#undef scriptError
Tcl_SetResult(interp, scriptingErrorMessage, NULL); return TCL_ERROR; }
#undef scriptError

static void cppDecCode(bool safe,Tcl_Interp* interp) throw() {Tcl_CreateObjCommand(interp, "c++ trampoline1225", trampoline1225, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1227", trampoline1227, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1229", trampoline1229, 0, NULL);
Tcl_CreateObjCommand(interp, "c++ trampoline1231", trampoline1231, 0, NULL);
TypeExport* ste=new TypeExport(typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>)),
                           * ete=new TypeExport(typeid(TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_));
ste->isAObject=ete->isAObject=true;
ste->tclClassName=ete->tclClassName="fun<InputNetworkGeraet*:NetworkConnection*>";
ste->superclasses.insert(&typeid(AObject));
ete->superclasses=ste->superclasses;
ete->superclasses.insert(&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>));
typeExports[&typeid(DynFun1<InputNetworkGeraet*,NetworkConnection*>)]=ste;
typeExports[&typeid(TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_)]=ete;
}
};
void classdec1224(bool safe, Tcl_Interp* interp) throw() {
  TclDynFun1_leftangle_InputNetworkGeraet_asterix_u_comma_NetworkConnection_asterix_u_rightangle_::cppDecCode(safe,interp);
}

