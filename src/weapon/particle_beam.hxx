/**
 * @file
 * @author Jason Lingle
 * @brief Contains the ParticleEmitter weapon and helper ParticleBurst
 */

/*
 * particle_beam.hxx
 *
 *  Created on: 09.03.2011
 *      Author: jason
 */

#ifndef PARTICLE_BEAM_HXX_
#define PARTICLE_BEAM_HXX_

#include <vector>

#include "src/sim/game_object.hxx"
class Ship;

///Defines the type of a particle beam
enum ParticleBeamType {
  ///Kills FissionPower
  NeutronBeam=0,
  ///Kills FusionPower
  MuonBeam,
  ///Kills AntimatterPower
  AntiprotonBeam,
  ///Kills PowerCells
  PositronBeam
};

/** The ParticleEmitter is in itself not a weapon, but rather
 * a courier for the ParticleBurst object. As it travels, it
 * emits ParticleBursts in a predetermined pattern. Though less
 * physically correct, the emissions do not have velocity added
 * to match the ParticleEmitter, but are rather emitted relative
 * to zero velocity. This prevents an exploit that would allow
 * a fast-moving ship to kill anything with the weapon. (It does,
 * however, still enable killing very fast ships, though that is
 * far from a serious issue.)
 *
 * The design of this
 * class primarily has to do with networking: ParticleBursts
 * do not release blasts, so there is no good way to communicate
 * their collision actions. Instead, the launcher fires
 * this class, which emits particles in a pseudorandom fassion,
 * but in a manner that can be easily communicated over the
 * network, without needing to export the ParticleBursts.
 *
 * This class and ParticleBurst are collectively called the
 * "Particle Beam", although it may not be the most apt
 * description.
 *
 * On collision with anything collideable, the ParticleEmitter
 * simply ceases to exist.
 */
class ParticleEmitter: public GameObject {
  friend class INO_ParticleEmitter;
  friend class ENO_ParticleEmitter;

  public:
  static const unsigned r_sz = 8; ///<Internal and networking only
  static const unsigned r_msk = 7; ///<Internal and networking only
  static const unsigned emissionTime = 64; ///<Internal and networking only
  static const unsigned timeAliveRotDiv = 300.0f; ///<Internal and networking only
  static const unsigned lifetime = 2560; ///<Internal and networking only

  private:
  GameObject*const parent;

  CollisionRectangle colrect;
  std::vector<CollisionRectangle*> collisionBounds;

  const ParticleBeamType type;

  /* We use 8 randomly-generated bytes to determine
   * what angle to create the particles in. We
   * keep a major and minor index, which are
   * never equal, to this array. The random angle
   * used is based on r[maj]^r[min].
   *
   * The formula used to find the angle of the particles
   * is to be exactly:
   *   (r[rmajor]^r[rminor])/128.0f*pi
   * rminor is to be incremented exactly once every particle
   * emission, which occurs once per 64 milliseconds. rmajor
   * is to be incremented whenever rminor is incremented to 0.
   * If rminor==rmajor, the increment is repeated.
   *
   * The lifetime of each emitted particle is to be exactly
   *   (timeAlive/lifetime*0.5f+0.5f)*256.
   */
  unsigned char r[8];
  unsigned rmajor, rminor;
  float timeAlive;

  unsigned blame;

  //Networking constructor
  ParticleEmitter(GameField*, ParticleBeamType, unsigned, float, float, float,
                  float, const unsigned char*, unsigned, unsigned,
                  float timeAlive);

  public:
  /** Constructs a ParticleEmitter with the given parms.
   *
   * @param field The field in which the emitter will live
   * @param t Type of emitter
   * @param x Initial X coordinate
   * @param y Initial Y coordinate
   * @param vx X velocity
   * @param vy Y velocity
   * @param par Ship that launched the emitter
   */
  ParticleEmitter(GameField* field, ParticleBeamType t, float x, float y,
                  float vx, float vy, Ship* par);

  virtual bool update(float) noth;
  virtual void draw() noth;
  virtual float getRadius() const noth;

  virtual const std::vector<CollisionRectangle*>* getCollisionBounds() noth;
  virtual CollisionResult checkCollision(GameObject*) noth;
  virtual bool collideWith(GameObject*) noth;
};

/** The ParticleBurst is a simple object emitted by ParticleEmitter,
 * in a manner described in that class.
 *
 * This class itself serves only as a basic container for the required
 * data, as well as providing update and drawing routines. It simply
 * ceases to exist a short time after the first collision. It is up
 * to the collidee to assign meaning to the collision. The effect should
 * only occur on living ships. The Ship should find which cell, if any,
 * caused the collision, and call particleBeamCollision(ParticleBurst*)
 * on any systems in that may be in that cell. The systems should
 * respond as follows:
 * + FissionPower will explode if the type is NeutronBeam
 * + FusionPower will explode if the type is MuonBeam
 * + AntimatterPower will explode if the type is AntiprotonBeam
 * + PowerCell will break if the type is PositronBeam
 * All other combinations should have no effect.
 */
class ParticleBurst: public GameObject {
  friend class ParticleEmitter;

  CollisionRectangle colrect;
  std::vector<CollisionRectangle*> collisionBounds;

  //The location where we were created
  float ox, oy;
  //The vx and vy of the emitter that created us
  float ovx, ovy;

  float timeLeft;
  bool hasCollided;

  //Constructor only useable by ParticleEmitter
  ParticleBurst(GameField*, unsigned blame, float x, float y,
                float vx, float vy,
                float ovx, float ovy, float time, ParticleBeamType);

  public:
  const ParticleBeamType type; ///<The type of the beam
  const unsigned blame; ///<The blameID of the beam

  virtual bool update(float) noth;
  virtual void draw() noth;
  virtual float getRadius() const noth;

  virtual const std::vector<CollisionRectangle*>* getCollisionBounds() noth;
  virtual CollisionResult checkCollision(GameObject*) noth;
  virtual bool collideWith(GameObject*) noth;
};

#endif /* PARTICLE_BEAM_HXX_ */
