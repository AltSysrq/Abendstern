
  package require Itcl

  # AUTOGENERATED BY generate.tcl. DO NOT EDIT DIRECTLY.
  # See readme.txt.

  #Our base Tcl glue code (eval'd to hardwire the magic cookie)
  eval [format {
    itcl::class AObject {
      # Ensure all code uses the fully-qualified name for C++ to recognize it
      method fqn {} {::return $this}

      protected constructor {cppClass constname cppArgs} {
        if {[::string length $constname]} {
          # Intercept errors so we don't leak the magic number
          if {[catch {
            "::c++ new $cppClass $constname" $this %s {*}$cppArgs
          } err]} {
            error "Bad constructor call: $cppClass $constname: $err"
          }
        }
      }
      destructor {
        {::c++ delete} $this %s
      }

      method super {sup cname {args {}}} {
        ${sup}::constructor $sup $cname $args
      }

      # Prevent access to the magic cookie by redirecting
      # all info requests to the global one
      method info {args} {
        ::namespace eval :: ::info {*}$args
      }
    }
  } ${ABENDSTERN-MAGIC-COOKIE-1} ${ABENDSTERN-MAGIC-COOKIE-1}]
  unset ABENDSTERN-MAGIC-COOKIE-1

  # Have rename commit suicide
  # rename rename {}

  set glueClass(AObject) yes

  proc new {clazz args} {
    global glueClass
    if {[info exists glueClass($clazz)]} {
      [$clazz #auto $clazz [lindex $args 0] [lrange $args 1 [llength $args]]] fqn
    } else {
      [$clazz #auto {*}$args] fqn
    }
  }

proc {c++ delete} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1} $a0 $a1 ]]
return $retpi
}
proc {glBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline3} $a0 ]]
return $retpi
}
proc {glEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline5} ]]
return $retpi
}
proc {glVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline7} $a0 $a1 ]]
return $retpi
}
proc {glColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline9} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {glPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline11} ]]
return $retpi
}
proc {glPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline13} ]]
return $retpi
}
proc {glLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline15} ]]
return $retpi
}
proc {glTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline17} $a0 $a1 ]]
return $retpi
}
proc {glRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline19} $a0 ]]
return $retpi
}
proc {glScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline21} $a0 $a1 ]]
return $retpi
}
proc {glUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline23} $a0 ]]
return $retpi
}
proc {glReset} {  } {set retpi [uplevel 1 [list {c++ trampoline25} ]]
return $retpi
}

proc {acsgi_begin} {  } {set retpi [uplevel 1 [list {c++ trampoline27} ]]
return $retpi
}
proc {acsgi_end} {  } {set retpi [uplevel 1 [list {c++ trampoline29} ]]
return $retpi
}
proc {acsgi_draw} {  } {set retpi [uplevel 1 [list {c++ trampoline31} ]]
return $retpi
}
proc {acsgi_textNormal} { a0  } {set retpi [uplevel 1 [list {c++ trampoline33} $a0 ]]
return $retpi
}
proc {cglBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline35} $a0 ]]
return $retpi
}
proc {cglEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline37} ]]
return $retpi
}
proc {cglVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline39} $a0 $a1 ]]
return $retpi
}
proc {cglColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline41} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {cglPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline43} ]]
return $retpi
}
proc {cglPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline45} ]]
return $retpi
}
proc {cglLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline47} ]]
return $retpi
}
proc {cglTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline49} $a0 $a1 ]]
return $retpi
}
proc {cglRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline51} $a0 ]]
return $retpi
}
proc {cglScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline53} $a0 $a1 ]]
return $retpi
}
proc {cglUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline55} $a0 ]]
return $retpi
}
proc {cglText} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline57} $a0 $a1 $a2 ]]
return $retpi
}
 proc accessor60 {ignored ignored op} {
             global SDLK_LAST
             if {$op == {read}} {
               set tmp [{c++ get59} ]
               set SDLK_LAST $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDLK_LAST"
             } else { error "Cannot unset C++ variable SDLK_LAST" }
           }

proc {SDLKeyToInt} { a0  } {set retpi [uplevel 1 [list {c++ trampoline61} $a0 ]]
set ret $retpi
return $ret
}
 proc accessor64 {ignored ignored op} {
             global none
             if {$op == {read}} {
               set tmp [{c++ get63} ]
               set none $tmp

             } elseif {$op == {write}} {
               error "Cannot write to none"
             } else { error "Cannot unset C++ variable none" }
           }

 proc accessor66 {ignored ignored op} {
             global lshift
             if {$op == {read}} {
               set tmp [{c++ get65} ]
               set lshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lshift"
             } else { error "Cannot unset C++ variable lshift" }
           }

 proc accessor68 {ignored ignored op} {
             global rshift
             if {$op == {read}} {
               set tmp [{c++ get67} ]
               set rshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rshift"
             } else { error "Cannot unset C++ variable rshift" }
           }

 proc accessor70 {ignored ignored op} {
             global lctrl
             if {$op == {read}} {
               set tmp [{c++ get69} ]
               set lctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lctrl"
             } else { error "Cannot unset C++ variable lctrl" }
           }

 proc accessor72 {ignored ignored op} {
             global rctrl
             if {$op == {read}} {
               set tmp [{c++ get71} ]
               set rctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rctrl"
             } else { error "Cannot unset C++ variable rctrl" }
           }

 proc accessor74 {ignored ignored op} {
             global lalt
             if {$op == {read}} {
               set tmp [{c++ get73} ]
               set lalt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lalt"
             } else { error "Cannot unset C++ variable lalt" }
           }

 proc accessor76 {ignored ignored op} {
             global ralt
             if {$op == {read}} {
               set tmp [{c++ get75} ]
               set ralt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ralt"
             } else { error "Cannot unset C++ variable ralt" }
           }

 proc accessor78 {ignored ignored op} {
             global lmeta
             if {$op == {read}} {
               set tmp [{c++ get77} ]
               set lmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lmeta"
             } else { error "Cannot unset C++ variable lmeta" }
           }

 proc accessor80 {ignored ignored op} {
             global rmeta
             if {$op == {read}} {
               set tmp [{c++ get79} ]
               set rmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rmeta"
             } else { error "Cannot unset C++ variable rmeta" }
           }

 proc accessor82 {ignored ignored op} {
             global num
             if {$op == {read}} {
               set tmp [{c++ get81} ]
               set num $tmp

             } elseif {$op == {write}} {
               error "Cannot write to num"
             } else { error "Cannot unset C++ variable num" }
           }

 proc accessor84 {ignored ignored op} {
             global caps
             if {$op == {read}} {
               set tmp [{c++ get83} ]
               set caps $tmp

             } elseif {$op == {write}} {
               error "Cannot write to caps"
             } else { error "Cannot unset C++ variable caps" }
           }

 proc accessor86 {ignored ignored op} {
             global mode
             if {$op == {read}} {
               set tmp [{c++ get85} ]
               set mode $tmp

             } elseif {$op == {write}} {
               error "Cannot write to mode"
             } else { error "Cannot unset C++ variable mode" }
           }

 proc accessor88 {ignored ignored op} {
             global reserved
             if {$op == {read}} {
               set tmp [{c++ get87} ]
               set reserved $tmp

             } elseif {$op == {write}} {
               error "Cannot write to reserved"
             } else { error "Cannot unset C++ variable reserved" }
           }

::itcl::class {SDL_keysym} {
inherit AObject
public variable scancode
 method accessor92 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get90} $this]
               set scancode $tmp

             } elseif {$op == {write}} {
               return [{c++ set91} $this $scancode]
             } else { error "Cannot unset C++ variable scancode" }
           }

public variable sym
 method accessor95 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get93} $this]
               set sym $tmp

             } elseif {$op == {write}} {
               return [{c++ set94} $this $sym]
             } else { error "Cannot unset C++ variable sym" }
           }

public variable mod
 method accessor98 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get96} $this]
               set mod $tmp

             } elseif {$op == {write}} {
               return [{c++ set97} $this $mod]
             } else { error "Cannot unset C++ variable mod" }
           }

public variable unicode
 method accessor101 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get99} $this]
               set unicode $tmp

             } elseif {$op == {write}} {
               return [{c++ set100} $this $unicode]
             } else { error "Cannot unset C++ variable unicode" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set scancode {}
            trace add variable scancode {read write unset} "$this accessor92"
set sym {}
            trace add variable sym {read write unset} "$this accessor95"
set mod {}
            trace add variable mod {read write unset} "$this accessor98"
set unicode {}
            trace add variable unicode {read write unset} "$this accessor101"
}
destructor {
trace remove variable scancode {read write unset} "$this accessor92"
trace remove variable sym {read write unset} "$this accessor95"
trace remove variable mod {read write unset} "$this accessor98"
trace remove variable unicode {read write unset} "$this accessor101"
}
}

::itcl::class {SDL_KeyboardEvent} {
inherit AObject
public variable type
 method accessor105 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get103} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set104} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor108 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get106} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set107} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable keysym
 method accessor111 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get109} $this]
               set keysym $tmp

             } elseif {$op == {write}} {
               return [{c++ set110} $this $keysym]
             } else { error "Cannot unset C++ variable keysym" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor105"
set state {}
            trace add variable state {read write unset} "$this accessor108"
set keysym {}
            trace add variable keysym {read write unset} "$this accessor111"
}
destructor {
trace remove variable type {read write unset} "$this accessor105"
trace remove variable state {read write unset} "$this accessor108"
trace remove variable keysym {read write unset} "$this accessor111"
}
}

 proc accessor113 {ignored ignored op} {
             global SDL_BUTTON_1
             if {$op == {read}} {
               set tmp [{c++ get112} ]
               set SDL_BUTTON_1 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_1"
             } else { error "Cannot unset C++ variable SDL_BUTTON_1" }
           }

 proc accessor115 {ignored ignored op} {
             global SDL_BUTTON_2
             if {$op == {read}} {
               set tmp [{c++ get114} ]
               set SDL_BUTTON_2 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_2"
             } else { error "Cannot unset C++ variable SDL_BUTTON_2" }
           }

 proc accessor117 {ignored ignored op} {
             global SDL_BUTTON_3
             if {$op == {read}} {
               set tmp [{c++ get116} ]
               set SDL_BUTTON_3 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_3"
             } else { error "Cannot unset C++ variable SDL_BUTTON_3" }
           }

 proc accessor119 {ignored ignored op} {
             global SDL_BUTTON_4
             if {$op == {read}} {
               set tmp [{c++ get118} ]
               set SDL_BUTTON_4 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_4"
             } else { error "Cannot unset C++ variable SDL_BUTTON_4" }
           }

 proc accessor121 {ignored ignored op} {
             global SDL_BUTTON_5
             if {$op == {read}} {
               set tmp [{c++ get120} ]
               set SDL_BUTTON_5 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_5"
             } else { error "Cannot unset C++ variable SDL_BUTTON_5" }
           }

proc {SDL_GetModState} {  } {set retpi [uplevel 1 [list {c++ trampoline122} ]]
set ret $retpi
return $ret
}
 proc accessor125 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_INTERVAL
             if {$op == {read}} {
               set tmp [{c++ get124} ]
               set SDL_DEFAULT_REPEAT_INTERVAL $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_INTERVAL"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_INTERVAL" }
           }

 proc accessor127 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_DELAY
             if {$op == {read}} {
               set tmp [{c++ get126} ]
               set SDL_DEFAULT_REPEAT_DELAY $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_DELAY"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_DELAY" }
           }

proc {SDL_EnableKeyRepeat} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline128} $a0 $a1 ]]
return $retpi
}

::itcl::class {SDL_MouseMotionEvent} {
inherit AObject
public variable type
 method accessor133 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get131} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set132} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor136 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get134} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set135} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor139 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get137} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set138} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor142 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get140} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set141} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

public variable xrel
 method accessor145 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get143} $this]
               set xrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set144} $this $xrel]
             } else { error "Cannot unset C++ variable xrel" }
           }

public variable yrel
 method accessor148 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get146} $this]
               set yrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set147} $this $yrel]
             } else { error "Cannot unset C++ variable yrel" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor133"
set state {}
            trace add variable state {read write unset} "$this accessor136"
set x {}
            trace add variable x {read write unset} "$this accessor139"
set y {}
            trace add variable y {read write unset} "$this accessor142"
set xrel {}
            trace add variable xrel {read write unset} "$this accessor145"
set yrel {}
            trace add variable yrel {read write unset} "$this accessor148"
}
destructor {
trace remove variable type {read write unset} "$this accessor133"
trace remove variable state {read write unset} "$this accessor136"
trace remove variable x {read write unset} "$this accessor139"
trace remove variable y {read write unset} "$this accessor142"
trace remove variable xrel {read write unset} "$this accessor145"
trace remove variable yrel {read write unset} "$this accessor148"
}
}

::itcl::class {SDL_MouseButtonEvent} {
inherit AObject
public variable type
 method accessor152 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get150} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set151} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable which
 method accessor155 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get153} $this]
               set which $tmp

             } elseif {$op == {write}} {
               return [{c++ set154} $this $which]
             } else { error "Cannot unset C++ variable which" }
           }

public variable button
 method accessor158 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get156} $this]
               set button $tmp

             } elseif {$op == {write}} {
               return [{c++ set157} $this $button]
             } else { error "Cannot unset C++ variable button" }
           }

public variable state
 method accessor161 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get159} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set160} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor164 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get162} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set163} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor167 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get165} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set166} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor152"
set which {}
            trace add variable which {read write unset} "$this accessor155"
set button {}
            trace add variable button {read write unset} "$this accessor158"
set state {}
            trace add variable state {read write unset} "$this accessor161"
set x {}
            trace add variable x {read write unset} "$this accessor164"
set y {}
            trace add variable y {read write unset} "$this accessor167"
}
destructor {
trace remove variable type {read write unset} "$this accessor152"
trace remove variable which {read write unset} "$this accessor155"
trace remove variable button {read write unset} "$this accessor158"
trace remove variable state {read write unset} "$this accessor161"
trace remove variable x {read write unset} "$this accessor164"
trace remove variable y {read write unset} "$this accessor167"
}
}

proc {SDL_GetKeyName} { a0  } {set retpi [uplevel 1 [list {c++ trampoline168} $a0 ]]
set ret $retpi
return $ret
}
proc {SDL_WarpMouse} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline170} $a0 $a1 ]]
return $retpi
}
proc {SDL_GetTicks} {  } {set retpi [uplevel 1 [list {c++ trampoline172} ]]
set ret $retpi
return $ret
}

 proc accessor175 {ignored ignored op} {
             global preliminaryRunMode
             if {$op == {read}} {
               set tmp [{c++ get174} ]
               set preliminaryRunMode $tmp

             } elseif {$op == {write}} {
               error "Cannot write to preliminaryRunMode"
             } else { error "Cannot unset C++ variable preliminaryRunMode" }
           }

 proc accessor177 {ignored ignored op} {
             global THIS_GL_TYPE
             if {$op == {read}} {
               set tmp [{c++ get176} ]
               set THIS_GL_TYPE $tmp

             } elseif {$op == {write}} {
               error "Cannot write to THIS_GL_TYPE"
             } else { error "Cannot unset C++ variable THIS_GL_TYPE" }
           }

 proc accessor180 {ignored ignored op} {
             global recommendedGLType
             if {$op == {read}} {
               set tmp [{c++ get178} ]
               set recommendedGLType $tmp

             } elseif {$op == {write}} {
               return [{c++ set179}  $recommendedGLType]
             } else { error "Cannot unset C++ variable recommendedGLType" }
           }

proc {exitPreliminaryRunMode} {  } {set retpi [uplevel 1 [list {c++ trampoline181} ]]
return $retpi
}

::itcl::class {Font} {
inherit AObject
namespace eval :: {
proc {c++ new Font default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline184} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}


method {charWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline186} $this $a0 ]]
set ret $retpi
return $ret
}
method {width} { a0  } {set retpi [uplevel 1 [list {c++ trampoline188} $this $a0 ]]
set ret $retpi
return $ret
}
method {getHeight} {  } {set retpi [uplevel 1 [list {c++ trampoline190} $this ]]
set ret $retpi
return $ret
}
method {getRise} {  } {set retpi [uplevel 1 [list {c++ trampoline192} $this ]]
set ret $retpi
return $ret
}
method {getDip} {  } {set retpi [uplevel 1 [list {c++ trampoline194} $this ]]
set ret $retpi
return $ret
}
method {preDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline196} $this ]]
return $retpi
}
method {postDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline198} $this ]]
return $retpi
}
method {drawCh} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline200} $this $a0 $a1 $a2 ]]
return $retpi
}
method {drawStr} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline202} $this $a0 $a1 $a2 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {











}
destructor {











}
}

 proc accessor205 {ignored ignored op} {
             global sysfont
             if {$op == {read}} {
               set tmp [{c++ get204} ]
               set sysfont $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfont"
             } else { error "Cannot unset C++ variable sysfont" }
           }

 proc accessor207 {ignored ignored op} {
             global sysfontStipple
             if {$op == {read}} {
               set tmp [{c++ get206} ]
               set sysfontStipple $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfontStipple"
             } else { error "Cannot unset C++ variable sysfontStipple" }
           }

::itcl::class {GameState} {
inherit AObject
namespace eval :: {
proc {c++ new TclGameState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline209} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {configureGL} {  } {set retpi [uplevel 1 [list {c++ deftramp216} $this ]]
return $retpi
}
method {keyboard} { a0  } {set retpi [uplevel 1 [list {c++ deftramp218} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ deftramp220} $this $a0 ]]
return $retpi
}
method {mouseButton} { a0  } {set retpi [uplevel 1 [list {c++ deftramp222} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {InitState} {
inherit GameState
namespace eval :: {
proc {c++ new InitState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline224} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


 proc accessor228 {ignored ignored op} {
             global gameClass
             if {$op == {read}} {
               set tmp [{c++ get226} ]
               set gameClass $tmp

             } elseif {$op == {write}} {
               return [{c++ set227}  $gameClass]
             } else { error "Cannot unset C++ variable gameClass" }
           }

 proc accessor231 {ignored ignored op} {
             global humanShip
             if {$op == {read}} {
               set tmp [{c++ get229} ]
               set humanShip $tmp

             } elseif {$op == {write}} {
               return [{c++ set230}  $humanShip]
             } else { error "Cannot unset C++ variable humanShip" }
           }

 proc accessor234 {ignored ignored op} {
             global testStateMode
             if {$op == {read}} {
               set tmp [{c++ get232} ]
               set testStateMode $tmp

             } elseif {$op == {write}} {
               return [{c++ set233}  $testStateMode]
             } else { error "Cannot unset C++ variable testStateMode" }
           }

 proc accessor237 {ignored ignored op} {
             global testStateSize
             if {$op == {read}} {
               set tmp [{c++ get235} ]
               set testStateSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set236}  $testStateSize]
             } else { error "Cannot unset C++ variable testStateSize" }
           }

::itcl::class {TestState} {
inherit GameState
namespace eval :: {
proc {c++ new TestState default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline239} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline241} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline243} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}



::itcl::class {GameObject} {
inherit AObject
public variable isRemote
 method accessor248 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get247} $this]
               set isRemote $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isRemote"
             } else { error "Cannot unset C++ variable isRemote" }
           }

public variable isExportable
 method accessor251 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get249} $this]
               set isExportable $tmp

             } elseif {$op == {write}} {
               return [{c++ set250} $this $isExportable]
             } else { error "Cannot unset C++ variable isExportable" }
           }

public variable tag
 method accessor254 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get252} $this]
               set tag $tmp

             } elseif {$op == {write}} {
               return [{c++ set253} $this $tag]
             } else { error "Cannot unset C++ variable tag" }
           }

public variable ignoreNetworkTag
 method accessor257 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get255} $this]
               set ignoreNetworkTag $tmp

             } elseif {$op == {write}} {
               return [{c++ set256} $this $ignoreNetworkTag]
             } else { error "Cannot unset C++ variable ignoreNetworkTag" }
           }

protected variable field
 method accessor259 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get258} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable isDead
 method accessor261 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get260} $this]
               set isDead $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isDead"
             } else { error "Cannot unset C++ variable isDead" }
           }

protected variable x
 method accessor264 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get262} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set263} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

protected variable y
 method accessor267 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get265} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set266} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

protected variable vx
 method accessor270 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get268} $this]
               set vx $tmp

             } elseif {$op == {write}} {
               return [{c++ set269} $this $vx]
             } else { error "Cannot unset C++ variable vx" }
           }

protected variable vy
 method accessor273 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get271} $this]
               set vy $tmp

             } elseif {$op == {write}} {
               return [{c++ set272} $this $vy]
             } else { error "Cannot unset C++ variable vy" }
           }

protected variable includeInCollisionDetection
 method accessor276 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get274} $this]
               set includeInCollisionDetection $tmp

             } elseif {$op == {write}} {
               return [{c++ set275} $this $includeInCollisionDetection]
             } else { error "Cannot unset C++ variable includeInCollisionDetection" }
           }

protected variable classification
 method accessor279 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get277} $this]
               set classification $tmp

             } elseif {$op == {write}} {
               return [{c++ set278} $this $classification]
             } else { error "Cannot unset C++ variable classification" }
           }

protected variable decorative
 method accessor282 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get280} $this]
               set decorative $tmp

             } elseif {$op == {write}} {
               return [{c++ set281} $this $decorative]
             } else { error "Cannot unset C++ variable decorative" }
           }

namespace eval :: {
proc {c++ new TclGameObject default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline283} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject position} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline285} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject velocity} { a0 a1 a2 a3 a4 a5 a6  } {set retpi [uplevel 1 [list {c++ trampoline287} $a0 $a1 $a2 $a3 $a4 $a5 $a6 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {getX} {  } {set retpi [uplevel 1 [list {c++ trampoline293} $this ]]
set ret $retpi
return $ret
}
method {getY} {  } {set retpi [uplevel 1 [list {c++ trampoline295} $this ]]
set ret $retpi
return $ret
}
method {getVX} {  } {set retpi [uplevel 1 [list {c++ trampoline297} $this ]]
set ret $retpi
return $ret
}
method {getVY} {  } {set retpi [uplevel 1 [list {c++ trampoline299} $this ]]
set ret $retpi
return $ret
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline301} $this ]]
set ret $retpi
return $ret
}
method {isDecorative} {  } {set retpi [uplevel 1 [list {c++ trampoline303} $this ]]
set ret $retpi
return $ret
}
method {getClassification} {  } {set retpi [uplevel 1 [list {c++ trampoline305} $this ]]
set ret $retpi
return $ret
}
method {okToDecorate} {  } {set retpi [uplevel 1 [list {c++ trampoline307} $this ]]
return $retpi
}
method {teleport} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp310} $this $a0 $a1 $a2 ]]
return $retpi
}
method {getRotation} {  } {set retpi [uplevel 1 [list {c++ deftramp312} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getRadius"]
set ret $retpi
return $ret
}
method {isCollideable} {  } {set retpi [uplevel 1 [list {c++ deftramp316} $this ]]
set ret $retpi
return $ret
}
method {checkCollision} { a0  } {set retpi [uplevel 1 [list {c++ deftramp318} $this $a0 ]]
set ret $retpi
return $ret
}
method {del} {  } {set retpi [uplevel 1 [list {c++ trampoline319} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set isRemote {}
            trace add variable isRemote {read write unset} "$this accessor248"
set isExportable {}
            trace add variable isExportable {read write unset} "$this accessor251"
set tag {}
            trace add variable tag {read write unset} "$this accessor254"
set ignoreNetworkTag {}
            trace add variable ignoreNetworkTag {read write unset} "$this accessor257"
set field {}
            trace add variable field {read write unset} "$this accessor259"
set isDead {}
            trace add variable isDead {read write unset} "$this accessor261"
set x {}
            trace add variable x {read write unset} "$this accessor264"
set y {}
            trace add variable y {read write unset} "$this accessor267"
set vx {}
            trace add variable vx {read write unset} "$this accessor270"
set vy {}
            trace add variable vy {read write unset} "$this accessor273"
set includeInCollisionDetection {}
            trace add variable includeInCollisionDetection {read write unset} "$this accessor276"
set classification {}
            trace add variable classification {read write unset} "$this accessor279"
set decorative {}
            trace add variable decorative {read write unset} "$this accessor282"



















}
destructor {
trace remove variable isRemote {read write unset} "$this accessor248"
trace remove variable isExportable {read write unset} "$this accessor251"
trace remove variable tag {read write unset} "$this accessor254"
trace remove variable ignoreNetworkTag {read write unset} "$this accessor257"
trace remove variable field {read write unset} "$this accessor259"
trace remove variable isDead {read write unset} "$this accessor261"
trace remove variable x {read write unset} "$this accessor264"
trace remove variable y {read write unset} "$this accessor267"
trace remove variable vx {read write unset} "$this accessor270"
trace remove variable vy {read write unset} "$this accessor273"
trace remove variable includeInCollisionDetection {read write unset} "$this accessor276"
trace remove variable classification {read write unset} "$this accessor279"
trace remove variable decorative {read write unset} "$this accessor282"



















}
}


::itcl::class {GameField} {
inherit AObject
public variable fieldClock
 method accessor324 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get323} $this]
               set fieldClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to fieldClock"
             } else { error "Cannot unset C++ variable fieldClock" }
           }

public variable width
 method accessor327 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get325} $this]
               set width $tmp

             } elseif {$op == {write}} {
               return [{c++ set326} $this $width]
             } else { error "Cannot unset C++ variable width" }
           }

public variable height
 method accessor330 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get328} $this]
               set height $tmp

             } elseif {$op == {write}} {
               return [{c++ set329} $this $height]
             } else { error "Cannot unset C++ variable height" }
           }

public variable effects
 method accessor333 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get331} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set332} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable perfectRadar
 method accessor336 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get334} $this]
               set perfectRadar $tmp

             } elseif {$op == {write}} {
               return [{c++ set335} $this $perfectRadar]
             } else { error "Cannot unset C++ variable perfectRadar" }
           }

namespace eval :: {
proc {c++ new GameField default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline337} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline339} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline341} $this ]]
return $retpi
}
method {at} { a0  } {set retpi [uplevel 1 [list {c++ trampoline343} $this $a0 ]]
set ret $retpi
return $ret
}
method {size} {  } {set retpi [uplevel 1 [list {c++ trampoline345} $this ]]
set ret $retpi
return $ret
}
method {add} { a0  } {set retpi [uplevel 1 [list {c++ trampoline347} $this $a0 ]]
return $retpi
}
method {addBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline349} $this $a0 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline351} $this $a0 ]]
return $retpi
}
method {inject} { a0  } {set retpi [uplevel 1 [list {c++ trampoline353} $this $a0 ]]
return $retpi
}
method {clear} {  } {set retpi [uplevel 1 [list {c++ trampoline355} $this ]]
return $retpi
}
method {updateBoundaries} {  } {set retpi [uplevel 1 [list {c++ trampoline357} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set fieldClock {}
            trace add variable fieldClock {read write unset} "$this accessor324"
set width {}
            trace add variable width {read write unset} "$this accessor327"
set height {}
            trace add variable height {read write unset} "$this accessor330"
set effects {}
            trace add variable effects {read write unset} "$this accessor333"
set perfectRadar {}
            trace add variable perfectRadar {read write unset} "$this accessor336"











}
destructor {
trace remove variable fieldClock {read write unset} "$this accessor324"
trace remove variable width {read write unset} "$this accessor327"
trace remove variable height {read write unset} "$this accessor330"
trace remove variable effects {read write unset} "$this accessor333"
trace remove variable perfectRadar {read write unset} "$this accessor336"











}
}

::itcl::class {Blast} {
inherit GameObject
public variable blame
 method accessor361 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get360} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               error "Cannot write to blame"
             } else { error "Cannot unset C++ variable blame" }
           }

namespace eval :: {
proc {c++ new Blast default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline362} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDirect} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline364} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withSize} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline366} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withADC} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline368} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDecor} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline370} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDamage} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12  } {set retpi [uplevel 1 [list {c++ trampoline372} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast nonDamageCopy} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline374} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline376} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline378} $this ]]
return $retpi
}
method {getFalloff} {  } {set retpi [uplevel 1 [list {c++ trampoline380} $this ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline382} $this ]]
set ret $retpi
return $ret
}
method {getStrengthAt} { a0  } {set retpi [uplevel 1 [list {c++ trampoline384} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrengthUpon} { a0  } {set retpi [uplevel 1 [list {c++ trampoline386} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline388} $this ]]
set ret $retpi
return $ret
}
method {isDirect} {  } {set retpi [uplevel 1 [list {c++ trampoline390} $this ]]
set ret $retpi
return $ret
}
method {causesDamage} {  } {set retpi [uplevel 1 [list {c++ trampoline392} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set blame {}
            trace add variable blame {read write unset} "$this accessor361"
















}
destructor {
trace remove variable blame {read write unset} "$this accessor361"
















}
}

::itcl::class {CellFragment} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline395} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline397} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline399} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {PlasmaFire} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline402} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline404} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline406} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {Explosion} {
inherit GameObject
public variable hungry
 method accessor411 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get409} $this]
               set hungry $tmp

             } elseif {$op == {write}} {
               return [{c++ set410} $this $hungry]
             } else { error "Cannot unset C++ variable hungry" }
           }

namespace eval :: {
proc {c++ new Explosion stationary} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline412} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion velocity} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13  } {set retpi [uplevel 1 [list {c++ trampoline414} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion smeared} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15  } {set retpi [uplevel 1 [list {c++ trampoline416} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 $a15 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion by} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline418} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

method {multiExplosion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline420} $this $a0 ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline422} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline424} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline426} $this ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline428} $this ]]
set ret $retpi
return $ret
}
method {getDensity} {  } {set retpi [uplevel 1 [list {c++ trampoline430} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set hungry {}
            trace add variable hungry {read write unset} "$this accessor411"










}
destructor {
trace remove variable hungry {read write unset} "$this accessor411"










}
}


::itcl::class {OldStyleExplosion} {
inherit GameObject
namespace eval :: {
proc {c++ new OldStyleExplosion default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline433} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline435} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline437} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline439} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {LightTrail} {
inherit GameObject
namespace eval :: {
proc {c++ new LightTrail default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14  } {set retpi [uplevel 1 [list {c++ trampoline442} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline444} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline446} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline448} $this ]]
set ret $retpi
return $ret
}
method {setWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline450} $this $a0 ]]
return $retpi
}
method {emit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline452} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}







itcl::class fun<void:Ship*,bool>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<void:Ship*,bool>::fun_t {} {}
      } {}
    }
::itcl::class {fun<void:Ship*,bool>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<void:Ship*,bool> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline460} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
return $retpi
}
proc {call} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline464} $a0 $a1 $a2 ]]
return $retpi
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline466} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

::itcl::class {radar_t} {
inherit AObject
namespace eval :: {
proc {c++ new radar_t default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline469} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

proc {shipCategoryToInt} { a0  } {set retpi [uplevel 1 [list {c++ trampoline471} $a0 ]]
set ret $retpi
return $ret
}
::itcl::class {Ship} {
inherit GameObject
public variable controller
 method accessor476 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get474} $this]
               set controller $tmp

             } elseif {$op == {write}} {
               return [{c++ set475} $this $controller]
             } else { error "Cannot unset C++ variable controller" }
           }

public variable effects
 method accessor479 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get477} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set478} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable shipExistenceFailure
 method accessor482 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get480} $this]
               set shipExistenceFailure $tmp

             } elseif {$op == {write}} {
               return [{c++ set481} $this $shipExistenceFailure]
             } else { error "Cannot unset C++ variable shipExistenceFailure" }
           }


proc {cellCoord} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline483} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {cellSubCoord} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline485} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}
public variable insignia
 method accessor489 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get487} $this]
               set insignia $tmp

             } elseif {$op == {write}} {
               return [{c++ set488} $this $insignia]
             } else { error "Cannot unset C++ variable insignia" }
           }

public variable blame
 method accessor492 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get490} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               return [{c++ set491} $this $blame]
             } else { error "Cannot unset C++ variable blame" }
           }

public variable score
 method accessor495 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get493} $this]
               set score $tmp

             } elseif {$op == {write}} {
               return [{c++ set494} $this $score]
             } else { error "Cannot unset C++ variable score" }
           }

public variable playerScore
 method accessor498 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get496} $this]
               set playerScore $tmp

             } elseif {$op == {write}} {
               return [{c++ set497} $this $playerScore]
             } else { error "Cannot unset C++ variable playerScore" }
           }

public variable damageMultiplier
 method accessor501 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get499} $this]
               set damageMultiplier $tmp

             } elseif {$op == {write}} {
               return [{c++ set500} $this $damageMultiplier]
             } else { error "Cannot unset C++ variable damageMultiplier" }
           }

public variable diedSpontaneously
 method accessor503 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get502} $this]
               set diedSpontaneously $tmp

             } elseif {$op == {write}} {
               error "Cannot write to diedSpontaneously"
             } else { error "Cannot unset C++ variable diedSpontaneously" }
           }

public variable typeName
 method accessor505 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get504} $this]
               set typeName $tmp

             } elseif {$op == {write}} {
               error "Cannot write to typeName"
             } else { error "Cannot unset C++ variable typeName" }
           }

namespace eval :: {
proc {c++ new Ship default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline506} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}


method {refreshUpdates} {  } {set retpi [uplevel 1 [list {c++ trampoline508} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline510} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline512} $this ]]
return $retpi
}

method {getVRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline514} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline516} $this ]]
set ret $retpi
return $ret
}
method {glSetColour0} {  } {set retpi [uplevel 1 [list {c++ trampoline518} $this ]]
return $retpi
}
method {glSetColour1} { a0  } {set retpi [uplevel 1 [list {c++ trampoline520} $this $a0 ]]
return $retpi
}
method {glSetColour2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline522} $this $a0 $a1 ]]
return $retpi
}
method {setThrust} { a0  } {set retpi [uplevel 1 [list {c++ trampoline524} $this $a0 ]]
return $retpi
}
method {getThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline526} $this ]]
set ret $retpi
return $ret
}
method {getTrueThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline528} $this ]]
set ret $retpi
return $ret
}
method {setThrustOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline530} $this $a0 ]]
return $retpi
}
method {isThrustOn} {  } {set retpi [uplevel 1 [list {c++ trampoline532} $this ]]
set ret $retpi
return $ret
}
method {setBrakeOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline534} $this $a0 ]]
return $retpi
}
method {isBrakeOn} {  } {set retpi [uplevel 1 [list {c++ trampoline536} $this ]]
set ret $retpi
return $ret
}
method {configureEngines} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline538} $this $a0 $a1 $a2 ]]
return $retpi
}
method {configureEngines2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline540} $this $a0 $a1 ]]
return $retpi
}
method {getAcceleration} {  } {set retpi [uplevel 1 [list {c++ trampoline542} $this ]]
set ret $retpi
return $ret
}
method {getRotationRate} {  } {set retpi [uplevel 1 [list {c++ trampoline544} $this ]]
set ret $retpi
return $ret
}
method {getRotationAccel} {  } {set retpi [uplevel 1 [list {c++ trampoline546} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline548} $this ]]
set ret $retpi
return $ret
}
method {getPowerUsagePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline550} $this ]]
set ret $retpi
return $ret
}
method {getPowerSupply} {  } {set retpi [uplevel 1 [list {c++ trampoline552} $this ]]
set ret $retpi
return $ret
}
method {getPowerDrain} {  } {set retpi [uplevel 1 [list {c++ trampoline554} $this ]]
set ret $retpi
return $ret
}
method {getCurrentCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline556} $this ]]
set ret $retpi
return $ret
}
method {getMaximumCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline558} $this ]]
set ret $retpi
return $ret
}
method {getCapacitancePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline560} $this ]]
set ret $retpi
return $ret
}
method {setColour} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline562} $this $a0 $a1 $a2 ]]
return $retpi
}
method {destroyGraphicsInfo} {  } {set retpi [uplevel 1 [list {c++ trampoline564} $this ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline566} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline568} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline570} $this ]]
set ret $retpi
return $ret
}
method {drawPower} { a0  } {set retpi [uplevel 1 [list {c++ trampoline572} $this $a0 ]]
set ret $retpi
return $ret
}
method {getReinforcement} {  } {set retpi [uplevel 1 [list {c++ trampoline574} $this ]]
set ret $retpi
return $ret
}
method {setReinforcement} { a0  } {set retpi [uplevel 1 [list {c++ trampoline576} $this $a0 ]]
return $retpi
}
method {enableSoundEffects} {  } {set retpi [uplevel 1 [list {c++ trampoline578} $this ]]
return $retpi
}

method {hasPower} {  } {set retpi [uplevel 1 [list {c++ trampoline580} $this ]]
set ret $retpi
return $ret
}
method {spontaneouslyDie} {  } {set retpi [uplevel 1 [list {c++ trampoline582} $this ]]
return $retpi
}
method {getCoolingMult} {  } {set retpi [uplevel 1 [list {c++ trampoline584} $this ]]
set ret $retpi
return $ret
}
method {getCellVelocity} { a0  } {set retpi [uplevel 1 [list {c++ trampoline586} $this $a0 ]]
set ret $retpi
return $ret
}

method {spin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline588} $this $a0 ]]
return $retpi
}
method {startTest} {  } {set retpi [uplevel 1 [list {c++ trampoline590} $this ]]
return $retpi
}
method {endTest} {  } {set retpi [uplevel 1 [list {c++ trampoline592} $this ]]
set ret $retpi
return $ret
}

method {applyCollision} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline594} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {cellCount} {  } {set retpi [uplevel 1 [list {c++ trampoline596} $this ]]
set ret $retpi
return $ret
}
method {getRadar} {  } {set retpi [uplevel 1 [list {c++ trampoline598} $this ]]
set ret $retpi
return $ret
}
method {setRadar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline600} $this $a0 ]]
return $retpi
}
method {getDeathAttributions} {  } {set retpi [uplevel 1 [list {c++ trampoline602} $this ]]
set ret $retpi
return $ret
}
method {categorise} {  } {set retpi [uplevel 1 [list {c++ trampoline604} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set controller {}
            trace add variable controller {read write unset} "$this accessor476"
set effects {}
            trace add variable effects {read write unset} "$this accessor479"
set shipExistenceFailure {}
            trace add variable shipExistenceFailure {read write unset} "$this accessor482"



set insignia {}
            trace add variable insignia {read write unset} "$this accessor489"
set blame {}
            trace add variable blame {read write unset} "$this accessor492"
set score {}
            trace add variable score {read write unset} "$this accessor495"
set playerScore {}
            trace add variable playerScore {read write unset} "$this accessor498"
set damageMultiplier {}
            trace add variable damageMultiplier {read write unset} "$this accessor501"
set diedSpontaneously {}
            trace add variable diedSpontaneously {read write unset} "$this accessor503"
set typeName {}
            trace add variable typeName {read write unset} "$this accessor505"























































}
destructor {
trace remove variable controller {read write unset} "$this accessor476"
trace remove variable effects {read write unset} "$this accessor479"
trace remove variable shipExistenceFailure {read write unset} "$this accessor482"



trace remove variable insignia {read write unset} "$this accessor489"
trace remove variable blame {read write unset} "$this accessor492"
trace remove variable score {read write unset} "$this accessor495"
trace remove variable playerScore {read write unset} "$this accessor498"
trace remove variable damageMultiplier {read write unset} "$this accessor501"
trace remove variable diedSpontaneously {read write unset} "$this accessor503"
trace remove variable typeName {read write unset} "$this accessor505"























































}
}

proc {Ship_categorise} { a0  } {set retpi [uplevel 1 [list {c++ trampoline606} $a0 ]]
set ret $retpi
return $ret
}
::itcl::class {ShipImageRenderer} {
inherit AObject
method {renderNext} {  } {set retpi [uplevel 1 [list {c++ trampoline609} $this ]]
set ret $retpi
return $ret
}
method {save} { a0  } {set retpi [uplevel 1 [list {c++ trampoline611} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

proc {ShipImageRenderer_create} { a0  } {set retpi [uplevel 1 [list {c++ trampoline613} $a0 ]]
set ret $retpi
return $ret
}
proc {verify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline615} $a0 ]]
set ret $retpi
return $ret
}
proc {loadShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline617} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {saveShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline619} $a0 $a1 ]]
return $retpi
}

::itcl::class {Shield} {
inherit AObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline622} $this $a0 ]]
return $retpi
}
method {updateDist} {  } {set retpi [uplevel 1 [list {c++ trampoline624} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline626} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline628} $this ]]
set ret $retpi
return $ret
}
method {collideWith} { a0  } {set retpi [uplevel 1 [list {c++ trampoline630} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline632} $this ]]
set ret $retpi
return $ret
}
method {getStability} {  } {set retpi [uplevel 1 [list {c++ trampoline634} $this ]]
set ret $retpi
return $ret
}
method {getShip} {  } {set retpi [uplevel 1 [list {c++ trampoline636} $this ]]
set ret $retpi
return $ret
}
method {drawForHUD} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline638} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {









}
destructor {









}
}


proc {insignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline640} $a0 ]]
set ret $retpi
return $ret
}
proc {clear_insignias} {  } {set retpi [uplevel 1 [list {c++ trampoline642} ]]
return $retpi
}

proc {getAlliance} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline644} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {setAlliance} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline646} $a0 $a1 $a2 ]]
return $retpi
}

::itcl::class {EnergyCharge} {
inherit GameObject
namespace eval :: {
proc {c++ new EnergyCharge default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline649} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp652} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline653} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline655} $this ]]
set ret $retpi
return $ret
}
method {getIntensity} {  } {set retpi [uplevel 1 [list {c++ trampoline657} $this ]]
set ret $retpi
return $ret
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline659} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {MagnetoBomb} {
inherit GameObject
namespace eval :: {
proc {c++ new MagnetoBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline662} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp665} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline666} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline668} $this ]]
set ret $retpi
return $ret
}
method {getPower} {  } {set retpi [uplevel 1 [list {c++ trampoline670} $this ]]
set ret $retpi
return $ret
}
method {simulateFailure} {  } {set retpi [uplevel 1 [list {c++ trampoline672} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {SemiguidedBomb} {
inherit MagnetoBomb
namespace eval :: {
proc {c++ new SemiguidedBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline675} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      MagnetoBomb::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {PlasmaBurst} {
inherit GameObject
namespace eval :: {
proc {c++ new PlasmaBurst default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline678} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp681} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline682} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline684} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline686} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {





}
destructor {





}
}

::itcl::class {MonophasicEnergyPulse} {
inherit GameObject
namespace eval :: {
proc {c++ new MonophasicEnergyPulse default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline689} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Missile} {
inherit GameObject
namespace eval :: {
proc {c++ new Missile default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline692} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {EffectsHandler} {
inherit AObject
namespace eval :: {
proc {c++ new EffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline695} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclEffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline697} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {impact} { a0  } {set retpi [uplevel 1 [list {c++ deftramp700} $this $a0 ]]
return $retpi
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ deftramp702} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

 proc accessor704 {ignored ignored op} {
             global nullEffectsHandler
             if {$op == {read}} {
               set tmp [{c++ get703} ]
               set nullEffectsHandler $tmp

             } elseif {$op == {write}} {
               error "Cannot write to nullEffectsHandler"
             } else { error "Cannot unset C++ variable nullEffectsHandler" }
           }

::itcl::class {Background} {
inherit EffectsHandler
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline706} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline708} $this $a0 ]]
return $retpi
}
method {updateReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline710} $this $a0 $a1 ]]
return $retpi
}
method {repopulate} {  } {set retpi [uplevel 1 [list {c++ trampoline712} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {Planet} {
inherit Background
namespace eval :: {
proc {c++ new Planet default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline715} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {StarField} {
inherit Background
namespace eval :: {
proc {c++ new StarField default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline718} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

proc {initStarLists} {  } {set retpi [uplevel 1 [list {c++ trampoline720} ]]
return $retpi
}

::itcl::class {Nebula} {
inherit Background
namespace eval :: {
proc {c++ new Nebula default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline723} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {setFlowEquation} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline725} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {setPressureEquation} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline727} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
method {setPressureResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline729} $this $a0 ]]
return $retpi
}
method {getPressureResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline731} $this ]]
set ret $retpi
return $ret
}
method {setVelocityResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline733} $this $a0 ]]
return $retpi
}
method {getVelocityResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline735} $this ]]
set ret $retpi
return $ret
}
method {setForceMultiplier} { a0  } {set retpi [uplevel 1 [list {c++ trampoline737} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {








}
destructor {








}
}


::itcl::class {Camera} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new TclCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline740} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

protected variable reference
 method accessor744 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get742} $this]
               set reference $tmp

             } elseif {$op == {write}} {
               return [{c++ set743} $this $reference]
             } else { error "Cannot unset C++ variable reference" }
           }

protected method {doSetup} {  } {set retpi [uplevel 1 error "Call to pure-virtual function doSetup"]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp748} $this $a0 ]]
return $retpi
}
method {drawOverlays} {  } {set retpi [uplevel 1 [list {c++ deftramp750} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ deftramp752} $this ]]
return $retpi
}
method {setup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline753} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set reference {}
            trace add variable reference {read write unset} "$this accessor744"





}
destructor {

trace remove variable reference {read write unset} "$this accessor744"





}
}


::itcl::class {DynamicCamera} {
inherit Camera
namespace eval :: {
proc {c++ new DynamicCamera default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline756} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline758} $this $a0 ]]
return $retpi
}
protected method {doSetup} {  } {set retpi [uplevel 1 [list {c++ trampoline760} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ trampoline762} $this ]]
return $retpi
}
method {getZoom} {  } {set retpi [uplevel 1 [list {c++ trampoline764} $this ]]
set ret $retpi
return $ret
}
method {setZoom} { a0  } {set retpi [uplevel 1 [list {c++ trampoline766} $this $a0 ]]
return $retpi
}
method {getRotateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline768} $this ]]
set ret $retpi
return $ret
}
method {setRotateMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline770} $this $a0 ]]
return $retpi
}
method {getLookAhead} {  } {set retpi [uplevel 1 [list {c++ trampoline772} $this ]]
set ret $retpi
return $ret
}
method {setLookAhead} { a0  } {set retpi [uplevel 1 [list {c++ trampoline774} $this $a0 ]]
return $retpi
}
method {getVisualRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline776} $this ]]
set ret $retpi
return $ret
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline778} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {












}
destructor {












}
}


::itcl::class {FixedCamera} {
inherit Camera
namespace eval :: {
proc {c++ new FixedCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline781} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {Controller} {
inherit AObject
public variable ship
 method accessor785 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get784} $this]
               set ship $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ship"
             } else { error "Cannot unset C++ variable ship" }
           }

namespace eval :: {
proc {c++ new TclController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline786} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
return $retpi
}
method {damage} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp791} $this $a0 $a1 $a2 ]]
return $retpi
}
method {otherShipDied} { a0  } {set retpi [uplevel 1 [list {c++ deftramp793} $this $a0 ]]
return $retpi
}
method {notifyScore} { a0  } {set retpi [uplevel 1 [list {c++ deftramp795} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set ship {}
            trace add variable ship {read write unset} "$this accessor785"





}
destructor {
trace remove variable ship {read write unset} "$this accessor785"





}
}


::itcl::class {HumanController} {
inherit Controller
namespace eval :: {
proc {c++ new HumanController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline797} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline799} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline801} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline803} $this $a0 ]]
return $retpi
}
method {button} { a0  } {set retpi [uplevel 1 [list {c++ trampoline805} $this $a0 ]]
return $retpi
}
method {key} { a0  } {set retpi [uplevel 1 [list {c++ trampoline807} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

 proc accessor810 {ignored ignored op} {
             global isCompositionBufferInUse
             if {$op == {read}} {
               set tmp [{c++ get809} ]
               set isCompositionBufferInUse $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isCompositionBufferInUse"
             } else { error "Cannot unset C++ variable isCompositionBufferInUse" }
           }

 proc accessor813 {ignored ignored op} {
             global compositionBufferPrefix
             if {$op == {read}} {
               set tmp [{c++ get811} ]
               set compositionBufferPrefix $tmp

             } elseif {$op == {write}} {
               return [{c++ set812}  $compositionBufferPrefix]
             } else { error "Cannot unset C++ variable compositionBufferPrefix" }
           }


proc {hc_conf_configure} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline814} $a0 $a1 ]]
return $retpi
}
proc {hc_conf_clear} {  } {set retpi [uplevel 1 [list {c++ trampoline816} ]]
return $retpi
}

::itcl::class {AIControl} {
inherit Controller
namespace eval :: {
proc {c++ new AIControl default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline819} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline821} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {GeneticAI} {
inherit Controller
namespace eval :: {
proc {c++ new GeneticAI default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline824} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline826} $this $a0 ]]
return $retpi
}
public variable species
 method accessor829 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get828} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor831 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get830} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

public variable instance
 method accessor833 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get832} $this]
               set instance $tmp

             } elseif {$op == {write}} {
               error "Cannot write to instance"
             } else { error "Cannot unset C++ variable instance" }
           }

public variable failed
 method accessor835 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get834} $this]
               set failed $tmp

             } elseif {$op == {write}} {
               error "Cannot write to failed"
             } else { error "Cannot unset C++ variable failed" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


set species {}
            trace add variable species {read write unset} "$this accessor829"
set generation {}
            trace add variable generation {read write unset} "$this accessor831"
set instance {}
            trace add variable instance {read write unset} "$this accessor833"
set failed {}
            trace add variable failed {read write unset} "$this accessor835"
}
destructor {


trace remove variable species {read write unset} "$this accessor829"
trace remove variable generation {read write unset} "$this accessor831"
trace remove variable instance {read write unset} "$this accessor833"
trace remove variable failed {read write unset} "$this accessor835"
}
}

proc {calculateGeneticAIFunctionCosts} {  } {set retpi [uplevel 1 [list {c++ trampoline836} ]]
return $retpi
}
::itcl::class {GenAI} {
inherit Controller
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline839} $this $a0 ]]
return $retpi
}
public variable species
 method accessor842 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get841} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor844 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get843} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

method {getScores} {  } {set retpi [uplevel 1 [list {c++ trampoline845} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set species {}
            trace add variable species {read write unset} "$this accessor842"
set generation {}
            trace add variable generation {read write unset} "$this accessor844"

}
destructor {

trace remove variable species {read write unset} "$this accessor842"
trace remove variable generation {read write unset} "$this accessor844"

}
}

proc {GenAI_make} { a0  } {set retpi [uplevel 1 [list {c++ trampoline847} $a0 ]]
set ret $retpi
return $ret
}

::itcl::class {CommonKeyboardClient} {
inherit AObject
namespace eval :: {
proc {c++ new CommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline850} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclCommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline852} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {exit} {  } {set retpi [uplevel 1 [list {c++ deftramp855} $this ]]
return $retpi
}
method {slow} {  } {set retpi [uplevel 1 [list {c++ deftramp857} $this ]]
return $retpi
}
method {fast} {  } {set retpi [uplevel 1 [list {c++ deftramp859} $this ]]
return $retpi
}
method {halt} {  } {set retpi [uplevel 1 [list {c++ deftramp861} $this ]]
return $retpi
}
method {frameXframe} {  } {set retpi [uplevel 1 [list {c++ deftramp863} $this ]]
return $retpi
}
method {statsOn} {  } {set retpi [uplevel 1 [list {c++ deftramp865} $this ]]
return $retpi
}
method {statsOff} {  } {set retpi [uplevel 1 [list {c++ deftramp867} $this ]]
return $retpi
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline868} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {










}
destructor {










}
}


::itcl::class {ForwardingEffectsHandler} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new ForwardingEffectsHandler default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline871} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Spectator} {
inherit GameObject
namespace eval :: {
proc {c++ new Spectator default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline874} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator explicit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline876} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator empty} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline878} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {nextReference} {  } {set retpi [uplevel 1 [list {c++ trampoline880} $this ]]
return $retpi
}
method {requireInsignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline882} $this $a0 ]]
return $retpi
}
method {kill} {  } {set retpi [uplevel 1 [list {c++ trampoline884} $this ]]
return $retpi
}
method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline886} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {GameEnv} {
inherit AObject
namespace eval :: {
proc {c++ new GameEnv customCamera} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline889} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new GameEnv default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline891} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline893} $this ]]
set ret $retpi
return $ret
}
method {setReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline895} $this $a0 $a1 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline897} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline899} $this ]]
return $retpi
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline901} $this ]]
set ret $retpi
return $ret
}
public variable cam
 method accessor905 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get903} $this]
               set cam $tmp

             } elseif {$op == {write}} {
               return [{c++ set904} $this $cam]
             } else { error "Cannot unset C++ variable cam" }
           }

public variable stars
 method accessor908 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get906} $this]
               set stars $tmp

             } elseif {$op == {write}} {
               return [{c++ set907} $this $stars]
             } else { error "Cannot unset C++ variable stars" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







set cam {}
            trace add variable cam {read write unset} "$this accessor905"
set stars {}
            trace add variable stars {read write unset} "$this accessor908"
}
destructor {







trace remove variable cam {read write unset} "$this accessor905"
trace remove variable stars {read write unset} "$this accessor908"
}
}


::itcl::class {Manipulator} {
inherit AObject
namespace eval :: {
proc {c++ new Manipulator default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline910} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} {  } {set retpi [uplevel 1 [list {c++ trampoline912} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline914} $this ]]
return $retpi
}
method {primaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline916} $this $a0 $a1 ]]
return $retpi
}
method {primaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline918} $this $a0 $a1 ]]
return $retpi
}
method {secondaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline920} $this $a0 $a1 ]]
return $retpi
}
method {secondaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline922} $this $a0 $a1 ]]
return $retpi
}
method {scrollUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline924} $this $a0 $a1 ]]
return $retpi
}
method {scrollDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline926} $this $a0 $a1 ]]
return $retpi
}
method {motion} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline928} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
method {resetView} {  } {set retpi [uplevel 1 [list {c++ trampoline930} $this ]]
return $retpi
}
method {pushUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline932} $this ]]
return $retpi
}
method {popUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline934} $this ]]
return $retpi
}
method {commitUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline936} $this ]]
return $retpi
}
method {deactivateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline938} $this ]]
return $retpi
}
method {activateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline940} $this ]]
return $retpi
}
method {addToHistory} {  } {set retpi [uplevel 1 [list {c++ trampoline942} $this ]]
return $retpi
}
method {revertToHistory} { a0  } {set retpi [uplevel 1 [list {c++ trampoline944} $this $a0 ]]
return $retpi
}
method {reloadShip} {  } {set retpi [uplevel 1 [list {c++ trampoline946} $this ]]
set ret $retpi
return $ret
}
method {deleteShip} {  } {set retpi [uplevel 1 [list {c++ trampoline948} $this ]]
return $retpi
}
method {copyMounts} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline950} $this $a0 $a1 ]]
return $retpi
}
method {getCellAt} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline952} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






















}
destructor {






















}
}


 proc accessor955 {ignored ignored op} {
             global planetgen_width
             if {$op == {read}} {
               set tmp [{c++ get954} ]
               set planetgen_width $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_width"
             } else { error "Cannot unset C++ variable planetgen_width" }
           }

 proc accessor957 {ignored ignored op} {
             global planetgen_height
             if {$op == {read}} {
               set tmp [{c++ get956} ]
               set planetgen_height $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_height"
             } else { error "Cannot unset C++ variable planetgen_height" }
           }

::itcl::class {PlanetGeneratorParms} {
inherit AObject
namespace eval :: {
proc {c++ new PlanetGeneratorParms default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline959} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable seed
 method accessor963 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get961} $this]
               set seed $tmp

             } elseif {$op == {write}} {
               return [{c++ set962} $this $seed]
             } else { error "Cannot unset C++ variable seed" }
           }

public variable continents
 method accessor966 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get964} $this]
               set continents $tmp

             } elseif {$op == {write}} {
               return [{c++ set965} $this $continents]
             } else { error "Cannot unset C++ variable continents" }
           }

public variable largeIslands
 method accessor969 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get967} $this]
               set largeIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set968} $this $largeIslands]
             } else { error "Cannot unset C++ variable largeIslands" }
           }

public variable smallIslands
 method accessor972 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get970} $this]
               set smallIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set971} $this $smallIslands]
             } else { error "Cannot unset C++ variable smallIslands" }
           }

public variable islandGrouping
 method accessor975 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get973} $this]
               set islandGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set974} $this $islandGrouping]
             } else { error "Cannot unset C++ variable islandGrouping" }
           }

public variable landSlope
 method accessor978 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get976} $this]
               set landSlope $tmp

             } elseif {$op == {write}} {
               return [{c++ set977} $this $landSlope]
             } else { error "Cannot unset C++ variable landSlope" }
           }

public variable oceans
 method accessor981 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get979} $this]
               set oceans $tmp

             } elseif {$op == {write}} {
               return [{c++ set980} $this $oceans]
             } else { error "Cannot unset C++ variable oceans" }
           }

public variable seas
 method accessor984 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get982} $this]
               set seas $tmp

             } elseif {$op == {write}} {
               return [{c++ set983} $this $seas]
             } else { error "Cannot unset C++ variable seas" }
           }

public variable lakes
 method accessor987 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get985} $this]
               set lakes $tmp

             } elseif {$op == {write}} {
               return [{c++ set986} $this $lakes]
             } else { error "Cannot unset C++ variable lakes" }
           }

public variable rivers
 method accessor990 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get988} $this]
               set rivers $tmp

             } elseif {$op == {write}} {
               return [{c++ set989} $this $rivers]
             } else { error "Cannot unset C++ variable rivers" }
           }

public variable mountainRanges
 method accessor993 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get991} $this]
               set mountainRanges $tmp

             } elseif {$op == {write}} {
               return [{c++ set992} $this $mountainRanges]
             } else { error "Cannot unset C++ variable mountainRanges" }
           }

public variable mountainSteepness
 method accessor996 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get994} $this]
               set mountainSteepness $tmp

             } elseif {$op == {write}} {
               return [{c++ set995} $this $mountainSteepness]
             } else { error "Cannot unset C++ variable mountainSteepness" }
           }

public variable enormousMountains
 method accessor999 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get997} $this]
               set enormousMountains $tmp

             } elseif {$op == {write}} {
               return [{c++ set998} $this $enormousMountains]
             } else { error "Cannot unset C++ variable enormousMountains" }
           }

public variable craters
 method accessor1002 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1000} $this]
               set craters $tmp

             } elseif {$op == {write}} {
               return [{c++ set1001} $this $craters]
             } else { error "Cannot unset C++ variable craters" }
           }

public variable maxCraterSize
 method accessor1005 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1003} $this]
               set maxCraterSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set1004} $this $maxCraterSize]
             } else { error "Cannot unset C++ variable maxCraterSize" }
           }

public variable equatorTemperature
 method accessor1008 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1006} $this]
               set equatorTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set1007} $this $equatorTemperature]
             } else { error "Cannot unset C++ variable equatorTemperature" }
           }

public variable solarEquator
 method accessor1011 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1009} $this]
               set solarEquator $tmp

             } elseif {$op == {write}} {
               return [{c++ set1010} $this $solarEquator]
             } else { error "Cannot unset C++ variable solarEquator" }
           }

public variable polarTemperature
 method accessor1014 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1012} $this]
               set polarTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set1013} $this $polarTemperature]
             } else { error "Cannot unset C++ variable polarTemperature" }
           }

public variable altitudeTemperatureDelta
 method accessor1017 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1015} $this]
               set altitudeTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set1016} $this $altitudeTemperatureDelta]
             } else { error "Cannot unset C++ variable altitudeTemperatureDelta" }
           }

public variable waterTemperatureDelta
 method accessor1020 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1018} $this]
               set waterTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set1019} $this $waterTemperatureDelta]
             } else { error "Cannot unset C++ variable waterTemperatureDelta" }
           }

public variable freezingPoint
 method accessor1023 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1021} $this]
               set freezingPoint $tmp

             } elseif {$op == {write}} {
               return [{c++ set1022} $this $freezingPoint]
             } else { error "Cannot unset C++ variable freezingPoint" }
           }

public variable humidity
 method accessor1026 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1024} $this]
               set humidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set1025} $this $humidity]
             } else { error "Cannot unset C++ variable humidity" }
           }

public variable vapourTransport
 method accessor1029 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1027} $this]
               set vapourTransport $tmp

             } elseif {$op == {write}} {
               return [{c++ set1028} $this $vapourTransport]
             } else { error "Cannot unset C++ variable vapourTransport" }
           }

public variable mountainBlockage
 method accessor1032 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1030} $this]
               set mountainBlockage $tmp

             } elseif {$op == {write}} {
               return [{c++ set1031} $this $mountainBlockage]
             } else { error "Cannot unset C++ variable mountainBlockage" }
           }

public variable vegitationHumidity
 method accessor1035 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1033} $this]
               set vegitationHumidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set1034} $this $vegitationHumidity]
             } else { error "Cannot unset C++ variable vegitationHumidity" }
           }

public variable cities
 method accessor1038 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1036} $this]
               set cities $tmp

             } elseif {$op == {write}} {
               return [{c++ set1037} $this $cities]
             } else { error "Cannot unset C++ variable cities" }
           }

public variable maxCitySize
 method accessor1041 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1039} $this]
               set maxCitySize $tmp

             } elseif {$op == {write}} {
               return [{c++ set1040} $this $maxCitySize]
             } else { error "Cannot unset C++ variable maxCitySize" }
           }

public variable cityGrouping
 method accessor1044 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1042} $this]
               set cityGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set1043} $this $cityGrouping]
             } else { error "Cannot unset C++ variable cityGrouping" }
           }

public variable waterColour
 method accessor1047 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1045} $this]
               set waterColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1046} $this $waterColour]
             } else { error "Cannot unset C++ variable waterColour" }
           }

public variable vegitationColour
 method accessor1050 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1048} $this]
               set vegitationColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1049} $this $vegitationColour]
             } else { error "Cannot unset C++ variable vegitationColour" }
           }

public variable lowerPlanetColour
 method accessor1053 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1051} $this]
               set lowerPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1052} $this $lowerPlanetColour]
             } else { error "Cannot unset C++ variable lowerPlanetColour" }
           }

public variable upperPlanetColour
 method accessor1056 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1054} $this]
               set upperPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1055} $this $upperPlanetColour]
             } else { error "Cannot unset C++ variable upperPlanetColour" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set seed {}
            trace add variable seed {read write unset} "$this accessor963"
set continents {}
            trace add variable continents {read write unset} "$this accessor966"
set largeIslands {}
            trace add variable largeIslands {read write unset} "$this accessor969"
set smallIslands {}
            trace add variable smallIslands {read write unset} "$this accessor972"
set islandGrouping {}
            trace add variable islandGrouping {read write unset} "$this accessor975"
set landSlope {}
            trace add variable landSlope {read write unset} "$this accessor978"
set oceans {}
            trace add variable oceans {read write unset} "$this accessor981"
set seas {}
            trace add variable seas {read write unset} "$this accessor984"
set lakes {}
            trace add variable lakes {read write unset} "$this accessor987"
set rivers {}
            trace add variable rivers {read write unset} "$this accessor990"
set mountainRanges {}
            trace add variable mountainRanges {read write unset} "$this accessor993"
set mountainSteepness {}
            trace add variable mountainSteepness {read write unset} "$this accessor996"
set enormousMountains {}
            trace add variable enormousMountains {read write unset} "$this accessor999"
set craters {}
            trace add variable craters {read write unset} "$this accessor1002"
set maxCraterSize {}
            trace add variable maxCraterSize {read write unset} "$this accessor1005"
set equatorTemperature {}
            trace add variable equatorTemperature {read write unset} "$this accessor1008"
set solarEquator {}
            trace add variable solarEquator {read write unset} "$this accessor1011"
set polarTemperature {}
            trace add variable polarTemperature {read write unset} "$this accessor1014"
set altitudeTemperatureDelta {}
            trace add variable altitudeTemperatureDelta {read write unset} "$this accessor1017"
set waterTemperatureDelta {}
            trace add variable waterTemperatureDelta {read write unset} "$this accessor1020"
set freezingPoint {}
            trace add variable freezingPoint {read write unset} "$this accessor1023"
set humidity {}
            trace add variable humidity {read write unset} "$this accessor1026"
set vapourTransport {}
            trace add variable vapourTransport {read write unset} "$this accessor1029"
set mountainBlockage {}
            trace add variable mountainBlockage {read write unset} "$this accessor1032"
set vegitationHumidity {}
            trace add variable vegitationHumidity {read write unset} "$this accessor1035"
set cities {}
            trace add variable cities {read write unset} "$this accessor1038"
set maxCitySize {}
            trace add variable maxCitySize {read write unset} "$this accessor1041"
set cityGrouping {}
            trace add variable cityGrouping {read write unset} "$this accessor1044"
set waterColour {}
            trace add variable waterColour {read write unset} "$this accessor1047"
set vegitationColour {}
            trace add variable vegitationColour {read write unset} "$this accessor1050"
set lowerPlanetColour {}
            trace add variable lowerPlanetColour {read write unset} "$this accessor1053"
set upperPlanetColour {}
            trace add variable upperPlanetColour {read write unset} "$this accessor1056"
}
destructor {

trace remove variable seed {read write unset} "$this accessor963"
trace remove variable continents {read write unset} "$this accessor966"
trace remove variable largeIslands {read write unset} "$this accessor969"
trace remove variable smallIslands {read write unset} "$this accessor972"
trace remove variable islandGrouping {read write unset} "$this accessor975"
trace remove variable landSlope {read write unset} "$this accessor978"
trace remove variable oceans {read write unset} "$this accessor981"
trace remove variable seas {read write unset} "$this accessor984"
trace remove variable lakes {read write unset} "$this accessor987"
trace remove variable rivers {read write unset} "$this accessor990"
trace remove variable mountainRanges {read write unset} "$this accessor993"
trace remove variable mountainSteepness {read write unset} "$this accessor996"
trace remove variable enormousMountains {read write unset} "$this accessor999"
trace remove variable craters {read write unset} "$this accessor1002"
trace remove variable maxCraterSize {read write unset} "$this accessor1005"
trace remove variable equatorTemperature {read write unset} "$this accessor1008"
trace remove variable solarEquator {read write unset} "$this accessor1011"
trace remove variable polarTemperature {read write unset} "$this accessor1014"
trace remove variable altitudeTemperatureDelta {read write unset} "$this accessor1017"
trace remove variable waterTemperatureDelta {read write unset} "$this accessor1020"
trace remove variable freezingPoint {read write unset} "$this accessor1023"
trace remove variable humidity {read write unset} "$this accessor1026"
trace remove variable vapourTransport {read write unset} "$this accessor1029"
trace remove variable mountainBlockage {read write unset} "$this accessor1032"
trace remove variable vegitationHumidity {read write unset} "$this accessor1035"
trace remove variable cities {read write unset} "$this accessor1038"
trace remove variable maxCitySize {read write unset} "$this accessor1041"
trace remove variable cityGrouping {read write unset} "$this accessor1044"
trace remove variable waterColour {read write unset} "$this accessor1047"
trace remove variable vegitationColour {read write unset} "$this accessor1050"
trace remove variable lowerPlanetColour {read write unset} "$this accessor1053"
trace remove variable upperPlanetColour {read write unset} "$this accessor1056"
}
}

proc {planetgen_begin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1057} $a0 ]]
return $retpi
}
proc {planetgen_what} {  } {set retpi [uplevel 1 [list {c++ trampoline1059} ]]
set ret $retpi
return $ret
}
proc {planetgen_progress} {  } {set retpi [uplevel 1 [list {c++ trampoline1061} ]]
set ret $retpi
return $ret
}
proc {planetgen_done} {  } {set retpi [uplevel 1 [list {c++ trampoline1063} ]]
set ret $retpi
return $ret
}
proc {planetgen_kill} {  } {set retpi [uplevel 1 [list {c++ trampoline1065} ]]
return $retpi
}
proc {planetgen_save} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1067} $a0 $a1 ]]
return $retpi
}

proc {set_hud_message} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1069} $a0 $a1 ]]
return $retpi
}
proc {global_chat_post} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1071} $a0 ]]
return $retpi
}
proc {global_chat_post_local} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1073} $a0 ]]
return $retpi
}
proc {global_chat_post_remote} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1075} $a0 ]]
return $retpi
}
 proc accessor1079 {ignored ignored op} {
             global state
             if {$op == {read}} {
               set tmp [{c++ get1077} ]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set1078}  $state]
             } else { error "Cannot unset C++ variable state" }
           }


 proc accessor1081 {ignored ignored op} {
             global PLATFORM
             if {$op == {read}} {
               set tmp [{c++ get1080} ]
               set PLATFORM $tmp

             } elseif {$op == {write}} {
               error "Cannot write to PLATFORM"
             } else { error "Cannot unset C++ variable PLATFORM" }
           }

 proc accessor1083 {ignored ignored op} {
             global screenW
             if {$op == {read}} {
               set tmp [{c++ get1082} ]
               set screenW $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenW"
             } else { error "Cannot unset C++ variable screenW" }
           }

 proc accessor1085 {ignored ignored op} {
             global screenH
             if {$op == {read}} {
               set tmp [{c++ get1084} ]
               set screenH $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenH"
             } else { error "Cannot unset C++ variable screenH" }
           }

 proc accessor1087 {ignored ignored op} {
             global vheight
             if {$op == {read}} {
               set tmp [{c++ get1086} ]
               set vheight $tmp

             } elseif {$op == {write}} {
               error "Cannot write to vheight"
             } else { error "Cannot unset C++ variable vheight" }
           }

 proc accessor1090 {ignored ignored op} {
             global generalAlphaBlending
             if {$op == {read}} {
               set tmp [{c++ get1088} ]
               set generalAlphaBlending $tmp

             } elseif {$op == {write}} {
               return [{c++ set1089}  $generalAlphaBlending]
             } else { error "Cannot unset C++ variable generalAlphaBlending" }
           }

 proc accessor1093 {ignored ignored op} {
             global alphaBlendingEnabled
             if {$op == {read}} {
               set tmp [{c++ get1091} ]
               set alphaBlendingEnabled $tmp

             } elseif {$op == {write}} {
               return [{c++ set1092}  $alphaBlendingEnabled]
             } else { error "Cannot unset C++ variable alphaBlendingEnabled" }
           }

 proc accessor1096 {ignored ignored op} {
             global smoothScaling
             if {$op == {read}} {
               set tmp [{c++ get1094} ]
               set smoothScaling $tmp

             } elseif {$op == {write}} {
               return [{c++ set1095}  $smoothScaling]
             } else { error "Cannot unset C++ variable smoothScaling" }
           }

 proc accessor1099 {ignored ignored op} {
             global highQuality
             if {$op == {read}} {
               set tmp [{c++ get1097} ]
               set highQuality $tmp

             } elseif {$op == {write}} {
               return [{c++ set1098}  $highQuality]
             } else { error "Cannot unset C++ variable highQuality" }
           }

 proc accessor1102 {ignored ignored op} {
             global antialiasing
             if {$op == {read}} {
               set tmp [{c++ get1100} ]
               set antialiasing $tmp

             } elseif {$op == {write}} {
               return [{c++ set1101}  $antialiasing]
             } else { error "Cannot unset C++ variable antialiasing" }
           }


 proc accessor1104 {ignored ignored op} {
             global headless
             if {$op == {read}} {
               set tmp [{c++ get1103} ]
               set headless $tmp

             } elseif {$op == {write}} {
               error "Cannot write to headless"
             } else { error "Cannot unset C++ variable headless" }
           }

 proc accessor1107 {ignored ignored op} {
             global cameraX1
             if {$op == {read}} {
               set tmp [{c++ get1105} ]
               set cameraX1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1106}  $cameraX1]
             } else { error "Cannot unset C++ variable cameraX1" }
           }

 proc accessor1110 {ignored ignored op} {
             global cameraX2
             if {$op == {read}} {
               set tmp [{c++ get1108} ]
               set cameraX2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1109}  $cameraX2]
             } else { error "Cannot unset C++ variable cameraX2" }
           }

 proc accessor1113 {ignored ignored op} {
             global cameraY1
             if {$op == {read}} {
               set tmp [{c++ get1111} ]
               set cameraY1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1112}  $cameraY1]
             } else { error "Cannot unset C++ variable cameraY1" }
           }

 proc accessor1116 {ignored ignored op} {
             global cameraY2
             if {$op == {read}} {
               set tmp [{c++ get1114} ]
               set cameraY2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1115}  $cameraY2]
             } else { error "Cannot unset C++ variable cameraY2" }
           }

 proc accessor1119 {ignored ignored op} {
             global cameraCX
             if {$op == {read}} {
               set tmp [{c++ get1117} ]
               set cameraCX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1118}  $cameraCX]
             } else { error "Cannot unset C++ variable cameraCX" }
           }

 proc accessor1122 {ignored ignored op} {
             global cameraCY
             if {$op == {read}} {
               set tmp [{c++ get1120} ]
               set cameraCY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1121}  $cameraCY]
             } else { error "Cannot unset C++ variable cameraCY" }
           }

 proc accessor1125 {ignored ignored op} {
             global cameraZoom
             if {$op == {read}} {
               set tmp [{c++ get1123} ]
               set cameraZoom $tmp

             } elseif {$op == {write}} {
               return [{c++ set1124}  $cameraZoom]
             } else { error "Cannot unset C++ variable cameraZoom" }
           }

 proc accessor1128 {ignored ignored op} {
             global cursorX
             if {$op == {read}} {
               set tmp [{c++ get1126} ]
               set cursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1127}  $cursorX]
             } else { error "Cannot unset C++ variable cursorX" }
           }

 proc accessor1131 {ignored ignored op} {
             global cursorY
             if {$op == {read}} {
               set tmp [{c++ get1129} ]
               set cursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1130}  $cursorY]
             } else { error "Cannot unset C++ variable cursorY" }
           }

 proc accessor1134 {ignored ignored op} {
             global oldCursorX
             if {$op == {read}} {
               set tmp [{c++ get1132} ]
               set oldCursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1133}  $oldCursorX]
             } else { error "Cannot unset C++ variable oldCursorX" }
           }

 proc accessor1137 {ignored ignored op} {
             global oldCursorY
             if {$op == {read}} {
               set tmp [{c++ get1135} ]
               set oldCursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1136}  $oldCursorY]
             } else { error "Cannot unset C++ variable oldCursorY" }
           }


 proc accessor1139 {ignored ignored op} {
             global currentFrameTime
             if {$op == {read}} {
               set tmp [{c++ get1138} ]
               set currentFrameTime $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTime"
             } else { error "Cannot unset C++ variable currentFrameTime" }
           }

 proc accessor1141 {ignored ignored op} {
             global currentFrameTimeLeft
             if {$op == {read}} {
               set tmp [{c++ get1140} ]
               set currentFrameTimeLeft $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTimeLeft"
             } else { error "Cannot unset C++ variable currentFrameTimeLeft" }
           }

 proc accessor1143 {ignored ignored op} {
             global currentVFrameLast
             if {$op == {read}} {
               set tmp [{c++ get1142} ]
               set currentVFrameLast $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentVFrameLast"
             } else { error "Cannot unset C++ variable currentVFrameLast" }
           }

 proc accessor1145 {ignored ignored op} {
             global frameRate
             if {$op == {read}} {
               set tmp [{c++ get1144} ]
               set frameRate $tmp

             } elseif {$op == {write}} {
               error "Cannot write to frameRate"
             } else { error "Cannot unset C++ variable frameRate" }
           }

 proc accessor1147 {ignored ignored op} {
             global sparkCountMultiplier
             if {$op == {read}} {
               set tmp [{c++ get1146} ]
               set sparkCountMultiplier $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sparkCountMultiplier"
             } else { error "Cannot unset C++ variable sparkCountMultiplier" }
           }

 proc accessor1149 {ignored ignored op} {
             global gameClock
             if {$op == {read}} {
               set tmp [{c++ get1148} ]
               set gameClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to gameClock"
             } else { error "Cannot unset C++ variable gameClock" }
           }

 proc accessor1151 {ignored ignored op} {
             global STD_CELL_SZ
             if {$op == {read}} {
               set tmp [{c++ get1150} ]
               set STD_CELL_SZ $tmp

             } elseif {$op == {write}} {
               error "Cannot write to STD_CELL_SZ"
             } else { error "Cannot unset C++ variable STD_CELL_SZ" }
           }

::itcl::class {SquareIcon} {
inherit AObject
namespace eval :: {
proc {c++ new SquareIcon default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1153} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {load} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1155} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {unload} {  } {set retpi [uplevel 1 [list {c++ trampoline1157} $this ]]
return $retpi
}
method {isLoaded} {  } {set retpi [uplevel 1 [list {c++ trampoline1159} $this ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline1161} $this ]]
return $retpi
}
method {save} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1163} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}




::itcl::class {Antenna} {
inherit AObject
namespace eval :: {
proc {c++ new Antenna default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1168} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable tuner
 method accessor1172 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1170} $this]
               set tuner $tmp

             } elseif {$op == {write}} {
               return [{c++ set1171} $this $tuner]
             } else { error "Cannot unset C++ variable tuner" }
           }

method {setInternetInformation4} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline1173} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {setInternetInformation6} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline1175} $this $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
return $retpi
}
method {getGlobalID4} {  } {set retpi [uplevel 1 [list {c++ trampoline1177} $this ]]
set ret $retpi
return $ret
}
method {getGlobalID6} {  } {set retpi [uplevel 1 [list {c++ trampoline1179} $this ]]
set ret $retpi
return $ret
}
method {hasV4} {  } {set retpi [uplevel 1 [list {c++ trampoline1181} $this ]]
set ret $retpi
return $ret
}
method {hasV6} {  } {set retpi [uplevel 1 [list {c++ trampoline1183} $this ]]
set ret $retpi
return $ret
}
method {processIncomming} {  } {set retpi [uplevel 1 [list {c++ trampoline1185} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set tuner {}
            trace add variable tuner {read write unset} "$this accessor1172"







}
destructor {

trace remove variable tuner {read write unset} "$this accessor1172"







}
}

 proc accessor1188 {ignored ignored op} {
             global antenna
             if {$op == {read}} {
               set tmp [{c++ get1187} ]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

 proc accessor1191 {ignored ignored op} {
             global packetDropMask
             if {$op == {read}} {
               set tmp [{c++ get1189} ]
               set packetDropMask $tmp

             } elseif {$op == {write}} {
               return [{c++ set1190}  $packetDropMask]
             } else { error "Cannot unset C++ variable packetDropMask" }
           }


::itcl::class {Tuner} {
inherit AObject
namespace eval :: {
proc {c++ new Tuner default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1193} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {GlobalID} {
inherit AObject
namespace eval :: {
proc {c++ new GlobalID default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1196} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {toString} {  } {set retpi [uplevel 1 [list {c++ trampoline1198} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {PacketProcessor} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}



::itcl::class {NetworkAssembly} {
inherit AObject
public variable field
 method accessor1204 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1203} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable antenna
 method accessor1206 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1205} $this]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

namespace eval :: {
proc {c++ new NetworkAssembly default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1207} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getTuner} {  } {set retpi [uplevel 1 [list {c++ trampoline1209} $this ]]
set ret $retpi
return $ret
}
method {numConnections} {  } {set retpi [uplevel 1 [list {c++ trampoline1211} $this ]]
set ret $retpi
return $ret
}
method {getConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1213} $this $a0 ]]
set ret $retpi
return $ret
}
method {addConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1215} $this $a0 ]]
return $retpi
}
method {removeConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1217} $this $a0 ]]
return $retpi
}
method {addPacketProcessor} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1219} $this $a0 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1221} $this $a0 ]]
return $retpi
}
method {setFieldSize} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1223} $this $a0 $a1 ]]
return $retpi
}
method {changeField} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1225} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set field {}
            trace add variable field {read write unset} "$this accessor1204"
set antenna {}
            trace add variable antenna {read write unset} "$this accessor1206"










}
destructor {
trace remove variable field {read write unset} "$this accessor1204"
trace remove variable antenna {read write unset} "$this accessor1206"










}
}



::itcl::class {NetworkConnection} {
inherit PacketProcessor
public variable parent
 method accessor1230 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1229} $this]
               set parent $tmp

             } elseif {$op == {write}} {
               error "Cannot write to parent"
             } else { error "Cannot unset C++ variable parent" }
           }

public variable scg
 method accessor1232 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1231} $this]
               set scg $tmp

             } elseif {$op == {write}} {
               error "Cannot write to scg"
             } else { error "Cannot unset C++ variable scg" }
           }

public variable blameMask
 method accessor1235 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1233} $this]
               set blameMask $tmp

             } elseif {$op == {write}} {
               return [{c++ set1234} $this $blameMask]
             } else { error "Cannot unset C++ variable blameMask" }
           }

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1236} $this $a0 ]]
return $retpi
}
method {getStatus} {  } {set retpi [uplevel 1 [list {c++ trampoline1238} $this ]]
set ret $retpi
return $ret
}
method {getDisconnectReason} {  } {set retpi [uplevel 1 [list {c++ trampoline1240} $this ]]
set ret $retpi
return $ret
}
method {setFieldSize} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1242} $this $a0 $a1 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set parent {}
            trace add variable parent {read write unset} "$this accessor1230"
set scg {}
            trace add variable scg {read write unset} "$this accessor1232"
set blameMask {}
            trace add variable blameMask {read write unset} "$this accessor1235"




}
destructor {
trace remove variable parent {read write unset} "$this accessor1230"
trace remove variable scg {read write unset} "$this accessor1232"
trace remove variable blameMask {read write unset} "$this accessor1235"




}
}


::itcl::class {ConnectionListener} {
inherit PacketProcessor
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}


::itcl::class {InputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

::itcl::class {OutputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

itcl::class fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {} {}
      } {}
    }
::itcl::class {fun<InputNetworkGeraet*:NetworkConnection*>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<InputNetworkGeraet*:NetworkConnection*> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1248} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
set ret $retpi
return $ret
}
proc {call} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1252} $a0 $a1 ]]
set ret $retpi
return $ret
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline1254} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {SynchronousControlGeraet} {
inherit AObject
method {openChannel} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1257} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {GameAdvertiser} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameAdvertiser default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline1260} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {setOverseerId} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1262} $this $a0 ]]
return $retpi
}
method {setPeerCount} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1264} $this $a0 ]]
return $retpi
}
method {setGameMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1266} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {GameDiscoverer} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameDiscoverer default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1269} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {start} {  } {set retpi [uplevel 1 [list {c++ trampoline1271} $this ]]
return $retpi
}
method {poll} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1273} $this $a0 ]]
return $retpi
}
method {progress} {  } {set retpi [uplevel 1 [list {c++ trampoline1275} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}




::itcl::class {SeqTextOutputGeraet} {
inherit OutputNetworkGeraet
namespace eval :: {
proc {c++ new SeqTextOutputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1279} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {send} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1281} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      OutputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

::itcl::class {SeqTextInputGeraet} {
inherit InputNetworkGeraet
namespace eval :: {
proc {c++ new TclSeqTextInputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1284} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {receiveText} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveText"]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      InputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {Peer} {
inherit AObject
public variable gid
 method accessor1290 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1289} $this]
               set gid $tmp

             } elseif {$op == {write}} {
               error "Cannot write to gid"
             } else { error "Cannot unset C++ variable gid" }
           }

public variable nid
 method accessor1292 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1291} $this]
               set nid $tmp

             } elseif {$op == {write}} {
               error "Cannot write to nid"
             } else { error "Cannot unset C++ variable nid" }
           }

public variable overseerReady
 method accessor1294 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1293} $this]
               set overseerReady $tmp

             } elseif {$op == {write}} {
               error "Cannot write to overseerReady"
             } else { error "Cannot unset C++ variable overseerReady" }
           }

public variable connectionAttempts
 method accessor1296 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1295} $this]
               set connectionAttempts $tmp

             } elseif {$op == {write}} {
               error "Cannot write to connectionAttempts"
             } else { error "Cannot unset C++ variable connectionAttempts" }
           }

public variable cxn
 method accessor1298 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1297} $this]
               set cxn $tmp

             } elseif {$op == {write}} {
               error "Cannot write to cxn"
             } else { error "Cannot unset C++ variable cxn" }
           }

public variable screenName
 method accessor1300 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1299} $this]
               set screenName $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenName"
             } else { error "Cannot unset C++ variable screenName" }
           }

public variable receivedStx
 method accessor1302 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1301} $this]
               set receivedStx $tmp

             } elseif {$op == {write}} {
               error "Cannot write to receivedStx"
             } else { error "Cannot unset C++ variable receivedStx" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set gid {}
            trace add variable gid {read write unset} "$this accessor1290"
set nid {}
            trace add variable nid {read write unset} "$this accessor1292"
set overseerReady {}
            trace add variable overseerReady {read write unset} "$this accessor1294"
set connectionAttempts {}
            trace add variable connectionAttempts {read write unset} "$this accessor1296"
set cxn {}
            trace add variable cxn {read write unset} "$this accessor1298"
set screenName {}
            trace add variable screenName {read write unset} "$this accessor1300"
set receivedStx {}
            trace add variable receivedStx {read write unset} "$this accessor1302"
}
destructor {
trace remove variable gid {read write unset} "$this accessor1290"
trace remove variable nid {read write unset} "$this accessor1292"
trace remove variable overseerReady {read write unset} "$this accessor1294"
trace remove variable connectionAttempts {read write unset} "$this accessor1296"
trace remove variable cxn {read write unset} "$this accessor1298"
trace remove variable screenName {read write unset} "$this accessor1300"
trace remove variable receivedStx {read write unset} "$this accessor1302"
}
}

::itcl::class {NetIface} {
inherit AObject
namespace eval :: {
proc {c++ new TclNetIface default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1304} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {addPeer} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function addPeer"]
return $retpi
}
method {delPeer} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function delPeer"]
return $retpi
}
method {setOverseer} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function setOverseer"]
return $retpi
}
method {receiveBroadcast} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveBroadcast"]
return $retpi
}
method {receiveOverseer} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveOverseer"]
return $retpi
}
method {receiveUnicast} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveUnicast"]
return $retpi
}
method {alterDatp} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function alterDatp"]
set ret $retpi
return $ret
}
method {alterDats} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function alterDats"]
set ret $retpi
return $ret
}
method {setGameMode} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function setGameMode"]
return $retpi
}
method {getGameMode} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getGameMode"]
set ret $retpi
return $ret
}
method {connectionLost} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function connectionLost"]
return $retpi
}
method {getFullDats} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getFullDats"]
set ret $retpi
return $ret
}
method {receiveShip} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveShip"]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {














}
destructor {














}
}

::itcl::class {NetworkGame} {
inherit AObject
namespace eval :: {
proc {c++ new NetworkGame default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1333} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {getLocalPeer} {  } {set retpi [uplevel 1 [list {c++ trampoline1335} $this ]]
set ret $retpi
return $ret
}
method {getOverseer} {  } {set retpi [uplevel 1 [list {c++ trampoline1337} $this ]]
set ret $retpi
return $ret
}
method {getPeerByConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1339} $this $a0 ]]
set ret $retpi
return $ret
}
method {getDisconnectReason} {  } {set retpi [uplevel 1 [list {c++ trampoline1341} $this ]]
set ret $retpi
return $ret
}
method {setNetIface} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1343} $this $a0 ]]
return $retpi
}
method {setAdvertising} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1345} $this $a0 ]]
return $retpi
}
method {stopAdvertising} {  } {set retpi [uplevel 1 [list {c++ trampoline1347} $this ]]
return $retpi
}
method {startDiscoveryScan} {  } {set retpi [uplevel 1 [list {c++ trampoline1349} $this ]]
return $retpi
}
method {discoveryScanProgress} {  } {set retpi [uplevel 1 [list {c++ trampoline1351} $this ]]
set ret $retpi
return $ret
}
method {discoveryScanDone} {  } {set retpi [uplevel 1 [list {c++ trampoline1353} $this ]]
set ret $retpi
return $ret
}
method {getDiscoveryResults} {  } {set retpi [uplevel 1 [list {c++ trampoline1355} $this ]]
set ret $retpi
return $ret
}
method {setLocalPeerName} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1357} $this $a0 ]]
return $retpi
}
method {setLocalPeerNID} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1359} $this $a0 ]]
return $retpi
}
method {setLocalPeerNIDAuto} {  } {set retpi [uplevel 1 [list {c++ trampoline1361} $this ]]
return $retpi
}
method {connectToNothing} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1363} $this $a0 $a1 ]]
return $retpi
}
method {connectToDiscovery} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1365} $this $a0 ]]
return $retpi
}
method {connectToLan} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1367} $this $a0 $a1 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1369} $this $a0 ]]
return $retpi
}
method {updateFieldSize} {  } {set retpi [uplevel 1 [list {c++ trampoline1371} $this ]]
return $retpi
}
method {changeField} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1373} $this $a0 ]]
return $retpi
}
method {alterDats} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1375} $this $a0 $a1 ]]
return $retpi
}
method {alterDatp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1377} $this $a0 $a1 ]]
return $retpi
}
method {sendUnicast} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1379} $this $a0 $a1 ]]
return $retpi
}
method {sendOverseer} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1381} $this $a0 $a1 ]]
return $retpi
}
method {sendBroadcast} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1383} $this $a0 ]]
return $retpi
}
method {sendGameMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1385} $this $a0 ]]
return $retpi
}
method {setBlameMask} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1387} $this $a0 $a1 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




























}
destructor {




























}
}


::itcl::class {ConfReg} {
inherit AObject
method {open} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1390} $this $a0 $a1 ]]
return $retpi
}
method {openLazily} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1392} $this $a0 $a1 ]]
return $retpi
}
method {create} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1394} $this $a0 $a1 ]]
return $retpi
}
method {close} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1396} $this $a0 ]]
return $retpi
}
method {closeAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1398} $this ]]
return $retpi
}
method {modify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1400} $this $a0 ]]
return $retpi
}
method {unmodify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1402} $this $a0 ]]
return $retpi
}
method {sync} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1404} $this $a0 ]]
return $retpi
}
method {syncAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1406} $this ]]
return $retpi
}
method {revert} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1408} $this $a0 ]]
return $retpi
}
method {revertAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1410} $this ]]
return $retpi
}
method {addToWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1412} $this $a0 ]]
return $retpi
}
method {removeFromWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1414} $this $a0 ]]
return $retpi
}
method {clearWhitelist} {  } {set retpi [uplevel 1 [list {c++ trampoline1416} $this ]]
return $retpi
}
method {setWhitelistOnly} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1418} $this $a0 ]]
return $retpi
}
method {renameFile} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1420} $this $a0 $a1 ]]
return $retpi
}

method {exists} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1422} $this $a0 ]]
set ret $retpi
return $ret
}
method {loaded} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1424} $this $a0 ]]
set ret $retpi
return $ret
}
method {bool} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1426} $this $a0 ]]
set ret $retpi
return $ret
}
method {int} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1428} $this $a0 ]]
set ret $retpi
return $ret
}
method {float} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1430} $this $a0 ]]
set ret $retpi
return $ret
}
method {str} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1432} $this $a0 ]]
set ret $retpi
return $ret
}
method {setb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1434} $this $a0 $a1 ]]
return $retpi
}
method {seti} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1436} $this $a0 $a1 ]]
return $retpi
}
method {setf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1438} $this $a0 $a1 ]]
return $retpi
}
method {sets} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1440} $this $a0 $a1 ]]
return $retpi
}
method {add} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1442} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addb} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1444} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addi} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1446} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addf} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1448} $this $a0 $a1 $a2 ]]
return $retpi
}
method {adds} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1450} $this $a0 $a1 $a2 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1452} $this $a0 ]]
return $retpi
}
method {append} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1454} $this $a0 $a1 ]]
return $retpi
}
method {appendb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1456} $this $a0 $a1 ]]
return $retpi
}
method {appendi} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1458} $this $a0 $a1 ]]
return $retpi
}
method {appendf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1460} $this $a0 $a1 ]]
return $retpi
}
method {appends} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1462} $this $a0 $a1 ]]
return $retpi
}
method {remix} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1464} $this $a0 $a1 ]]
return $retpi
}
method {name} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1466} $this $a0 ]]
set ret $retpi
return $ret
}
method {copy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1468} $this $a0 $a1 ]]
return $retpi
}
method {getType} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1470} $this $a0 ]]
set ret $retpi
return $ret
}
method {length} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1472} $this $a0 ]]
set ret $retpi
return $ret
}
method {isGroup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1474} $this $a0 ]]
set ret $retpi
return $ret
}
method {isArray} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1476} $this $a0 ]]
set ret $retpi
return $ret
}
method {isList} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1478} $this $a0 ]]
set ret $retpi
return $ret
}
method {isAggregate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1480} $this $a0 ]]
set ret $retpi
return $ret
}
method {isScalar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1482} $this $a0 ]]
set ret $retpi
return $ret
}
method {isNumber} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1484} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSourceLine} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1486} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


















































}
destructor {


















































}
}

 proc accessor1489 {ignored ignored op} {
             global globalConf
             if {$op == {read}} {
               set tmp [{c++ get1488} ]
               set globalConf $tmp

             } elseif {$op == {write}} {
               error "Cannot write to globalConf"
             } else { error "Cannot unset C++ variable globalConf" }
           }

proc {confcpy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1490} $a0 $a1 ]]
return $retpi
}
proc {l10n_acceptLanguage} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1492} $a0 ]]
return $retpi
}
proc {l10n_loadCatalogue} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1494} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {l10n_purgeCatalogue} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1496} $a0 ]]
return $retpi
}

proc {_} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1498} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
proc {namegenAny} {  } {set retpi [uplevel 1 [list {c++ trampoline1500} ]]
set ret $retpi
return $ret
}
proc {namegenGet} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1502} $a0 ]]
set ret $retpi
return $ret
}
proc {newInterpreter} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1504} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {delInterpreter} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1506} $a0 ]]
return $retpi
}

proc {safe_source} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1508} $a0 ]]
return $retpi
}
proc {bkg_start} {  } {set retpi [uplevel 1 [list {c++ trampoline1510} ]]
return $retpi
}
proc {bkg_req} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1512} $a0 ]]
return $retpi
}
proc {bkg_ans} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1514} $a0 ]]
return $retpi
}
proc {bkg_req2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1516} $a0 $a1 ]]
return $retpi
}
proc {bkg_ans2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1518} $a0 $a1 ]]
return $retpi
}
proc {bkg_rcv} {  } {set retpi [uplevel 1 [list {c++ trampoline1520} ]]
set ret $retpi
return $ret
}
proc {bkg_get} {  } {set retpi [uplevel 1 [list {c++ trampoline1522} ]]
set ret $retpi
return $ret
}
proc {bkg_wait} {  } {set retpi [uplevel 1 [list {c++ trampoline1524} ]]
return $retpi
}

proc {crypto_init} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1526} $a0 ]]
return $retpi
}
proc {crypto_rand} {  } {set retpi [uplevel 1 [list {c++ trampoline1528} ]]
set ret $retpi
return $ret
}
proc {crypto_powm} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1530} $a0 $a1 ]]
set ret $retpi
return $ret
}

proc {performValidation} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1532} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {getValidationResultA} {  } {set retpi [uplevel 1 [list {c++ trampoline1534} ]]
set ret $retpi
return $ret
}
proc {getValidationResultB} {  } {set retpi [uplevel 1 [list {c++ trampoline1536} ]]
set ret $retpi
return $ret
}

::itcl::class {NetworkTest} {
inherit TestState
namespace eval :: {
proc {c++ new NetworkTest default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1539} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      TestState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


proc {ship_mixer_init} {  } {set retpi [uplevel 1 [list {c++ trampoline1541} ]]
return $retpi
}
proc {ship_mixer_end} {  } {set retpi [uplevel 1 [list {c++ trampoline1543} ]]
return $retpi
}

proc {joystick_count} {  } {set retpi [uplevel 1 [list {c++ trampoline1545} ]]
set ret $retpi
return $ret
}
proc {joystick_name} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1547} $a0 ]]
set ret $retpi
return $ret
}
proc {joystick_axisCount} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1549} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {joystick_buttonCount} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1551} $a0 $a1 ]]
set ret $retpi
return $ret
}

::itcl::class {VersusMatch} {
inherit AObject
method {step} {  } {set retpi [uplevel 1 [list {c++ trampoline1554} $this ]]
set ret $retpi
return $ret
}
method {score} {  } {set retpi [uplevel 1 [list {c++ trampoline1556} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

proc {VersusMatch_create} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1558} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}
proc {frame_recorder_enable} {  } {set retpi [uplevel 1 [list {c++ trampoline1560} ]]
return $retpi
}
proc {frame_recorder_setFrameRate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1562} $a0 ]]
return $retpi
}

proc {debugTclExports} {  } {set retpi [uplevel 1 [list {c++ trampoline1564} ]]
return $retpi
}































set SDLK_LAST {}
trace add variable SDLK_LAST {read write unset} accessor60

set none {}
trace add variable none {read write unset} accessor64
set lshift {}
trace add variable lshift {read write unset} accessor66
set rshift {}
trace add variable rshift {read write unset} accessor68
set lctrl {}
trace add variable lctrl {read write unset} accessor70
set rctrl {}
trace add variable rctrl {read write unset} accessor72
set lalt {}
trace add variable lalt {read write unset} accessor74
set ralt {}
trace add variable ralt {read write unset} accessor76
set lmeta {}
trace add variable lmeta {read write unset} accessor78
set rmeta {}
trace add variable rmeta {read write unset} accessor80
set num {}
trace add variable num {read write unset} accessor82
set caps {}
trace add variable caps {read write unset} accessor84
set mode {}
trace add variable mode {read write unset} accessor86
set reserved {}
trace add variable reserved {read write unset} accessor88
set glueClass(SDL_keysym) yes





set glueClass(SDL_KeyboardEvent) yes




set SDL_BUTTON_1 {}
trace add variable SDL_BUTTON_1 {read write unset} accessor113
set SDL_BUTTON_2 {}
trace add variable SDL_BUTTON_2 {read write unset} accessor115
set SDL_BUTTON_3 {}
trace add variable SDL_BUTTON_3 {read write unset} accessor117
set SDL_BUTTON_4 {}
trace add variable SDL_BUTTON_4 {read write unset} accessor119
set SDL_BUTTON_5 {}
trace add variable SDL_BUTTON_5 {read write unset} accessor121

set SDL_DEFAULT_REPEAT_INTERVAL {}
trace add variable SDL_DEFAULT_REPEAT_INTERVAL {read write unset} accessor125
set SDL_DEFAULT_REPEAT_DELAY {}
trace add variable SDL_DEFAULT_REPEAT_DELAY {read write unset} accessor127


set glueClass(SDL_MouseMotionEvent) yes







set glueClass(SDL_MouseButtonEvent) yes











set preliminaryRunMode {}
trace add variable preliminaryRunMode {read write unset} accessor175
set THIS_GL_TYPE {}
trace add variable THIS_GL_TYPE {read write unset} accessor177
set recommendedGLType {}
trace add variable recommendedGLType {read write unset} accessor180


set glueClass(Font) yes












set sysfont {}
trace add variable sysfont {read write unset} accessor205
set sysfontStipple {}
trace add variable sysfontStipple {read write unset} accessor207
set glueClass(GameState) yes








set glueClass(InitState) yes



set gameClass {}
trace add variable gameClass {read write unset} accessor228
set humanShip {}
trace add variable humanShip {read write unset} accessor231
set testStateMode {}
trace add variable testStateMode {read write unset} accessor234
set testStateSize {}
trace add variable testStateSize {read write unset} accessor237
set glueClass(TestState) yes






set glueClass(GameObject) yes


































set glueClass(GameField) yes

















set glueClass(Blast) yes


















set glueClass(CellFragment) yes




set glueClass(PlasmaFire) yes




set glueClass(Explosion) yes













set glueClass(OldStyleExplosion) yes






set glueClass(LightTrail) yes














set glueClass(fun<void:Ship*,bool>) yes





set glueClass(radar_t) yes



set glueClass(Ship) yes






































































set glueClass(ShipImageRenderer) yes








set glueClass(Shield) yes

















set glueClass(EnergyCharge) yes







set glueClass(MagnetoBomb) yes







set glueClass(SemiguidedBomb) yes


set glueClass(PlasmaBurst) yes






set glueClass(MonophasicEnergyPulse) yes


set glueClass(Missile) yes


set glueClass(EffectsHandler) yes





set nullEffectsHandler {}
trace add variable nullEffectsHandler {read write unset} accessor704
set glueClass(Background) yes






set glueClass(Planet) yes



set glueClass(StarField) yes




set glueClass(Nebula) yes










set glueClass(Camera) yes









set glueClass(DynamicCamera) yes














set glueClass(FixedCamera) yes



set glueClass(Controller) yes








set glueClass(HumanController) yes







set isCompositionBufferInUse {}
trace add variable isCompositionBufferInUse {read write unset} accessor810
set compositionBufferPrefix {}
trace add variable compositionBufferPrefix {read write unset} accessor813




set glueClass(AIControl) yes




set glueClass(GeneticAI) yes








set glueClass(GenAI) yes







set glueClass(CommonKeyboardClient) yes












set glueClass(ForwardingEffectsHandler) yes


set glueClass(Spectator) yes








set glueClass(GameEnv) yes











set glueClass(Manipulator) yes
























set planetgen_width {}
trace add variable planetgen_width {read write unset} accessor955
set planetgen_height {}
trace add variable planetgen_height {read write unset} accessor957
set glueClass(PlanetGeneratorParms) yes













































set state {}
trace add variable state {read write unset} accessor1079

set PLATFORM {}
trace add variable PLATFORM {read write unset} accessor1081
set screenW {}
trace add variable screenW {read write unset} accessor1083
set screenH {}
trace add variable screenH {read write unset} accessor1085
set vheight {}
trace add variable vheight {read write unset} accessor1087
set generalAlphaBlending {}
trace add variable generalAlphaBlending {read write unset} accessor1090
set alphaBlendingEnabled {}
trace add variable alphaBlendingEnabled {read write unset} accessor1093
set smoothScaling {}
trace add variable smoothScaling {read write unset} accessor1096
set highQuality {}
trace add variable highQuality {read write unset} accessor1099
set antialiasing {}
trace add variable antialiasing {read write unset} accessor1102

set headless {}
trace add variable headless {read write unset} accessor1104
set cameraX1 {}
trace add variable cameraX1 {read write unset} accessor1107
set cameraX2 {}
trace add variable cameraX2 {read write unset} accessor1110
set cameraY1 {}
trace add variable cameraY1 {read write unset} accessor1113
set cameraY2 {}
trace add variable cameraY2 {read write unset} accessor1116
set cameraCX {}
trace add variable cameraCX {read write unset} accessor1119
set cameraCY {}
trace add variable cameraCY {read write unset} accessor1122
set cameraZoom {}
trace add variable cameraZoom {read write unset} accessor1125
set cursorX {}
trace add variable cursorX {read write unset} accessor1128
set cursorY {}
trace add variable cursorY {read write unset} accessor1131
set oldCursorX {}
trace add variable oldCursorX {read write unset} accessor1134
set oldCursorY {}
trace add variable oldCursorY {read write unset} accessor1137

set currentFrameTime {}
trace add variable currentFrameTime {read write unset} accessor1139
set currentFrameTimeLeft {}
trace add variable currentFrameTimeLeft {read write unset} accessor1141
set currentVFrameLast {}
trace add variable currentVFrameLast {read write unset} accessor1143
set frameRate {}
trace add variable frameRate {read write unset} accessor1145
set sparkCountMultiplier {}
trace add variable sparkCountMultiplier {read write unset} accessor1147
set gameClock {}
trace add variable gameClock {read write unset} accessor1149
set STD_CELL_SZ {}
trace add variable STD_CELL_SZ {read write unset} accessor1151
set glueClass(SquareIcon) yes










set glueClass(Antenna) yes










set antenna {}
trace add variable antenna {read write unset} accessor1188
set packetDropMask {}
trace add variable packetDropMask {read write unset} accessor1191

set glueClass(Tuner) yes



set glueClass(GlobalID) yes




set glueClass(PacketProcessor) yes



set glueClass(NetworkAssembly) yes















set glueClass(NetworkConnection) yes









set glueClass(ConnectionListener) yes


set glueClass(InputNetworkGeraet) yes

set glueClass(OutputNetworkGeraet) yes


set glueClass(fun<InputNetworkGeraet*:NetworkConnection*>) yes






set glueClass(SynchronousControlGeraet) yes



set glueClass(GameAdvertiser) yes






set glueClass(GameDiscoverer) yes








set glueClass(SeqTextOutputGeraet) yes



set glueClass(SeqTextInputGeraet) yes




set glueClass(Peer) yes








set glueClass(NetIface) yes















set glueClass(NetworkGame) yes






























set glueClass(ConfReg) yes



















































set globalConf {}
trace add variable globalConf {read write unset} accessor1489





























set glueClass(NetworkTest) yes











set glueClass(VersusMatch) yes









safe_source tcl/autosource.tcl
