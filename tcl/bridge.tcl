
  package require Itcl

  # AUTOGENERATED BY generate.tcl. DO NOT EDIT DIRECTLY.
  # See readme.txt.

  #Our base Tcl glue code (eval'd to hardwire the magic cookie)
  eval [format {
    itcl::class AObject {
      # Ensure all code uses the fully-qualified name for C++ to recognize it
      method fqn {} {::return $this}

      protected constructor {cppClass constname cppArgs} {
        if {[::string length $constname]} {
          # Intercept errors so we don't leak the magic number
          if {[catch {
            "::c++ new $cppClass $constname" $this %s {*}$cppArgs
          } err]} {
            error "Bad constructor call: $cppClass $constname: $err"
          }
        }
      }
      destructor {
        {::c++ delete} $this %s
      }

      method super {sup cname {args {}}} {
        ${sup}::constructor $sup $cname $args
      }

      # Prevent access to the magic cookie by redirecting
      # all info requests to the global one
      method info {args} {
        ::namespace eval :: ::info {*}$args
      }
    }
  } ${ABENDSTERN-MAGIC-COOKIE-1} ${ABENDSTERN-MAGIC-COOKIE-1}]
  unset ABENDSTERN-MAGIC-COOKIE-1

  # Have rename commit suicide
  # rename rename {}

  set glueClass(AObject) yes

  proc new {clazz args} {
    global glueClass
    if {[info exists glueClass($clazz)]} {
      [$clazz #auto $clazz [lindex $args 0] [lrange $args 1 [llength $args]]] fqn
    } else {
      [$clazz #auto {*}$args] fqn
    }
  }

proc {c++ delete} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1} $a0 $a1 ]]
return $retpi
}
proc {glBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline3} $a0 ]]
return $retpi
}
proc {glEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline5} ]]
return $retpi
}
proc {glVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline7} $a0 $a1 ]]
return $retpi
}
proc {glColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline9} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {glPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline11} ]]
return $retpi
}
proc {glPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline13} ]]
return $retpi
}
proc {glLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline15} ]]
return $retpi
}
proc {glTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline17} $a0 $a1 ]]
return $retpi
}
proc {glRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline19} $a0 ]]
return $retpi
}
proc {glScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline21} $a0 $a1 ]]
return $retpi
}
proc {glUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline23} $a0 ]]
return $retpi
}
proc {glReset} {  } {set retpi [uplevel 1 [list {c++ trampoline25} ]]
return $retpi
}

proc {acsgi_begin} {  } {set retpi [uplevel 1 [list {c++ trampoline27} ]]
return $retpi
}
proc {acsgi_end} {  } {set retpi [uplevel 1 [list {c++ trampoline29} ]]
return $retpi
}
proc {acsgi_draw} {  } {set retpi [uplevel 1 [list {c++ trampoline31} ]]
return $retpi
}
proc {acsgi_textNormal} { a0  } {set retpi [uplevel 1 [list {c++ trampoline33} $a0 ]]
return $retpi
}
proc {cglBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline35} $a0 ]]
return $retpi
}
proc {cglEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline37} ]]
return $retpi
}
proc {cglVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline39} $a0 $a1 ]]
return $retpi
}
proc {cglColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline41} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {cglPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline43} ]]
return $retpi
}
proc {cglPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline45} ]]
return $retpi
}
proc {cglLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline47} ]]
return $retpi
}
proc {cglTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline49} $a0 $a1 ]]
return $retpi
}
proc {cglRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline51} $a0 ]]
return $retpi
}
proc {cglScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline53} $a0 $a1 ]]
return $retpi
}
proc {cglUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline55} $a0 ]]
return $retpi
}
proc {cglText} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline57} $a0 $a1 $a2 ]]
return $retpi
}
 proc accessor60 {ignored ignored op} {
             global none
             if {$op == {read}} {
               set tmp [{c++ get59} ]
               set none $tmp

             } elseif {$op == {write}} {
               error "Cannot write to none"
             } else { error "Cannot unset C++ variable none" }
           }

 proc accessor62 {ignored ignored op} {
             global lshift
             if {$op == {read}} {
               set tmp [{c++ get61} ]
               set lshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lshift"
             } else { error "Cannot unset C++ variable lshift" }
           }

 proc accessor64 {ignored ignored op} {
             global rshift
             if {$op == {read}} {
               set tmp [{c++ get63} ]
               set rshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rshift"
             } else { error "Cannot unset C++ variable rshift" }
           }

 proc accessor66 {ignored ignored op} {
             global lctrl
             if {$op == {read}} {
               set tmp [{c++ get65} ]
               set lctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lctrl"
             } else { error "Cannot unset C++ variable lctrl" }
           }

 proc accessor68 {ignored ignored op} {
             global rctrl
             if {$op == {read}} {
               set tmp [{c++ get67} ]
               set rctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rctrl"
             } else { error "Cannot unset C++ variable rctrl" }
           }

 proc accessor70 {ignored ignored op} {
             global lalt
             if {$op == {read}} {
               set tmp [{c++ get69} ]
               set lalt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lalt"
             } else { error "Cannot unset C++ variable lalt" }
           }

 proc accessor72 {ignored ignored op} {
             global ralt
             if {$op == {read}} {
               set tmp [{c++ get71} ]
               set ralt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ralt"
             } else { error "Cannot unset C++ variable ralt" }
           }

 proc accessor74 {ignored ignored op} {
             global lmeta
             if {$op == {read}} {
               set tmp [{c++ get73} ]
               set lmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lmeta"
             } else { error "Cannot unset C++ variable lmeta" }
           }

 proc accessor76 {ignored ignored op} {
             global rmeta
             if {$op == {read}} {
               set tmp [{c++ get75} ]
               set rmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rmeta"
             } else { error "Cannot unset C++ variable rmeta" }
           }

 proc accessor78 {ignored ignored op} {
             global num
             if {$op == {read}} {
               set tmp [{c++ get77} ]
               set num $tmp

             } elseif {$op == {write}} {
               error "Cannot write to num"
             } else { error "Cannot unset C++ variable num" }
           }

 proc accessor80 {ignored ignored op} {
             global caps
             if {$op == {read}} {
               set tmp [{c++ get79} ]
               set caps $tmp

             } elseif {$op == {write}} {
               error "Cannot write to caps"
             } else { error "Cannot unset C++ variable caps" }
           }

 proc accessor82 {ignored ignored op} {
             global mode
             if {$op == {read}} {
               set tmp [{c++ get81} ]
               set mode $tmp

             } elseif {$op == {write}} {
               error "Cannot write to mode"
             } else { error "Cannot unset C++ variable mode" }
           }

 proc accessor84 {ignored ignored op} {
             global reserved
             if {$op == {read}} {
               set tmp [{c++ get83} ]
               set reserved $tmp

             } elseif {$op == {write}} {
               error "Cannot write to reserved"
             } else { error "Cannot unset C++ variable reserved" }
           }

::itcl::class {SDL_keysym} {
inherit AObject
public variable scancode
 method accessor88 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get86} $this]
               set scancode $tmp

             } elseif {$op == {write}} {
               return [{c++ set87} $this $scancode]
             } else { error "Cannot unset C++ variable scancode" }
           }

public variable sym
 method accessor91 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get89} $this]
               set sym $tmp

             } elseif {$op == {write}} {
               return [{c++ set90} $this $sym]
             } else { error "Cannot unset C++ variable sym" }
           }

public variable mod
 method accessor94 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get92} $this]
               set mod $tmp

             } elseif {$op == {write}} {
               return [{c++ set93} $this $mod]
             } else { error "Cannot unset C++ variable mod" }
           }

public variable unicode
 method accessor97 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get95} $this]
               set unicode $tmp

             } elseif {$op == {write}} {
               return [{c++ set96} $this $unicode]
             } else { error "Cannot unset C++ variable unicode" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set scancode {}
            trace add variable scancode {read write unset} "$this accessor88"
set sym {}
            trace add variable sym {read write unset} "$this accessor91"
set mod {}
            trace add variable mod {read write unset} "$this accessor94"
set unicode {}
            trace add variable unicode {read write unset} "$this accessor97"
}
destructor {
trace remove variable scancode {read write unset} "$this accessor88"
trace remove variable sym {read write unset} "$this accessor91"
trace remove variable mod {read write unset} "$this accessor94"
trace remove variable unicode {read write unset} "$this accessor97"
}
}

::itcl::class {SDL_KeyboardEvent} {
inherit AObject
public variable type
 method accessor101 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get99} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set100} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor104 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get102} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set103} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable keysym
 method accessor107 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get105} $this]
               set keysym $tmp

             } elseif {$op == {write}} {
               return [{c++ set106} $this $keysym]
             } else { error "Cannot unset C++ variable keysym" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor101"
set state {}
            trace add variable state {read write unset} "$this accessor104"
set keysym {}
            trace add variable keysym {read write unset} "$this accessor107"
}
destructor {
trace remove variable type {read write unset} "$this accessor101"
trace remove variable state {read write unset} "$this accessor104"
trace remove variable keysym {read write unset} "$this accessor107"
}
}

 proc accessor109 {ignored ignored op} {
             global SDL_BUTTON_1
             if {$op == {read}} {
               set tmp [{c++ get108} ]
               set SDL_BUTTON_1 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_1"
             } else { error "Cannot unset C++ variable SDL_BUTTON_1" }
           }

 proc accessor111 {ignored ignored op} {
             global SDL_BUTTON_2
             if {$op == {read}} {
               set tmp [{c++ get110} ]
               set SDL_BUTTON_2 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_2"
             } else { error "Cannot unset C++ variable SDL_BUTTON_2" }
           }

 proc accessor113 {ignored ignored op} {
             global SDL_BUTTON_3
             if {$op == {read}} {
               set tmp [{c++ get112} ]
               set SDL_BUTTON_3 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_3"
             } else { error "Cannot unset C++ variable SDL_BUTTON_3" }
           }

 proc accessor115 {ignored ignored op} {
             global SDL_BUTTON_4
             if {$op == {read}} {
               set tmp [{c++ get114} ]
               set SDL_BUTTON_4 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_4"
             } else { error "Cannot unset C++ variable SDL_BUTTON_4" }
           }

 proc accessor117 {ignored ignored op} {
             global SDL_BUTTON_5
             if {$op == {read}} {
               set tmp [{c++ get116} ]
               set SDL_BUTTON_5 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_5"
             } else { error "Cannot unset C++ variable SDL_BUTTON_5" }
           }

proc {SDL_GetModState} {  } {set retpi [uplevel 1 [list {c++ trampoline118} ]]
set ret $retpi
return $ret
}
 proc accessor121 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_INTERVAL
             if {$op == {read}} {
               set tmp [{c++ get120} ]
               set SDL_DEFAULT_REPEAT_INTERVAL $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_INTERVAL"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_INTERVAL" }
           }

 proc accessor123 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_DELAY
             if {$op == {read}} {
               set tmp [{c++ get122} ]
               set SDL_DEFAULT_REPEAT_DELAY $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_DELAY"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_DELAY" }
           }

proc {SDL_EnableKeyRepeat} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline124} $a0 $a1 ]]
return $retpi
}

::itcl::class {SDL_MouseMotionEvent} {
inherit AObject
public variable type
 method accessor129 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get127} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set128} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor132 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get130} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set131} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor135 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get133} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set134} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor138 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get136} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set137} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

public variable xrel
 method accessor141 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get139} $this]
               set xrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set140} $this $xrel]
             } else { error "Cannot unset C++ variable xrel" }
           }

public variable yrel
 method accessor144 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get142} $this]
               set yrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set143} $this $yrel]
             } else { error "Cannot unset C++ variable yrel" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor129"
set state {}
            trace add variable state {read write unset} "$this accessor132"
set x {}
            trace add variable x {read write unset} "$this accessor135"
set y {}
            trace add variable y {read write unset} "$this accessor138"
set xrel {}
            trace add variable xrel {read write unset} "$this accessor141"
set yrel {}
            trace add variable yrel {read write unset} "$this accessor144"
}
destructor {
trace remove variable type {read write unset} "$this accessor129"
trace remove variable state {read write unset} "$this accessor132"
trace remove variable x {read write unset} "$this accessor135"
trace remove variable y {read write unset} "$this accessor138"
trace remove variable xrel {read write unset} "$this accessor141"
trace remove variable yrel {read write unset} "$this accessor144"
}
}

::itcl::class {SDL_MouseButtonEvent} {
inherit AObject
public variable type
 method accessor148 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get146} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set147} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable which
 method accessor151 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get149} $this]
               set which $tmp

             } elseif {$op == {write}} {
               return [{c++ set150} $this $which]
             } else { error "Cannot unset C++ variable which" }
           }

public variable button
 method accessor154 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get152} $this]
               set button $tmp

             } elseif {$op == {write}} {
               return [{c++ set153} $this $button]
             } else { error "Cannot unset C++ variable button" }
           }

public variable state
 method accessor157 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get155} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set156} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor160 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get158} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set159} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor163 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get161} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set162} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor148"
set which {}
            trace add variable which {read write unset} "$this accessor151"
set button {}
            trace add variable button {read write unset} "$this accessor154"
set state {}
            trace add variable state {read write unset} "$this accessor157"
set x {}
            trace add variable x {read write unset} "$this accessor160"
set y {}
            trace add variable y {read write unset} "$this accessor163"
}
destructor {
trace remove variable type {read write unset} "$this accessor148"
trace remove variable which {read write unset} "$this accessor151"
trace remove variable button {read write unset} "$this accessor154"
trace remove variable state {read write unset} "$this accessor157"
trace remove variable x {read write unset} "$this accessor160"
trace remove variable y {read write unset} "$this accessor163"
}
}

proc {SDL_WarpMouse} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline164} $a0 $a1 ]]
return $retpi
}
proc {SDL_GetTicks} {  } {set retpi [uplevel 1 [list {c++ trampoline166} ]]
set ret $retpi
return $ret
}

::itcl::class {Font} {
inherit AObject
namespace eval :: {
proc {c++ new Font default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline169} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}


method {charWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline171} $this $a0 ]]
set ret $retpi
return $ret
}
method {width} { a0  } {set retpi [uplevel 1 [list {c++ trampoline173} $this $a0 ]]
set ret $retpi
return $ret
}
method {getHeight} {  } {set retpi [uplevel 1 [list {c++ trampoline175} $this ]]
set ret $retpi
return $ret
}
method {getRise} {  } {set retpi [uplevel 1 [list {c++ trampoline177} $this ]]
set ret $retpi
return $ret
}
method {getDip} {  } {set retpi [uplevel 1 [list {c++ trampoline179} $this ]]
set ret $retpi
return $ret
}
method {preDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline181} $this ]]
return $retpi
}
method {postDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline183} $this ]]
return $retpi
}
method {drawCh} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline185} $this $a0 $a1 $a2 ]]
return $retpi
}
method {drawStr} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline187} $this $a0 $a1 $a2 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {











}
destructor {











}
}

 proc accessor190 {ignored ignored op} {
             global sysfont
             if {$op == {read}} {
               set tmp [{c++ get189} ]
               set sysfont $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfont"
             } else { error "Cannot unset C++ variable sysfont" }
           }

 proc accessor192 {ignored ignored op} {
             global sysfontStipple
             if {$op == {read}} {
               set tmp [{c++ get191} ]
               set sysfontStipple $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfontStipple"
             } else { error "Cannot unset C++ variable sysfontStipple" }
           }

::itcl::class {GameState} {
inherit AObject
namespace eval :: {
proc {c++ new TclGameState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline194} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {configureGL} {  } {set retpi [uplevel 1 [list {c++ deftramp201} $this ]]
return $retpi
}
method {keyboard} { a0  } {set retpi [uplevel 1 [list {c++ deftramp203} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ deftramp205} $this $a0 ]]
return $retpi
}
method {mouseButton} { a0  } {set retpi [uplevel 1 [list {c++ deftramp207} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {InitState} {
inherit GameState
namespace eval :: {
proc {c++ new InitState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline209} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


 proc accessor213 {ignored ignored op} {
             global gameClass
             if {$op == {read}} {
               set tmp [{c++ get211} ]
               set gameClass $tmp

             } elseif {$op == {write}} {
               return [{c++ set212}  $gameClass]
             } else { error "Cannot unset C++ variable gameClass" }
           }

 proc accessor216 {ignored ignored op} {
             global humanShip
             if {$op == {read}} {
               set tmp [{c++ get214} ]
               set humanShip $tmp

             } elseif {$op == {write}} {
               return [{c++ set215}  $humanShip]
             } else { error "Cannot unset C++ variable humanShip" }
           }

 proc accessor219 {ignored ignored op} {
             global testStateMode
             if {$op == {read}} {
               set tmp [{c++ get217} ]
               set testStateMode $tmp

             } elseif {$op == {write}} {
               return [{c++ set218}  $testStateMode]
             } else { error "Cannot unset C++ variable testStateMode" }
           }

 proc accessor222 {ignored ignored op} {
             global testStateSize
             if {$op == {read}} {
               set tmp [{c++ get220} ]
               set testStateSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set221}  $testStateSize]
             } else { error "Cannot unset C++ variable testStateSize" }
           }

::itcl::class {TestState} {
inherit GameState
namespace eval :: {
proc {c++ new TestState default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline224} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline226} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline228} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}



::itcl::class {GameObject} {
inherit AObject
public variable isRemote
 method accessor233 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get232} $this]
               set isRemote $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isRemote"
             } else { error "Cannot unset C++ variable isRemote" }
           }

public variable isExportable
 method accessor236 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get234} $this]
               set isExportable $tmp

             } elseif {$op == {write}} {
               return [{c++ set235} $this $isExportable]
             } else { error "Cannot unset C++ variable isExportable" }
           }

public variable tag
 method accessor239 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get237} $this]
               set tag $tmp

             } elseif {$op == {write}} {
               return [{c++ set238} $this $tag]
             } else { error "Cannot unset C++ variable tag" }
           }

public variable ignoreNetworkTag
 method accessor242 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get240} $this]
               set ignoreNetworkTag $tmp

             } elseif {$op == {write}} {
               return [{c++ set241} $this $ignoreNetworkTag]
             } else { error "Cannot unset C++ variable ignoreNetworkTag" }
           }

protected variable field
 method accessor244 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get243} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable isDead
 method accessor246 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get245} $this]
               set isDead $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isDead"
             } else { error "Cannot unset C++ variable isDead" }
           }

protected variable x
 method accessor249 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get247} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set248} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

protected variable y
 method accessor252 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get250} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set251} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

protected variable vx
 method accessor255 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get253} $this]
               set vx $tmp

             } elseif {$op == {write}} {
               return [{c++ set254} $this $vx]
             } else { error "Cannot unset C++ variable vx" }
           }

protected variable vy
 method accessor258 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get256} $this]
               set vy $tmp

             } elseif {$op == {write}} {
               return [{c++ set257} $this $vy]
             } else { error "Cannot unset C++ variable vy" }
           }

protected variable includeInCollisionDetection
 method accessor261 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get259} $this]
               set includeInCollisionDetection $tmp

             } elseif {$op == {write}} {
               return [{c++ set260} $this $includeInCollisionDetection]
             } else { error "Cannot unset C++ variable includeInCollisionDetection" }
           }

protected variable classification
 method accessor264 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get262} $this]
               set classification $tmp

             } elseif {$op == {write}} {
               return [{c++ set263} $this $classification]
             } else { error "Cannot unset C++ variable classification" }
           }

protected variable decorative
 method accessor267 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get265} $this]
               set decorative $tmp

             } elseif {$op == {write}} {
               return [{c++ set266} $this $decorative]
             } else { error "Cannot unset C++ variable decorative" }
           }

namespace eval :: {
proc {c++ new TclGameObject default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline268} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject position} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline270} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject velocity} { a0 a1 a2 a3 a4 a5 a6  } {set retpi [uplevel 1 [list {c++ trampoline272} $a0 $a1 $a2 $a3 $a4 $a5 $a6 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {getX} {  } {set retpi [uplevel 1 [list {c++ trampoline278} $this ]]
set ret $retpi
return $ret
}
method {getY} {  } {set retpi [uplevel 1 [list {c++ trampoline280} $this ]]
set ret $retpi
return $ret
}
method {getVX} {  } {set retpi [uplevel 1 [list {c++ trampoline282} $this ]]
set ret $retpi
return $ret
}
method {getVY} {  } {set retpi [uplevel 1 [list {c++ trampoline284} $this ]]
set ret $retpi
return $ret
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline286} $this ]]
set ret $retpi
return $ret
}
method {isDecorative} {  } {set retpi [uplevel 1 [list {c++ trampoline288} $this ]]
set ret $retpi
return $ret
}
method {getClassification} {  } {set retpi [uplevel 1 [list {c++ trampoline290} $this ]]
set ret $retpi
return $ret
}
method {okToDecorate} {  } {set retpi [uplevel 1 [list {c++ trampoline292} $this ]]
return $retpi
}
method {teleport} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp295} $this $a0 $a1 $a2 ]]
return $retpi
}
method {getRotation} {  } {set retpi [uplevel 1 [list {c++ deftramp297} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getRadius"]
set ret $retpi
return $ret
}
method {isCollideable} {  } {set retpi [uplevel 1 [list {c++ deftramp301} $this ]]
set ret $retpi
return $ret
}
method {checkCollision} { a0  } {set retpi [uplevel 1 [list {c++ deftramp303} $this $a0 ]]
set ret $retpi
return $ret
}
method {del} {  } {set retpi [uplevel 1 [list {c++ trampoline304} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set isRemote {}
            trace add variable isRemote {read write unset} "$this accessor233"
set isExportable {}
            trace add variable isExportable {read write unset} "$this accessor236"
set tag {}
            trace add variable tag {read write unset} "$this accessor239"
set ignoreNetworkTag {}
            trace add variable ignoreNetworkTag {read write unset} "$this accessor242"
set field {}
            trace add variable field {read write unset} "$this accessor244"
set isDead {}
            trace add variable isDead {read write unset} "$this accessor246"
set x {}
            trace add variable x {read write unset} "$this accessor249"
set y {}
            trace add variable y {read write unset} "$this accessor252"
set vx {}
            trace add variable vx {read write unset} "$this accessor255"
set vy {}
            trace add variable vy {read write unset} "$this accessor258"
set includeInCollisionDetection {}
            trace add variable includeInCollisionDetection {read write unset} "$this accessor261"
set classification {}
            trace add variable classification {read write unset} "$this accessor264"
set decorative {}
            trace add variable decorative {read write unset} "$this accessor267"



















}
destructor {
trace remove variable isRemote {read write unset} "$this accessor233"
trace remove variable isExportable {read write unset} "$this accessor236"
trace remove variable tag {read write unset} "$this accessor239"
trace remove variable ignoreNetworkTag {read write unset} "$this accessor242"
trace remove variable field {read write unset} "$this accessor244"
trace remove variable isDead {read write unset} "$this accessor246"
trace remove variable x {read write unset} "$this accessor249"
trace remove variable y {read write unset} "$this accessor252"
trace remove variable vx {read write unset} "$this accessor255"
trace remove variable vy {read write unset} "$this accessor258"
trace remove variable includeInCollisionDetection {read write unset} "$this accessor261"
trace remove variable classification {read write unset} "$this accessor264"
trace remove variable decorative {read write unset} "$this accessor267"



















}
}


::itcl::class {GameField} {
inherit AObject
public variable fieldClock
 method accessor309 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get308} $this]
               set fieldClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to fieldClock"
             } else { error "Cannot unset C++ variable fieldClock" }
           }

public variable width
 method accessor312 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get310} $this]
               set width $tmp

             } elseif {$op == {write}} {
               return [{c++ set311} $this $width]
             } else { error "Cannot unset C++ variable width" }
           }

public variable height
 method accessor315 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get313} $this]
               set height $tmp

             } elseif {$op == {write}} {
               return [{c++ set314} $this $height]
             } else { error "Cannot unset C++ variable height" }
           }

public variable effects
 method accessor318 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get316} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set317} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable perfectRadar
 method accessor321 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get319} $this]
               set perfectRadar $tmp

             } elseif {$op == {write}} {
               return [{c++ set320} $this $perfectRadar]
             } else { error "Cannot unset C++ variable perfectRadar" }
           }

namespace eval :: {
proc {c++ new GameField default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline322} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline324} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline326} $this ]]
return $retpi
}
method {at} { a0  } {set retpi [uplevel 1 [list {c++ trampoline328} $this $a0 ]]
set ret $retpi
return $ret
}
method {size} {  } {set retpi [uplevel 1 [list {c++ trampoline330} $this ]]
set ret $retpi
return $ret
}
method {add} { a0  } {set retpi [uplevel 1 [list {c++ trampoline332} $this $a0 ]]
return $retpi
}
method {addBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline334} $this $a0 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline336} $this $a0 ]]
return $retpi
}
method {inject} { a0  } {set retpi [uplevel 1 [list {c++ trampoline338} $this $a0 ]]
return $retpi
}
method {clear} {  } {set retpi [uplevel 1 [list {c++ trampoline340} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set fieldClock {}
            trace add variable fieldClock {read write unset} "$this accessor309"
set width {}
            trace add variable width {read write unset} "$this accessor312"
set height {}
            trace add variable height {read write unset} "$this accessor315"
set effects {}
            trace add variable effects {read write unset} "$this accessor318"
set perfectRadar {}
            trace add variable perfectRadar {read write unset} "$this accessor321"










}
destructor {
trace remove variable fieldClock {read write unset} "$this accessor309"
trace remove variable width {read write unset} "$this accessor312"
trace remove variable height {read write unset} "$this accessor315"
trace remove variable effects {read write unset} "$this accessor318"
trace remove variable perfectRadar {read write unset} "$this accessor321"










}
}

::itcl::class {Blast} {
inherit GameObject
public variable blame
 method accessor344 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get343} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               error "Cannot write to blame"
             } else { error "Cannot unset C++ variable blame" }
           }

namespace eval :: {
proc {c++ new Blast default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline345} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDirect} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline347} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withSize} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline349} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withADC} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline351} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDecor} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline353} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDamage} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12  } {set retpi [uplevel 1 [list {c++ trampoline355} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast nonDamageCopy} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline357} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline359} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline361} $this ]]
return $retpi
}
method {getFalloff} {  } {set retpi [uplevel 1 [list {c++ trampoline363} $this ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline365} $this ]]
set ret $retpi
return $ret
}
method {getStrengthAt} { a0  } {set retpi [uplevel 1 [list {c++ trampoline367} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrengthUpon} { a0  } {set retpi [uplevel 1 [list {c++ trampoline369} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline371} $this ]]
set ret $retpi
return $ret
}
method {isDirect} {  } {set retpi [uplevel 1 [list {c++ trampoline373} $this ]]
set ret $retpi
return $ret
}
method {causesDamage} {  } {set retpi [uplevel 1 [list {c++ trampoline375} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set blame {}
            trace add variable blame {read write unset} "$this accessor344"
















}
destructor {
trace remove variable blame {read write unset} "$this accessor344"
















}
}

::itcl::class {CellFragment} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline378} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline380} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline382} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {PlasmaFire} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline385} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline387} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline389} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {Explosion} {
inherit GameObject
public variable hungry
 method accessor394 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get392} $this]
               set hungry $tmp

             } elseif {$op == {write}} {
               return [{c++ set393} $this $hungry]
             } else { error "Cannot unset C++ variable hungry" }
           }

namespace eval :: {
proc {c++ new Explosion stationary} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline395} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion velocity} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13  } {set retpi [uplevel 1 [list {c++ trampoline397} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion smeared} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15  } {set retpi [uplevel 1 [list {c++ trampoline399} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 $a15 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion by} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline401} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

method {multiExplosion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline403} $this $a0 ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline405} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline407} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline409} $this ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline411} $this ]]
set ret $retpi
return $ret
}
method {getDensity} {  } {set retpi [uplevel 1 [list {c++ trampoline413} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set hungry {}
            trace add variable hungry {read write unset} "$this accessor394"










}
destructor {
trace remove variable hungry {read write unset} "$this accessor394"










}
}


::itcl::class {OldStyleExplosion} {
inherit GameObject
namespace eval :: {
proc {c++ new OldStyleExplosion default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline416} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline418} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline420} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline422} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {LightTrail} {
inherit GameObject
namespace eval :: {
proc {c++ new LightTrail default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14  } {set retpi [uplevel 1 [list {c++ trampoline425} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline427} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline429} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline431} $this ]]
set ret $retpi
return $ret
}
method {setWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline433} $this $a0 ]]
return $retpi
}
method {emit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline435} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}







itcl::class fun<void:Ship*,bool>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<void:Ship*,bool>::fun_t {} {}
      } {}
    }
::itcl::class {fun<void:Ship*,bool>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<void:Ship*,bool> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline443} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
return $retpi
}
proc {call} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline447} $a0 $a1 $a2 ]]
return $retpi
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline449} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

::itcl::class {radar_t} {
inherit AObject
namespace eval :: {
proc {c++ new radar_t default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline452} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Ship} {
inherit GameObject
public variable controller
 method accessor457 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get455} $this]
               set controller $tmp

             } elseif {$op == {write}} {
               return [{c++ set456} $this $controller]
             } else { error "Cannot unset C++ variable controller" }
           }

public variable effects
 method accessor460 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get458} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set459} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable shipExistenceFailure
 method accessor463 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get461} $this]
               set shipExistenceFailure $tmp

             } elseif {$op == {write}} {
               return [{c++ set462} $this $shipExistenceFailure]
             } else { error "Cannot unset C++ variable shipExistenceFailure" }
           }


proc {cellCoord} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline464} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {cellSubCoord} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline466} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}
public variable insignia
 method accessor470 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get468} $this]
               set insignia $tmp

             } elseif {$op == {write}} {
               return [{c++ set469} $this $insignia]
             } else { error "Cannot unset C++ variable insignia" }
           }

public variable blame
 method accessor473 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get471} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               return [{c++ set472} $this $blame]
             } else { error "Cannot unset C++ variable blame" }
           }

public variable score
 method accessor476 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get474} $this]
               set score $tmp

             } elseif {$op == {write}} {
               return [{c++ set475} $this $score]
             } else { error "Cannot unset C++ variable score" }
           }

public variable damageMultiplier
 method accessor479 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get477} $this]
               set damageMultiplier $tmp

             } elseif {$op == {write}} {
               return [{c++ set478} $this $damageMultiplier]
             } else { error "Cannot unset C++ variable damageMultiplier" }
           }

public variable diedSpontaneously
 method accessor481 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get480} $this]
               set diedSpontaneously $tmp

             } elseif {$op == {write}} {
               error "Cannot write to diedSpontaneously"
             } else { error "Cannot unset C++ variable diedSpontaneously" }
           }

public variable typeName
 method accessor483 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get482} $this]
               set typeName $tmp

             } elseif {$op == {write}} {
               error "Cannot write to typeName"
             } else { error "Cannot unset C++ variable typeName" }
           }

namespace eval :: {
proc {c++ new Ship default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline484} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}


method {refreshUpdates} {  } {set retpi [uplevel 1 [list {c++ trampoline486} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline488} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline490} $this ]]
return $retpi
}

method {getVRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline492} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline494} $this ]]
set ret $retpi
return $ret
}
method {glSetColour0} {  } {set retpi [uplevel 1 [list {c++ trampoline496} $this ]]
return $retpi
}
method {glSetColour1} { a0  } {set retpi [uplevel 1 [list {c++ trampoline498} $this $a0 ]]
return $retpi
}
method {glSetColour2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline500} $this $a0 $a1 ]]
return $retpi
}
method {setThrust} { a0  } {set retpi [uplevel 1 [list {c++ trampoline502} $this $a0 ]]
return $retpi
}
method {getThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline504} $this ]]
set ret $retpi
return $ret
}
method {getTrueThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline506} $this ]]
set ret $retpi
return $ret
}
method {setThrustOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline508} $this $a0 ]]
return $retpi
}
method {isThrustOn} {  } {set retpi [uplevel 1 [list {c++ trampoline510} $this ]]
set ret $retpi
return $ret
}
method {setBrakeOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline512} $this $a0 ]]
return $retpi
}
method {isBrakeOn} {  } {set retpi [uplevel 1 [list {c++ trampoline514} $this ]]
set ret $retpi
return $ret
}
method {configureEngines} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline516} $this $a0 $a1 $a2 ]]
return $retpi
}
method {configureEngines2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline518} $this $a0 $a1 ]]
return $retpi
}
method {getAcceleration} {  } {set retpi [uplevel 1 [list {c++ trampoline520} $this ]]
set ret $retpi
return $ret
}
method {getRotationRate} {  } {set retpi [uplevel 1 [list {c++ trampoline522} $this ]]
set ret $retpi
return $ret
}
method {getRotationAccel} {  } {set retpi [uplevel 1 [list {c++ trampoline524} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline526} $this ]]
set ret $retpi
return $ret
}
method {getPowerUsagePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline528} $this ]]
set ret $retpi
return $ret
}
method {getPowerSupply} {  } {set retpi [uplevel 1 [list {c++ trampoline530} $this ]]
set ret $retpi
return $ret
}
method {getPowerDrain} {  } {set retpi [uplevel 1 [list {c++ trampoline532} $this ]]
set ret $retpi
return $ret
}
method {getCurrentCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline534} $this ]]
set ret $retpi
return $ret
}
method {getMaximumCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline536} $this ]]
set ret $retpi
return $ret
}
method {getCapacitancePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline538} $this ]]
set ret $retpi
return $ret
}
method {setColour} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline540} $this $a0 $a1 $a2 ]]
return $retpi
}
method {destroyGraphicsInfo} {  } {set retpi [uplevel 1 [list {c++ trampoline542} $this ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline544} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline546} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline548} $this ]]
set ret $retpi
return $ret
}
method {drawPower} { a0  } {set retpi [uplevel 1 [list {c++ trampoline550} $this $a0 ]]
set ret $retpi
return $ret
}
method {getReinforcement} {  } {set retpi [uplevel 1 [list {c++ trampoline552} $this ]]
set ret $retpi
return $ret
}
method {setReinforcement} { a0  } {set retpi [uplevel 1 [list {c++ trampoline554} $this $a0 ]]
return $retpi
}
method {enableSoundEffects} {  } {set retpi [uplevel 1 [list {c++ trampoline556} $this ]]
return $retpi
}

method {hasPower} {  } {set retpi [uplevel 1 [list {c++ trampoline558} $this ]]
set ret $retpi
return $ret
}
method {spontaneouslyDie} {  } {set retpi [uplevel 1 [list {c++ trampoline560} $this ]]
return $retpi
}
method {getCoolingMult} {  } {set retpi [uplevel 1 [list {c++ trampoline562} $this ]]
set ret $retpi
return $ret
}
method {getCellVelocity} { a0  } {set retpi [uplevel 1 [list {c++ trampoline564} $this $a0 ]]
set ret $retpi
return $ret
}

method {spin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline566} $this $a0 ]]
return $retpi
}
method {startTest} {  } {set retpi [uplevel 1 [list {c++ trampoline568} $this ]]
return $retpi
}
method {endTest} {  } {set retpi [uplevel 1 [list {c++ trampoline570} $this ]]
set ret $retpi
return $ret
}

method {applyCollision} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline572} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {cellCount} {  } {set retpi [uplevel 1 [list {c++ trampoline574} $this ]]
set ret $retpi
return $ret
}
method {getRadar} {  } {set retpi [uplevel 1 [list {c++ trampoline576} $this ]]
set ret $retpi
return $ret
}
method {setRadar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline578} $this $a0 ]]
return $retpi
}
method {getDeathAttributions} {  } {set retpi [uplevel 1 [list {c++ trampoline580} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set controller {}
            trace add variable controller {read write unset} "$this accessor457"
set effects {}
            trace add variable effects {read write unset} "$this accessor460"
set shipExistenceFailure {}
            trace add variable shipExistenceFailure {read write unset} "$this accessor463"



set insignia {}
            trace add variable insignia {read write unset} "$this accessor470"
set blame {}
            trace add variable blame {read write unset} "$this accessor473"
set score {}
            trace add variable score {read write unset} "$this accessor476"
set damageMultiplier {}
            trace add variable damageMultiplier {read write unset} "$this accessor479"
set diedSpontaneously {}
            trace add variable diedSpontaneously {read write unset} "$this accessor481"
set typeName {}
            trace add variable typeName {read write unset} "$this accessor483"






















































}
destructor {
trace remove variable controller {read write unset} "$this accessor457"
trace remove variable effects {read write unset} "$this accessor460"
trace remove variable shipExistenceFailure {read write unset} "$this accessor463"



trace remove variable insignia {read write unset} "$this accessor470"
trace remove variable blame {read write unset} "$this accessor473"
trace remove variable score {read write unset} "$this accessor476"
trace remove variable damageMultiplier {read write unset} "$this accessor479"
trace remove variable diedSpontaneously {read write unset} "$this accessor481"
trace remove variable typeName {read write unset} "$this accessor483"






















































}
}

proc {verify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline582} $a0 ]]
set ret $retpi
return $ret
}
proc {loadShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline584} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {saveShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline586} $a0 $a1 ]]
return $retpi
}

::itcl::class {Shield} {
inherit AObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline589} $this $a0 ]]
return $retpi
}
method {updateDist} {  } {set retpi [uplevel 1 [list {c++ trampoline591} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline593} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline595} $this ]]
set ret $retpi
return $ret
}
method {collideWith} { a0  } {set retpi [uplevel 1 [list {c++ trampoline597} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline599} $this ]]
set ret $retpi
return $ret
}
method {getStability} {  } {set retpi [uplevel 1 [list {c++ trampoline601} $this ]]
set ret $retpi
return $ret
}
method {getShip} {  } {set retpi [uplevel 1 [list {c++ trampoline603} $this ]]
set ret $retpi
return $ret
}
method {drawForHUD} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline605} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {









}
destructor {









}
}


proc {insignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline607} $a0 ]]
set ret $retpi
return $ret
}
proc {clear_insignias} {  } {set retpi [uplevel 1 [list {c++ trampoline609} ]]
return $retpi
}

proc {getAlliance} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline611} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {setAlliance} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline613} $a0 $a1 $a2 ]]
return $retpi
}

::itcl::class {EnergyCharge} {
inherit GameObject
namespace eval :: {
proc {c++ new EnergyCharge default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline616} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp619} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline620} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline622} $this ]]
set ret $retpi
return $ret
}
method {getIntensity} {  } {set retpi [uplevel 1 [list {c++ trampoline624} $this ]]
set ret $retpi
return $ret
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline626} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {MagnetoBomb} {
inherit GameObject
namespace eval :: {
proc {c++ new MagnetoBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline629} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp632} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline633} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline635} $this ]]
set ret $retpi
return $ret
}
method {getPower} {  } {set retpi [uplevel 1 [list {c++ trampoline637} $this ]]
set ret $retpi
return $ret
}
method {simulateFailure} {  } {set retpi [uplevel 1 [list {c++ trampoline639} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {SemiguidedBomb} {
inherit MagnetoBomb
namespace eval :: {
proc {c++ new SemiguidedBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline642} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      MagnetoBomb::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {PlasmaBurst} {
inherit GameObject
namespace eval :: {
proc {c++ new PlasmaBurst default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline645} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp648} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline649} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline651} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline653} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {





}
destructor {





}
}

::itcl::class {MonophasicEnergyPulse} {
inherit GameObject
namespace eval :: {
proc {c++ new MonophasicEnergyPulse default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline656} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Missile} {
inherit GameObject
namespace eval :: {
proc {c++ new Missile default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline659} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {EffectsHandler} {
inherit AObject
namespace eval :: {
proc {c++ new EffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline662} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclEffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline664} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {impact} { a0  } {set retpi [uplevel 1 [list {c++ deftramp667} $this $a0 ]]
return $retpi
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ deftramp669} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

 proc accessor671 {ignored ignored op} {
             global nullEffectsHandler
             if {$op == {read}} {
               set tmp [{c++ get670} ]
               set nullEffectsHandler $tmp

             } elseif {$op == {write}} {
               error "Cannot write to nullEffectsHandler"
             } else { error "Cannot unset C++ variable nullEffectsHandler" }
           }

::itcl::class {Background} {
inherit EffectsHandler
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline673} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline675} $this $a0 ]]
return $retpi
}
method {updateReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline677} $this $a0 $a1 ]]
return $retpi
}
method {repopulate} {  } {set retpi [uplevel 1 [list {c++ trampoline679} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {Planet} {
inherit Background
namespace eval :: {
proc {c++ new Planet default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline682} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {StarField} {
inherit Background
namespace eval :: {
proc {c++ new StarField default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline685} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

proc {initStarLists} {  } {set retpi [uplevel 1 [list {c++ trampoline687} ]]
return $retpi
}

::itcl::class {Nebula} {
inherit Background
namespace eval :: {
proc {c++ new Nebula default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline690} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {setFlowEquation} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline692} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {setPressureEquation} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline694} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
method {setPressureResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline696} $this $a0 ]]
return $retpi
}
method {getPressureResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline698} $this ]]
set ret $retpi
return $ret
}
method {setVelocityResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline700} $this $a0 ]]
return $retpi
}
method {getVelocityResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline702} $this ]]
set ret $retpi
return $ret
}
method {setForceMultiplier} { a0  } {set retpi [uplevel 1 [list {c++ trampoline704} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {








}
destructor {








}
}


::itcl::class {Camera} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new TclCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline707} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

protected variable reference
 method accessor711 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get709} $this]
               set reference $tmp

             } elseif {$op == {write}} {
               return [{c++ set710} $this $reference]
             } else { error "Cannot unset C++ variable reference" }
           }

protected method {doSetup} {  } {set retpi [uplevel 1 error "Call to pure-virtual function doSetup"]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp715} $this $a0 ]]
return $retpi
}
method {drawOverlays} {  } {set retpi [uplevel 1 [list {c++ deftramp717} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ deftramp719} $this ]]
return $retpi
}
method {setup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline720} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set reference {}
            trace add variable reference {read write unset} "$this accessor711"





}
destructor {

trace remove variable reference {read write unset} "$this accessor711"





}
}


::itcl::class {DynamicCamera} {
inherit Camera
namespace eval :: {
proc {c++ new DynamicCamera default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline723} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline725} $this $a0 ]]
return $retpi
}
protected method {doSetup} {  } {set retpi [uplevel 1 [list {c++ trampoline727} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ trampoline729} $this ]]
return $retpi
}
method {getZoom} {  } {set retpi [uplevel 1 [list {c++ trampoline731} $this ]]
set ret $retpi
return $ret
}
method {setZoom} { a0  } {set retpi [uplevel 1 [list {c++ trampoline733} $this $a0 ]]
return $retpi
}
method {getRotateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline735} $this ]]
set ret $retpi
return $ret
}
method {setRotateMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline737} $this $a0 ]]
return $retpi
}
method {getLookAhead} {  } {set retpi [uplevel 1 [list {c++ trampoline739} $this ]]
set ret $retpi
return $ret
}
method {setLookAhead} { a0  } {set retpi [uplevel 1 [list {c++ trampoline741} $this $a0 ]]
return $retpi
}
method {getVisualRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline743} $this ]]
set ret $retpi
return $ret
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline745} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {












}
destructor {












}
}


::itcl::class {FixedCamera} {
inherit Camera
namespace eval :: {
proc {c++ new FixedCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline748} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {Controller} {
inherit AObject
public variable ship
 method accessor752 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get751} $this]
               set ship $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ship"
             } else { error "Cannot unset C++ variable ship" }
           }

namespace eval :: {
proc {c++ new TclController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline753} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
return $retpi
}
method {damage} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp758} $this $a0 $a1 $a2 ]]
return $retpi
}
method {otherShipDied} { a0  } {set retpi [uplevel 1 [list {c++ deftramp760} $this $a0 ]]
return $retpi
}
method {notifyScore} { a0  } {set retpi [uplevel 1 [list {c++ deftramp762} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set ship {}
            trace add variable ship {read write unset} "$this accessor752"





}
destructor {
trace remove variable ship {read write unset} "$this accessor752"





}
}


::itcl::class {HumanController} {
inherit Controller
namespace eval :: {
proc {c++ new HumanController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline764} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline766} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline768} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline770} $this $a0 ]]
return $retpi
}
method {button} { a0  } {set retpi [uplevel 1 [list {c++ trampoline772} $this $a0 ]]
return $retpi
}
method {key} { a0  } {set retpi [uplevel 1 [list {c++ trampoline774} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

 proc accessor777 {ignored ignored op} {
             global isCompositionBufferInUse
             if {$op == {read}} {
               set tmp [{c++ get776} ]
               set isCompositionBufferInUse $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isCompositionBufferInUse"
             } else { error "Cannot unset C++ variable isCompositionBufferInUse" }
           }


proc {hc_conf_configure} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline778} $a0 $a1 ]]
return $retpi
}
proc {hc_conf_clear} {  } {set retpi [uplevel 1 [list {c++ trampoline780} ]]
return $retpi
}

::itcl::class {AIControl} {
inherit Controller
namespace eval :: {
proc {c++ new AIControl default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline783} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline785} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {GeneticAI} {
inherit Controller
namespace eval :: {
proc {c++ new GeneticAI default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline788} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline790} $this $a0 ]]
return $retpi
}
public variable species
 method accessor793 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get792} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor795 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get794} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

public variable instance
 method accessor797 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get796} $this]
               set instance $tmp

             } elseif {$op == {write}} {
               error "Cannot write to instance"
             } else { error "Cannot unset C++ variable instance" }
           }

public variable failed
 method accessor799 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get798} $this]
               set failed $tmp

             } elseif {$op == {write}} {
               error "Cannot write to failed"
             } else { error "Cannot unset C++ variable failed" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


set species {}
            trace add variable species {read write unset} "$this accessor793"
set generation {}
            trace add variable generation {read write unset} "$this accessor795"
set instance {}
            trace add variable instance {read write unset} "$this accessor797"
set failed {}
            trace add variable failed {read write unset} "$this accessor799"
}
destructor {


trace remove variable species {read write unset} "$this accessor793"
trace remove variable generation {read write unset} "$this accessor795"
trace remove variable instance {read write unset} "$this accessor797"
trace remove variable failed {read write unset} "$this accessor799"
}
}

proc {calculateGeneticAIFunctionCosts} {  } {set retpi [uplevel 1 [list {c++ trampoline800} ]]
return $retpi
}
::itcl::class {GenAI} {
inherit Controller
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline803} $this $a0 ]]
return $retpi
}
public variable species
 method accessor806 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get805} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor808 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get807} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

method {getScores} {  } {set retpi [uplevel 1 [list {c++ trampoline809} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set species {}
            trace add variable species {read write unset} "$this accessor806"
set generation {}
            trace add variable generation {read write unset} "$this accessor808"

}
destructor {

trace remove variable species {read write unset} "$this accessor806"
trace remove variable generation {read write unset} "$this accessor808"

}
}

proc {GenAI_make} { a0  } {set retpi [uplevel 1 [list {c++ trampoline811} $a0 ]]
set ret $retpi
return $ret
}

::itcl::class {CommonKeyboardClient} {
inherit AObject
namespace eval :: {
proc {c++ new CommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline814} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclCommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline816} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {exit} {  } {set retpi [uplevel 1 [list {c++ deftramp819} $this ]]
return $retpi
}
method {slow} {  } {set retpi [uplevel 1 [list {c++ deftramp821} $this ]]
return $retpi
}
method {fast} {  } {set retpi [uplevel 1 [list {c++ deftramp823} $this ]]
return $retpi
}
method {halt} {  } {set retpi [uplevel 1 [list {c++ deftramp825} $this ]]
return $retpi
}
method {frameXframe} {  } {set retpi [uplevel 1 [list {c++ deftramp827} $this ]]
return $retpi
}
method {statsOn} {  } {set retpi [uplevel 1 [list {c++ deftramp829} $this ]]
return $retpi
}
method {statsOff} {  } {set retpi [uplevel 1 [list {c++ deftramp831} $this ]]
return $retpi
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline832} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {










}
destructor {










}
}


::itcl::class {ForwardingEffectsHandler} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new ForwardingEffectsHandler default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline835} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Spectator} {
inherit GameObject
namespace eval :: {
proc {c++ new Spectator default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline838} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator explicit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline840} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator empty} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline842} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {nextReference} {  } {set retpi [uplevel 1 [list {c++ trampoline844} $this ]]
return $retpi
}
method {requireInsignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline846} $this $a0 ]]
return $retpi
}
method {kill} {  } {set retpi [uplevel 1 [list {c++ trampoline848} $this ]]
return $retpi
}
method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline850} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {GameEnv} {
inherit AObject
namespace eval :: {
proc {c++ new GameEnv customCamera} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline853} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new GameEnv default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline855} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline857} $this ]]
set ret $retpi
return $ret
}
method {setReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline859} $this $a0 $a1 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline861} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline863} $this ]]
return $retpi
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline865} $this ]]
set ret $retpi
return $ret
}
public variable cam
 method accessor869 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get867} $this]
               set cam $tmp

             } elseif {$op == {write}} {
               return [{c++ set868} $this $cam]
             } else { error "Cannot unset C++ variable cam" }
           }

public variable stars
 method accessor872 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get870} $this]
               set stars $tmp

             } elseif {$op == {write}} {
               return [{c++ set871} $this $stars]
             } else { error "Cannot unset C++ variable stars" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







set cam {}
            trace add variable cam {read write unset} "$this accessor869"
set stars {}
            trace add variable stars {read write unset} "$this accessor872"
}
destructor {







trace remove variable cam {read write unset} "$this accessor869"
trace remove variable stars {read write unset} "$this accessor872"
}
}


::itcl::class {Manipulator} {
inherit AObject
namespace eval :: {
proc {c++ new Manipulator default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline874} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} {  } {set retpi [uplevel 1 [list {c++ trampoline876} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline878} $this ]]
return $retpi
}
method {primaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline880} $this $a0 $a1 ]]
return $retpi
}
method {primaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline882} $this $a0 $a1 ]]
return $retpi
}
method {secondaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline884} $this $a0 $a1 ]]
return $retpi
}
method {secondaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline886} $this $a0 $a1 ]]
return $retpi
}
method {scrollUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline888} $this $a0 $a1 ]]
return $retpi
}
method {scrollDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline890} $this $a0 $a1 ]]
return $retpi
}
method {motion} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline892} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
method {resetView} {  } {set retpi [uplevel 1 [list {c++ trampoline894} $this ]]
return $retpi
}
method {pushUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline896} $this ]]
return $retpi
}
method {popUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline898} $this ]]
return $retpi
}
method {commitUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline900} $this ]]
return $retpi
}
method {deactivateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline902} $this ]]
return $retpi
}
method {activateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline904} $this ]]
return $retpi
}
method {addToHistory} {  } {set retpi [uplevel 1 [list {c++ trampoline906} $this ]]
return $retpi
}
method {revertToHistory} { a0  } {set retpi [uplevel 1 [list {c++ trampoline908} $this $a0 ]]
return $retpi
}
method {reloadShip} {  } {set retpi [uplevel 1 [list {c++ trampoline910} $this ]]
set ret $retpi
return $ret
}
method {deleteShip} {  } {set retpi [uplevel 1 [list {c++ trampoline912} $this ]]
return $retpi
}
method {copyMounts} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline914} $this $a0 $a1 ]]
return $retpi
}
method {getCellAt} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline916} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






















}
destructor {






















}
}


 proc accessor919 {ignored ignored op} {
             global planetgen_width
             if {$op == {read}} {
               set tmp [{c++ get918} ]
               set planetgen_width $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_width"
             } else { error "Cannot unset C++ variable planetgen_width" }
           }

 proc accessor921 {ignored ignored op} {
             global planetgen_height
             if {$op == {read}} {
               set tmp [{c++ get920} ]
               set planetgen_height $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_height"
             } else { error "Cannot unset C++ variable planetgen_height" }
           }

::itcl::class {PlanetGeneratorParms} {
inherit AObject
namespace eval :: {
proc {c++ new PlanetGeneratorParms default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline923} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable seed
 method accessor927 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get925} $this]
               set seed $tmp

             } elseif {$op == {write}} {
               return [{c++ set926} $this $seed]
             } else { error "Cannot unset C++ variable seed" }
           }

public variable continents
 method accessor930 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get928} $this]
               set continents $tmp

             } elseif {$op == {write}} {
               return [{c++ set929} $this $continents]
             } else { error "Cannot unset C++ variable continents" }
           }

public variable largeIslands
 method accessor933 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get931} $this]
               set largeIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set932} $this $largeIslands]
             } else { error "Cannot unset C++ variable largeIslands" }
           }

public variable smallIslands
 method accessor936 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get934} $this]
               set smallIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set935} $this $smallIslands]
             } else { error "Cannot unset C++ variable smallIslands" }
           }

public variable islandGrouping
 method accessor939 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get937} $this]
               set islandGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set938} $this $islandGrouping]
             } else { error "Cannot unset C++ variable islandGrouping" }
           }

public variable landSlope
 method accessor942 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get940} $this]
               set landSlope $tmp

             } elseif {$op == {write}} {
               return [{c++ set941} $this $landSlope]
             } else { error "Cannot unset C++ variable landSlope" }
           }

public variable oceans
 method accessor945 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get943} $this]
               set oceans $tmp

             } elseif {$op == {write}} {
               return [{c++ set944} $this $oceans]
             } else { error "Cannot unset C++ variable oceans" }
           }

public variable seas
 method accessor948 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get946} $this]
               set seas $tmp

             } elseif {$op == {write}} {
               return [{c++ set947} $this $seas]
             } else { error "Cannot unset C++ variable seas" }
           }

public variable lakes
 method accessor951 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get949} $this]
               set lakes $tmp

             } elseif {$op == {write}} {
               return [{c++ set950} $this $lakes]
             } else { error "Cannot unset C++ variable lakes" }
           }

public variable rivers
 method accessor954 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get952} $this]
               set rivers $tmp

             } elseif {$op == {write}} {
               return [{c++ set953} $this $rivers]
             } else { error "Cannot unset C++ variable rivers" }
           }

public variable mountainRanges
 method accessor957 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get955} $this]
               set mountainRanges $tmp

             } elseif {$op == {write}} {
               return [{c++ set956} $this $mountainRanges]
             } else { error "Cannot unset C++ variable mountainRanges" }
           }

public variable mountainSteepness
 method accessor960 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get958} $this]
               set mountainSteepness $tmp

             } elseif {$op == {write}} {
               return [{c++ set959} $this $mountainSteepness]
             } else { error "Cannot unset C++ variable mountainSteepness" }
           }

public variable enormousMountains
 method accessor963 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get961} $this]
               set enormousMountains $tmp

             } elseif {$op == {write}} {
               return [{c++ set962} $this $enormousMountains]
             } else { error "Cannot unset C++ variable enormousMountains" }
           }

public variable craters
 method accessor966 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get964} $this]
               set craters $tmp

             } elseif {$op == {write}} {
               return [{c++ set965} $this $craters]
             } else { error "Cannot unset C++ variable craters" }
           }

public variable maxCraterSize
 method accessor969 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get967} $this]
               set maxCraterSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set968} $this $maxCraterSize]
             } else { error "Cannot unset C++ variable maxCraterSize" }
           }

public variable equatorTemperature
 method accessor972 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get970} $this]
               set equatorTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set971} $this $equatorTemperature]
             } else { error "Cannot unset C++ variable equatorTemperature" }
           }

public variable solarEquator
 method accessor975 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get973} $this]
               set solarEquator $tmp

             } elseif {$op == {write}} {
               return [{c++ set974} $this $solarEquator]
             } else { error "Cannot unset C++ variable solarEquator" }
           }

public variable polarTemperature
 method accessor978 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get976} $this]
               set polarTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set977} $this $polarTemperature]
             } else { error "Cannot unset C++ variable polarTemperature" }
           }

public variable altitudeTemperatureDelta
 method accessor981 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get979} $this]
               set altitudeTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set980} $this $altitudeTemperatureDelta]
             } else { error "Cannot unset C++ variable altitudeTemperatureDelta" }
           }

public variable waterTemperatureDelta
 method accessor984 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get982} $this]
               set waterTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set983} $this $waterTemperatureDelta]
             } else { error "Cannot unset C++ variable waterTemperatureDelta" }
           }

public variable freezingPoint
 method accessor987 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get985} $this]
               set freezingPoint $tmp

             } elseif {$op == {write}} {
               return [{c++ set986} $this $freezingPoint]
             } else { error "Cannot unset C++ variable freezingPoint" }
           }

public variable humidity
 method accessor990 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get988} $this]
               set humidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set989} $this $humidity]
             } else { error "Cannot unset C++ variable humidity" }
           }

public variable vapourTransport
 method accessor993 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get991} $this]
               set vapourTransport $tmp

             } elseif {$op == {write}} {
               return [{c++ set992} $this $vapourTransport]
             } else { error "Cannot unset C++ variable vapourTransport" }
           }

public variable mountainBlockage
 method accessor996 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get994} $this]
               set mountainBlockage $tmp

             } elseif {$op == {write}} {
               return [{c++ set995} $this $mountainBlockage]
             } else { error "Cannot unset C++ variable mountainBlockage" }
           }

public variable vegitationHumidity
 method accessor999 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get997} $this]
               set vegitationHumidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set998} $this $vegitationHumidity]
             } else { error "Cannot unset C++ variable vegitationHumidity" }
           }

public variable cities
 method accessor1002 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1000} $this]
               set cities $tmp

             } elseif {$op == {write}} {
               return [{c++ set1001} $this $cities]
             } else { error "Cannot unset C++ variable cities" }
           }

public variable maxCitySize
 method accessor1005 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1003} $this]
               set maxCitySize $tmp

             } elseif {$op == {write}} {
               return [{c++ set1004} $this $maxCitySize]
             } else { error "Cannot unset C++ variable maxCitySize" }
           }

public variable cityGrouping
 method accessor1008 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1006} $this]
               set cityGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set1007} $this $cityGrouping]
             } else { error "Cannot unset C++ variable cityGrouping" }
           }

public variable waterColour
 method accessor1011 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1009} $this]
               set waterColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1010} $this $waterColour]
             } else { error "Cannot unset C++ variable waterColour" }
           }

public variable vegitationColour
 method accessor1014 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1012} $this]
               set vegitationColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1013} $this $vegitationColour]
             } else { error "Cannot unset C++ variable vegitationColour" }
           }

public variable lowerPlanetColour
 method accessor1017 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1015} $this]
               set lowerPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1016} $this $lowerPlanetColour]
             } else { error "Cannot unset C++ variable lowerPlanetColour" }
           }

public variable upperPlanetColour
 method accessor1020 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1018} $this]
               set upperPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1019} $this $upperPlanetColour]
             } else { error "Cannot unset C++ variable upperPlanetColour" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set seed {}
            trace add variable seed {read write unset} "$this accessor927"
set continents {}
            trace add variable continents {read write unset} "$this accessor930"
set largeIslands {}
            trace add variable largeIslands {read write unset} "$this accessor933"
set smallIslands {}
            trace add variable smallIslands {read write unset} "$this accessor936"
set islandGrouping {}
            trace add variable islandGrouping {read write unset} "$this accessor939"
set landSlope {}
            trace add variable landSlope {read write unset} "$this accessor942"
set oceans {}
            trace add variable oceans {read write unset} "$this accessor945"
set seas {}
            trace add variable seas {read write unset} "$this accessor948"
set lakes {}
            trace add variable lakes {read write unset} "$this accessor951"
set rivers {}
            trace add variable rivers {read write unset} "$this accessor954"
set mountainRanges {}
            trace add variable mountainRanges {read write unset} "$this accessor957"
set mountainSteepness {}
            trace add variable mountainSteepness {read write unset} "$this accessor960"
set enormousMountains {}
            trace add variable enormousMountains {read write unset} "$this accessor963"
set craters {}
            trace add variable craters {read write unset} "$this accessor966"
set maxCraterSize {}
            trace add variable maxCraterSize {read write unset} "$this accessor969"
set equatorTemperature {}
            trace add variable equatorTemperature {read write unset} "$this accessor972"
set solarEquator {}
            trace add variable solarEquator {read write unset} "$this accessor975"
set polarTemperature {}
            trace add variable polarTemperature {read write unset} "$this accessor978"
set altitudeTemperatureDelta {}
            trace add variable altitudeTemperatureDelta {read write unset} "$this accessor981"
set waterTemperatureDelta {}
            trace add variable waterTemperatureDelta {read write unset} "$this accessor984"
set freezingPoint {}
            trace add variable freezingPoint {read write unset} "$this accessor987"
set humidity {}
            trace add variable humidity {read write unset} "$this accessor990"
set vapourTransport {}
            trace add variable vapourTransport {read write unset} "$this accessor993"
set mountainBlockage {}
            trace add variable mountainBlockage {read write unset} "$this accessor996"
set vegitationHumidity {}
            trace add variable vegitationHumidity {read write unset} "$this accessor999"
set cities {}
            trace add variable cities {read write unset} "$this accessor1002"
set maxCitySize {}
            trace add variable maxCitySize {read write unset} "$this accessor1005"
set cityGrouping {}
            trace add variable cityGrouping {read write unset} "$this accessor1008"
set waterColour {}
            trace add variable waterColour {read write unset} "$this accessor1011"
set vegitationColour {}
            trace add variable vegitationColour {read write unset} "$this accessor1014"
set lowerPlanetColour {}
            trace add variable lowerPlanetColour {read write unset} "$this accessor1017"
set upperPlanetColour {}
            trace add variable upperPlanetColour {read write unset} "$this accessor1020"
}
destructor {

trace remove variable seed {read write unset} "$this accessor927"
trace remove variable continents {read write unset} "$this accessor930"
trace remove variable largeIslands {read write unset} "$this accessor933"
trace remove variable smallIslands {read write unset} "$this accessor936"
trace remove variable islandGrouping {read write unset} "$this accessor939"
trace remove variable landSlope {read write unset} "$this accessor942"
trace remove variable oceans {read write unset} "$this accessor945"
trace remove variable seas {read write unset} "$this accessor948"
trace remove variable lakes {read write unset} "$this accessor951"
trace remove variable rivers {read write unset} "$this accessor954"
trace remove variable mountainRanges {read write unset} "$this accessor957"
trace remove variable mountainSteepness {read write unset} "$this accessor960"
trace remove variable enormousMountains {read write unset} "$this accessor963"
trace remove variable craters {read write unset} "$this accessor966"
trace remove variable maxCraterSize {read write unset} "$this accessor969"
trace remove variable equatorTemperature {read write unset} "$this accessor972"
trace remove variable solarEquator {read write unset} "$this accessor975"
trace remove variable polarTemperature {read write unset} "$this accessor978"
trace remove variable altitudeTemperatureDelta {read write unset} "$this accessor981"
trace remove variable waterTemperatureDelta {read write unset} "$this accessor984"
trace remove variable freezingPoint {read write unset} "$this accessor987"
trace remove variable humidity {read write unset} "$this accessor990"
trace remove variable vapourTransport {read write unset} "$this accessor993"
trace remove variable mountainBlockage {read write unset} "$this accessor996"
trace remove variable vegitationHumidity {read write unset} "$this accessor999"
trace remove variable cities {read write unset} "$this accessor1002"
trace remove variable maxCitySize {read write unset} "$this accessor1005"
trace remove variable cityGrouping {read write unset} "$this accessor1008"
trace remove variable waterColour {read write unset} "$this accessor1011"
trace remove variable vegitationColour {read write unset} "$this accessor1014"
trace remove variable lowerPlanetColour {read write unset} "$this accessor1017"
trace remove variable upperPlanetColour {read write unset} "$this accessor1020"
}
}

proc {planetgen_begin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1021} $a0 ]]
return $retpi
}
proc {planetgen_what} {  } {set retpi [uplevel 1 [list {c++ trampoline1023} ]]
set ret $retpi
return $ret
}
proc {planetgen_progress} {  } {set retpi [uplevel 1 [list {c++ trampoline1025} ]]
set ret $retpi
return $ret
}
proc {planetgen_done} {  } {set retpi [uplevel 1 [list {c++ trampoline1027} ]]
set ret $retpi
return $ret
}
proc {planetgen_kill} {  } {set retpi [uplevel 1 [list {c++ trampoline1029} ]]
return $retpi
}
proc {planetgen_save} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1031} $a0 $a1 ]]
return $retpi
}

proc {set_hud_message} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1033} $a0 $a1 ]]
return $retpi
}
proc {global_chat_post} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1035} $a0 ]]
return $retpi
}
proc {global_chat_post_local} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1037} $a0 ]]
return $retpi
}
proc {global_chat_post_remote} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1039} $a0 ]]
return $retpi
}
 proc accessor1043 {ignored ignored op} {
             global state
             if {$op == {read}} {
               set tmp [{c++ get1041} ]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set1042}  $state]
             } else { error "Cannot unset C++ variable state" }
           }


 proc accessor1045 {ignored ignored op} {
             global PLATFORM
             if {$op == {read}} {
               set tmp [{c++ get1044} ]
               set PLATFORM $tmp

             } elseif {$op == {write}} {
               error "Cannot write to PLATFORM"
             } else { error "Cannot unset C++ variable PLATFORM" }
           }

 proc accessor1047 {ignored ignored op} {
             global screenW
             if {$op == {read}} {
               set tmp [{c++ get1046} ]
               set screenW $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenW"
             } else { error "Cannot unset C++ variable screenW" }
           }

 proc accessor1049 {ignored ignored op} {
             global screenH
             if {$op == {read}} {
               set tmp [{c++ get1048} ]
               set screenH $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenH"
             } else { error "Cannot unset C++ variable screenH" }
           }

 proc accessor1051 {ignored ignored op} {
             global vheight
             if {$op == {read}} {
               set tmp [{c++ get1050} ]
               set vheight $tmp

             } elseif {$op == {write}} {
               error "Cannot write to vheight"
             } else { error "Cannot unset C++ variable vheight" }
           }

 proc accessor1054 {ignored ignored op} {
             global generalAlphaBlending
             if {$op == {read}} {
               set tmp [{c++ get1052} ]
               set generalAlphaBlending $tmp

             } elseif {$op == {write}} {
               return [{c++ set1053}  $generalAlphaBlending]
             } else { error "Cannot unset C++ variable generalAlphaBlending" }
           }

 proc accessor1057 {ignored ignored op} {
             global alphaBlendingEnabled
             if {$op == {read}} {
               set tmp [{c++ get1055} ]
               set alphaBlendingEnabled $tmp

             } elseif {$op == {write}} {
               return [{c++ set1056}  $alphaBlendingEnabled]
             } else { error "Cannot unset C++ variable alphaBlendingEnabled" }
           }

 proc accessor1060 {ignored ignored op} {
             global smoothScaling
             if {$op == {read}} {
               set tmp [{c++ get1058} ]
               set smoothScaling $tmp

             } elseif {$op == {write}} {
               return [{c++ set1059}  $smoothScaling]
             } else { error "Cannot unset C++ variable smoothScaling" }
           }

 proc accessor1063 {ignored ignored op} {
             global highQuality
             if {$op == {read}} {
               set tmp [{c++ get1061} ]
               set highQuality $tmp

             } elseif {$op == {write}} {
               return [{c++ set1062}  $highQuality]
             } else { error "Cannot unset C++ variable highQuality" }
           }

 proc accessor1066 {ignored ignored op} {
             global antialiasing
             if {$op == {read}} {
               set tmp [{c++ get1064} ]
               set antialiasing $tmp

             } elseif {$op == {write}} {
               return [{c++ set1065}  $antialiasing]
             } else { error "Cannot unset C++ variable antialiasing" }
           }


 proc accessor1068 {ignored ignored op} {
             global headless
             if {$op == {read}} {
               set tmp [{c++ get1067} ]
               set headless $tmp

             } elseif {$op == {write}} {
               error "Cannot write to headless"
             } else { error "Cannot unset C++ variable headless" }
           }

 proc accessor1071 {ignored ignored op} {
             global cameraX1
             if {$op == {read}} {
               set tmp [{c++ get1069} ]
               set cameraX1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1070}  $cameraX1]
             } else { error "Cannot unset C++ variable cameraX1" }
           }

 proc accessor1074 {ignored ignored op} {
             global cameraX2
             if {$op == {read}} {
               set tmp [{c++ get1072} ]
               set cameraX2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1073}  $cameraX2]
             } else { error "Cannot unset C++ variable cameraX2" }
           }

 proc accessor1077 {ignored ignored op} {
             global cameraY1
             if {$op == {read}} {
               set tmp [{c++ get1075} ]
               set cameraY1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1076}  $cameraY1]
             } else { error "Cannot unset C++ variable cameraY1" }
           }

 proc accessor1080 {ignored ignored op} {
             global cameraY2
             if {$op == {read}} {
               set tmp [{c++ get1078} ]
               set cameraY2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1079}  $cameraY2]
             } else { error "Cannot unset C++ variable cameraY2" }
           }

 proc accessor1083 {ignored ignored op} {
             global cameraCX
             if {$op == {read}} {
               set tmp [{c++ get1081} ]
               set cameraCX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1082}  $cameraCX]
             } else { error "Cannot unset C++ variable cameraCX" }
           }

 proc accessor1086 {ignored ignored op} {
             global cameraCY
             if {$op == {read}} {
               set tmp [{c++ get1084} ]
               set cameraCY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1085}  $cameraCY]
             } else { error "Cannot unset C++ variable cameraCY" }
           }

 proc accessor1089 {ignored ignored op} {
             global cameraZoom
             if {$op == {read}} {
               set tmp [{c++ get1087} ]
               set cameraZoom $tmp

             } elseif {$op == {write}} {
               return [{c++ set1088}  $cameraZoom]
             } else { error "Cannot unset C++ variable cameraZoom" }
           }

 proc accessor1092 {ignored ignored op} {
             global cursorX
             if {$op == {read}} {
               set tmp [{c++ get1090} ]
               set cursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1091}  $cursorX]
             } else { error "Cannot unset C++ variable cursorX" }
           }

 proc accessor1095 {ignored ignored op} {
             global cursorY
             if {$op == {read}} {
               set tmp [{c++ get1093} ]
               set cursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1094}  $cursorY]
             } else { error "Cannot unset C++ variable cursorY" }
           }

 proc accessor1098 {ignored ignored op} {
             global oldCursorX
             if {$op == {read}} {
               set tmp [{c++ get1096} ]
               set oldCursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1097}  $oldCursorX]
             } else { error "Cannot unset C++ variable oldCursorX" }
           }

 proc accessor1101 {ignored ignored op} {
             global oldCursorY
             if {$op == {read}} {
               set tmp [{c++ get1099} ]
               set oldCursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1100}  $oldCursorY]
             } else { error "Cannot unset C++ variable oldCursorY" }
           }


 proc accessor1103 {ignored ignored op} {
             global currentFrameTime
             if {$op == {read}} {
               set tmp [{c++ get1102} ]
               set currentFrameTime $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTime"
             } else { error "Cannot unset C++ variable currentFrameTime" }
           }

 proc accessor1105 {ignored ignored op} {
             global currentFrameTimeLeft
             if {$op == {read}} {
               set tmp [{c++ get1104} ]
               set currentFrameTimeLeft $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTimeLeft"
             } else { error "Cannot unset C++ variable currentFrameTimeLeft" }
           }

 proc accessor1107 {ignored ignored op} {
             global currentVFrameLast
             if {$op == {read}} {
               set tmp [{c++ get1106} ]
               set currentVFrameLast $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentVFrameLast"
             } else { error "Cannot unset C++ variable currentVFrameLast" }
           }

 proc accessor1109 {ignored ignored op} {
             global sparkCountMultiplier
             if {$op == {read}} {
               set tmp [{c++ get1108} ]
               set sparkCountMultiplier $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sparkCountMultiplier"
             } else { error "Cannot unset C++ variable sparkCountMultiplier" }
           }

 proc accessor1111 {ignored ignored op} {
             global gameClock
             if {$op == {read}} {
               set tmp [{c++ get1110} ]
               set gameClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to gameClock"
             } else { error "Cannot unset C++ variable gameClock" }
           }

 proc accessor1113 {ignored ignored op} {
             global STD_CELL_SZ
             if {$op == {read}} {
               set tmp [{c++ get1112} ]
               set STD_CELL_SZ $tmp

             } elseif {$op == {write}} {
               error "Cannot write to STD_CELL_SZ"
             } else { error "Cannot unset C++ variable STD_CELL_SZ" }
           }

::itcl::class {SquareIcon} {
inherit AObject
namespace eval :: {
proc {c++ new SquareIcon default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1115} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {load} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1117} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {unload} {  } {set retpi [uplevel 1 [list {c++ trampoline1119} $this ]]
return $retpi
}
method {isLoaded} {  } {set retpi [uplevel 1 [list {c++ trampoline1121} $this ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline1123} $this ]]
return $retpi
}
method {save} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1125} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}




::itcl::class {Antenna} {
inherit AObject
namespace eval :: {
proc {c++ new Antenna default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1130} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable tuner
 method accessor1134 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1132} $this]
               set tuner $tmp

             } elseif {$op == {write}} {
               return [{c++ set1133} $this $tuner]
             } else { error "Cannot unset C++ variable tuner" }
           }

method {setInternetInformation4} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline1135} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {setInternetInformation6} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline1137} $this $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
return $retpi
}
method {getGlobalID4} {  } {set retpi [uplevel 1 [list {c++ trampoline1139} $this ]]
set ret $retpi
return $ret
}
method {getGlobalID6} {  } {set retpi [uplevel 1 [list {c++ trampoline1141} $this ]]
set ret $retpi
return $ret
}
method {hasV4} {  } {set retpi [uplevel 1 [list {c++ trampoline1143} $this ]]
set ret $retpi
return $ret
}
method {hasV6} {  } {set retpi [uplevel 1 [list {c++ trampoline1145} $this ]]
set ret $retpi
return $ret
}
method {processIncomming} {  } {set retpi [uplevel 1 [list {c++ trampoline1147} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set tuner {}
            trace add variable tuner {read write unset} "$this accessor1134"







}
destructor {

trace remove variable tuner {read write unset} "$this accessor1134"







}
}

 proc accessor1150 {ignored ignored op} {
             global antenna
             if {$op == {read}} {
               set tmp [{c++ get1149} ]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

 proc accessor1153 {ignored ignored op} {
             global packetDropMask
             if {$op == {read}} {
               set tmp [{c++ get1151} ]
               set packetDropMask $tmp

             } elseif {$op == {write}} {
               return [{c++ set1152}  $packetDropMask]
             } else { error "Cannot unset C++ variable packetDropMask" }
           }


::itcl::class {Tuner} {
inherit AObject
namespace eval :: {
proc {c++ new Tuner default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1155} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {GlobalID} {
inherit AObject
namespace eval :: {
proc {c++ new GlobalID default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1158} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {toString} {  } {set retpi [uplevel 1 [list {c++ trampoline1160} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {PacketProcessor} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}



::itcl::class {NetworkAssembly} {
inherit AObject
public variable field
 method accessor1166 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1165} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable antenna
 method accessor1168 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1167} $this]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

namespace eval :: {
proc {c++ new NetworkAssembly default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1169} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getTuner} {  } {set retpi [uplevel 1 [list {c++ trampoline1171} $this ]]
set ret $retpi
return $ret
}
method {numConnections} {  } {set retpi [uplevel 1 [list {c++ trampoline1173} $this ]]
set ret $retpi
return $ret
}
method {getConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1175} $this $a0 ]]
set ret $retpi
return $ret
}
method {addConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1177} $this $a0 ]]
return $retpi
}
method {removeConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1179} $this $a0 ]]
return $retpi
}
method {addPacketProcessor} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1181} $this $a0 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1183} $this $a0 ]]
return $retpi
}
method {setFieldSize} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1185} $this $a0 $a1 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set field {}
            trace add variable field {read write unset} "$this accessor1166"
set antenna {}
            trace add variable antenna {read write unset} "$this accessor1168"









}
destructor {
trace remove variable field {read write unset} "$this accessor1166"
trace remove variable antenna {read write unset} "$this accessor1168"









}
}


::itcl::class {NetworkConnection} {
inherit PacketProcessor
public variable parent
 method accessor1189 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1188} $this]
               set parent $tmp

             } elseif {$op == {write}} {
               error "Cannot write to parent"
             } else { error "Cannot unset C++ variable parent" }
           }

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1190} $this $a0 ]]
return $retpi
}
method {getStatus} {  } {set retpi [uplevel 1 [list {c++ trampoline1192} $this ]]
set ret $retpi
return $ret
}
method {getDisconnectReason} {  } {set retpi [uplevel 1 [list {c++ trampoline1194} $this ]]
set ret $retpi
return $ret
}
method {setFieldSize} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1196} $this $a0 $a1 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set parent {}
            trace add variable parent {read write unset} "$this accessor1189"




}
destructor {
trace remove variable parent {read write unset} "$this accessor1189"




}
}


::itcl::class {ConnectionListener} {
inherit PacketProcessor
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}


::itcl::class {GameAdvertiser} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameAdvertiser default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline1200} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {setOverseerId} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1202} $this $a0 ]]
return $retpi
}
method {setPeerCount} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1204} $this $a0 ]]
return $retpi
}
method {setGameMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1206} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {GameDiscoverer} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameDiscoverer default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1209} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {start} {  } {set retpi [uplevel 1 [list {c++ trampoline1211} $this ]]
return $retpi
}
method {poll} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1213} $this $a0 ]]
return $retpi
}
method {progress} {  } {set retpi [uplevel 1 [list {c++ trampoline1215} $this ]]
set ret $retpi
return $ret
}
method {dumpResults} {  } {set retpi [uplevel 1 [list {c++ trampoline1217} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {





}
destructor {





}
}


::itcl::class {InputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

::itcl::class {OutputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

itcl::class fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {} {}
      } {}
    }
::itcl::class {fun<InputNetworkGeraet*:NetworkConnection*>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<InputNetworkGeraet*:NetworkConnection*> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1222} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
set ret $retpi
return $ret
}
proc {call} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1226} $a0 $a1 ]]
set ret $retpi
return $ret
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline1228} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}




::itcl::class {SeqTextOutputGeraet} {
inherit OutputNetworkGeraet
namespace eval :: {
proc {c++ new SeqTextOutputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1232} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {send} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1234} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      OutputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

::itcl::class {SeqTextInputGeraet} {
inherit InputNetworkGeraet
namespace eval :: {
proc {c++ new TclSeqTextInputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1237} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {receiveText} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveText"]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      InputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {ConfReg} {
inherit AObject
method {open} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1242} $this $a0 $a1 ]]
return $retpi
}
method {create} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1244} $this $a0 $a1 ]]
return $retpi
}
method {close} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1246} $this $a0 ]]
return $retpi
}
method {closeAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1248} $this ]]
return $retpi
}
method {modify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1250} $this $a0 ]]
return $retpi
}
method {unmodify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1252} $this $a0 ]]
return $retpi
}
method {sync} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1254} $this $a0 ]]
return $retpi
}
method {syncAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1256} $this ]]
return $retpi
}
method {revert} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1258} $this $a0 ]]
return $retpi
}
method {revertAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1260} $this ]]
return $retpi
}
method {addToWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1262} $this $a0 ]]
return $retpi
}
method {removeFromWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1264} $this $a0 ]]
return $retpi
}
method {clearWhitelist} {  } {set retpi [uplevel 1 [list {c++ trampoline1266} $this ]]
return $retpi
}
method {setWhitelistOnly} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1268} $this $a0 ]]
return $retpi
}
method {renameFile} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1270} $this $a0 $a1 ]]
return $retpi
}

method {exists} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1272} $this $a0 ]]
set ret $retpi
return $ret
}
method {bool} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1274} $this $a0 ]]
set ret $retpi
return $ret
}
method {int} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1276} $this $a0 ]]
set ret $retpi
return $ret
}
method {float} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1278} $this $a0 ]]
set ret $retpi
return $ret
}
method {str} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1280} $this $a0 ]]
set ret $retpi
return $ret
}
method {setb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1282} $this $a0 $a1 ]]
return $retpi
}
method {seti} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1284} $this $a0 $a1 ]]
return $retpi
}
method {setf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1286} $this $a0 $a1 ]]
return $retpi
}
method {sets} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1288} $this $a0 $a1 ]]
return $retpi
}
method {add} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1290} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addb} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1292} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addi} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1294} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addf} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1296} $this $a0 $a1 $a2 ]]
return $retpi
}
method {adds} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1298} $this $a0 $a1 $a2 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1300} $this $a0 ]]
return $retpi
}
method {append} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1302} $this $a0 $a1 ]]
return $retpi
}
method {appendb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1304} $this $a0 $a1 ]]
return $retpi
}
method {appendi} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1306} $this $a0 $a1 ]]
return $retpi
}
method {appendf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1308} $this $a0 $a1 ]]
return $retpi
}
method {appends} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1310} $this $a0 $a1 ]]
return $retpi
}
method {remix} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1312} $this $a0 $a1 ]]
return $retpi
}
method {name} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1314} $this $a0 ]]
set ret $retpi
return $ret
}
method {copy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1316} $this $a0 $a1 ]]
return $retpi
}
method {getType} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1318} $this $a0 ]]
set ret $retpi
return $ret
}
method {length} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1320} $this $a0 ]]
set ret $retpi
return $ret
}
method {isGroup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1322} $this $a0 ]]
set ret $retpi
return $ret
}
method {isArray} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1324} $this $a0 ]]
set ret $retpi
return $ret
}
method {isList} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1326} $this $a0 ]]
set ret $retpi
return $ret
}
method {isAggregate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1328} $this $a0 ]]
set ret $retpi
return $ret
}
method {isScalar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1330} $this $a0 ]]
set ret $retpi
return $ret
}
method {isNumber} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1332} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSourceLine} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1334} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
















































}
destructor {
















































}
}

 proc accessor1337 {ignored ignored op} {
             global globalConf
             if {$op == {read}} {
               set tmp [{c++ get1336} ]
               set globalConf $tmp

             } elseif {$op == {write}} {
               error "Cannot write to globalConf"
             } else { error "Cannot unset C++ variable globalConf" }
           }

proc {confcpy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1338} $a0 $a1 ]]
return $retpi
}
proc {l10n_acceptLanguage} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1340} $a0 ]]
return $retpi
}
proc {l10n_loadCatalogue} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1342} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {l10n_purgeCatalogue} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1344} $a0 ]]
return $retpi
}

proc {_} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1346} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
proc {namegenAny} {  } {set retpi [uplevel 1 [list {c++ trampoline1348} ]]
set ret $retpi
return $ret
}
proc {namegenGet} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1350} $a0 ]]
set ret $retpi
return $ret
}
proc {newInterpreter} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1352} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {delInterpreter} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1354} $a0 ]]
return $retpi
}

proc {safe_source} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1356} $a0 ]]
return $retpi
}
proc {bkg_start} {  } {set retpi [uplevel 1 [list {c++ trampoline1358} ]]
return $retpi
}
proc {bkg_req} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1360} $a0 ]]
return $retpi
}
proc {bkg_ans} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1362} $a0 ]]
return $retpi
}
proc {bkg_req2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1364} $a0 $a1 ]]
return $retpi
}
proc {bkg_ans2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1366} $a0 $a1 ]]
return $retpi
}
proc {bkg_rcv} {  } {set retpi [uplevel 1 [list {c++ trampoline1368} ]]
set ret $retpi
return $ret
}
proc {bkg_get} {  } {set retpi [uplevel 1 [list {c++ trampoline1370} ]]
set ret $retpi
return $ret
}
proc {bkg_wait} {  } {set retpi [uplevel 1 [list {c++ trampoline1372} ]]
return $retpi
}

proc {crypto_init} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1374} $a0 ]]
return $retpi
}
proc {crypto_rand} {  } {set retpi [uplevel 1 [list {c++ trampoline1376} ]]
set ret $retpi
return $ret
}
proc {crypto_powm} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1378} $a0 $a1 ]]
set ret $retpi
return $ret
}

proc {performValidation} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1380} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {getValidationResultA} {  } {set retpi [uplevel 1 [list {c++ trampoline1382} ]]
set ret $retpi
return $ret
}
proc {getValidationResultB} {  } {set retpi [uplevel 1 [list {c++ trampoline1384} ]]
set ret $retpi
return $ret
}

proc {networkTestListen} {  } {set retpi [uplevel 1 [list {c++ trampoline1386} ]]
return $retpi
}
proc {networkTestRun} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1388} $a0 $a1 ]]
set ret $retpi
return $ret
}

proc {ship_mixer_init} {  } {set retpi [uplevel 1 [list {c++ trampoline1390} ]]
return $retpi
}
proc {ship_mixer_end} {  } {set retpi [uplevel 1 [list {c++ trampoline1392} ]]
return $retpi
}

proc {debugTclExports} {  } {set retpi [uplevel 1 [list {c++ trampoline1394} ]]
return $retpi
}































set none {}
trace add variable none {read write unset} accessor60
set lshift {}
trace add variable lshift {read write unset} accessor62
set rshift {}
trace add variable rshift {read write unset} accessor64
set lctrl {}
trace add variable lctrl {read write unset} accessor66
set rctrl {}
trace add variable rctrl {read write unset} accessor68
set lalt {}
trace add variable lalt {read write unset} accessor70
set ralt {}
trace add variable ralt {read write unset} accessor72
set lmeta {}
trace add variable lmeta {read write unset} accessor74
set rmeta {}
trace add variable rmeta {read write unset} accessor76
set num {}
trace add variable num {read write unset} accessor78
set caps {}
trace add variable caps {read write unset} accessor80
set mode {}
trace add variable mode {read write unset} accessor82
set reserved {}
trace add variable reserved {read write unset} accessor84
set glueClass(SDL_keysym) yes





set glueClass(SDL_KeyboardEvent) yes




set SDL_BUTTON_1 {}
trace add variable SDL_BUTTON_1 {read write unset} accessor109
set SDL_BUTTON_2 {}
trace add variable SDL_BUTTON_2 {read write unset} accessor111
set SDL_BUTTON_3 {}
trace add variable SDL_BUTTON_3 {read write unset} accessor113
set SDL_BUTTON_4 {}
trace add variable SDL_BUTTON_4 {read write unset} accessor115
set SDL_BUTTON_5 {}
trace add variable SDL_BUTTON_5 {read write unset} accessor117

set SDL_DEFAULT_REPEAT_INTERVAL {}
trace add variable SDL_DEFAULT_REPEAT_INTERVAL {read write unset} accessor121
set SDL_DEFAULT_REPEAT_DELAY {}
trace add variable SDL_DEFAULT_REPEAT_DELAY {read write unset} accessor123


set glueClass(SDL_MouseMotionEvent) yes







set glueClass(SDL_MouseButtonEvent) yes










set glueClass(Font) yes












set sysfont {}
trace add variable sysfont {read write unset} accessor190
set sysfontStipple {}
trace add variable sysfontStipple {read write unset} accessor192
set glueClass(GameState) yes








set glueClass(InitState) yes



set gameClass {}
trace add variable gameClass {read write unset} accessor213
set humanShip {}
trace add variable humanShip {read write unset} accessor216
set testStateMode {}
trace add variable testStateMode {read write unset} accessor219
set testStateSize {}
trace add variable testStateSize {read write unset} accessor222
set glueClass(TestState) yes






set glueClass(GameObject) yes


































set glueClass(GameField) yes
















set glueClass(Blast) yes


















set glueClass(CellFragment) yes




set glueClass(PlasmaFire) yes




set glueClass(Explosion) yes













set glueClass(OldStyleExplosion) yes






set glueClass(LightTrail) yes














set glueClass(fun<void:Ship*,bool>) yes





set glueClass(radar_t) yes


set glueClass(Ship) yes







































































set glueClass(Shield) yes

















set glueClass(EnergyCharge) yes







set glueClass(MagnetoBomb) yes







set glueClass(SemiguidedBomb) yes


set glueClass(PlasmaBurst) yes






set glueClass(MonophasicEnergyPulse) yes


set glueClass(Missile) yes


set glueClass(EffectsHandler) yes





set nullEffectsHandler {}
trace add variable nullEffectsHandler {read write unset} accessor671
set glueClass(Background) yes






set glueClass(Planet) yes



set glueClass(StarField) yes




set glueClass(Nebula) yes










set glueClass(Camera) yes









set glueClass(DynamicCamera) yes














set glueClass(FixedCamera) yes



set glueClass(Controller) yes








set glueClass(HumanController) yes







set isCompositionBufferInUse {}
trace add variable isCompositionBufferInUse {read write unset} accessor777




set glueClass(AIControl) yes




set glueClass(GeneticAI) yes








set glueClass(GenAI) yes







set glueClass(CommonKeyboardClient) yes












set glueClass(ForwardingEffectsHandler) yes


set glueClass(Spectator) yes








set glueClass(GameEnv) yes











set glueClass(Manipulator) yes
























set planetgen_width {}
trace add variable planetgen_width {read write unset} accessor919
set planetgen_height {}
trace add variable planetgen_height {read write unset} accessor921
set glueClass(PlanetGeneratorParms) yes













































set state {}
trace add variable state {read write unset} accessor1043

set PLATFORM {}
trace add variable PLATFORM {read write unset} accessor1045
set screenW {}
trace add variable screenW {read write unset} accessor1047
set screenH {}
trace add variable screenH {read write unset} accessor1049
set vheight {}
trace add variable vheight {read write unset} accessor1051
set generalAlphaBlending {}
trace add variable generalAlphaBlending {read write unset} accessor1054
set alphaBlendingEnabled {}
trace add variable alphaBlendingEnabled {read write unset} accessor1057
set smoothScaling {}
trace add variable smoothScaling {read write unset} accessor1060
set highQuality {}
trace add variable highQuality {read write unset} accessor1063
set antialiasing {}
trace add variable antialiasing {read write unset} accessor1066

set headless {}
trace add variable headless {read write unset} accessor1068
set cameraX1 {}
trace add variable cameraX1 {read write unset} accessor1071
set cameraX2 {}
trace add variable cameraX2 {read write unset} accessor1074
set cameraY1 {}
trace add variable cameraY1 {read write unset} accessor1077
set cameraY2 {}
trace add variable cameraY2 {read write unset} accessor1080
set cameraCX {}
trace add variable cameraCX {read write unset} accessor1083
set cameraCY {}
trace add variable cameraCY {read write unset} accessor1086
set cameraZoom {}
trace add variable cameraZoom {read write unset} accessor1089
set cursorX {}
trace add variable cursorX {read write unset} accessor1092
set cursorY {}
trace add variable cursorY {read write unset} accessor1095
set oldCursorX {}
trace add variable oldCursorX {read write unset} accessor1098
set oldCursorY {}
trace add variable oldCursorY {read write unset} accessor1101

set currentFrameTime {}
trace add variable currentFrameTime {read write unset} accessor1103
set currentFrameTimeLeft {}
trace add variable currentFrameTimeLeft {read write unset} accessor1105
set currentVFrameLast {}
trace add variable currentVFrameLast {read write unset} accessor1107
set sparkCountMultiplier {}
trace add variable sparkCountMultiplier {read write unset} accessor1109
set gameClock {}
trace add variable gameClock {read write unset} accessor1111
set STD_CELL_SZ {}
trace add variable STD_CELL_SZ {read write unset} accessor1113
set glueClass(SquareIcon) yes










set glueClass(Antenna) yes










set antenna {}
trace add variable antenna {read write unset} accessor1150
set packetDropMask {}
trace add variable packetDropMask {read write unset} accessor1153

set glueClass(Tuner) yes



set glueClass(GlobalID) yes




set glueClass(PacketProcessor) yes



set glueClass(NetworkAssembly) yes













set glueClass(NetworkConnection) yes







set glueClass(ConnectionListener) yes


set glueClass(GameAdvertiser) yes






set glueClass(GameDiscoverer) yes







set glueClass(InputNetworkGeraet) yes

set glueClass(OutputNetworkGeraet) yes


set glueClass(fun<InputNetworkGeraet*:NetworkConnection*>) yes








set glueClass(SeqTextOutputGeraet) yes



set glueClass(SeqTextInputGeraet) yes




set glueClass(ConfReg) yes

















































set globalConf {}
trace add variable globalConf {read write unset} accessor1337





































safe_source tcl/autosource.tcl
