
  package require Itcl

  # AUTOGENERATED BY generate.tcl. DO NOT EDIT DIRECTLY.
  # See readme.txt.

  #Our base Tcl glue code (eval'd to hardwire the magic cookie)
  eval [format {
    itcl::class AObject {
      # Ensure all code uses the fully-qualified name for C++ to recognize it
      method fqn {} {::return $this}

      protected constructor {cppClass constname cppArgs} {
        if {[::string length $constname]} {
          # Intercept errors so we don't leak the magic number
          if {[catch {
            "::c++ new $cppClass $constname" $this %s {*}$cppArgs
          } err]} {
            error "Bad constructor call: $cppClass $constname: $err"
          }
        }
      }
      destructor {
        {::c++ delete} $this %s
      }

      method super {sup cname {args {}}} {
        ${sup}::constructor $sup $cname $args
      }

      # Prevent access to the magic cookie by redirecting
      # all info requests to the global one
      method info {args} {
        ::namespace eval :: ::info {*}$args
      }
    }
  } ${ABENDSTERN-MAGIC-COOKIE-1} ${ABENDSTERN-MAGIC-COOKIE-1}]
  unset ABENDSTERN-MAGIC-COOKIE-1

  # Have rename commit suicide
  # rename rename {}

  set glueClass(AObject) yes

  proc new {clazz args} {
    global glueClass
    if {[info exists glueClass($clazz)]} {
      [$clazz #auto $clazz [lindex $args 0] [lrange $args 1 [llength $args]]] fqn
    } else {
      [$clazz #auto {*}$args] fqn
    }
  }

proc {c++ delete} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1} $a0 $a1 ]]
return $retpi
}
proc {glBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline3} $a0 ]]
return $retpi
}
proc {glEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline5} ]]
return $retpi
}
proc {glVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline7} $a0 $a1 ]]
return $retpi
}
proc {glColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline9} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {glPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline11} ]]
return $retpi
}
proc {glPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline13} ]]
return $retpi
}
proc {glLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline15} ]]
return $retpi
}
proc {glTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline17} $a0 $a1 ]]
return $retpi
}
proc {glRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline19} $a0 ]]
return $retpi
}
proc {glScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline21} $a0 $a1 ]]
return $retpi
}
proc {glUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline23} $a0 ]]
return $retpi
}
proc {glReset} {  } {set retpi [uplevel 1 [list {c++ trampoline25} ]]
return $retpi
}

proc {acsgi_begin} {  } {set retpi [uplevel 1 [list {c++ trampoline27} ]]
return $retpi
}
proc {acsgi_end} {  } {set retpi [uplevel 1 [list {c++ trampoline29} ]]
return $retpi
}
proc {acsgi_draw} {  } {set retpi [uplevel 1 [list {c++ trampoline31} ]]
return $retpi
}
proc {acsgi_textNormal} { a0  } {set retpi [uplevel 1 [list {c++ trampoline33} $a0 ]]
return $retpi
}
proc {cglBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline35} $a0 ]]
return $retpi
}
proc {cglEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline37} ]]
return $retpi
}
proc {cglVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline39} $a0 $a1 ]]
return $retpi
}
proc {cglColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline41} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {cglPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline43} ]]
return $retpi
}
proc {cglPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline45} ]]
return $retpi
}
proc {cglLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline47} ]]
return $retpi
}
proc {cglTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline49} $a0 $a1 ]]
return $retpi
}
proc {cglRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline51} $a0 ]]
return $retpi
}
proc {cglScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline53} $a0 $a1 ]]
return $retpi
}
proc {cglUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline55} $a0 ]]
return $retpi
}
proc {cglText} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline57} $a0 $a1 $a2 ]]
return $retpi
}
 proc accessor60 {ignored ignored op} {
             global none
             if {$op == {read}} {
               set tmp [{c++ get59} ]
               set none $tmp

             } elseif {$op == {write}} {
               error "Cannot write to none"
             } else { error "Cannot unset C++ variable none" }
           }

 proc accessor62 {ignored ignored op} {
             global lshift
             if {$op == {read}} {
               set tmp [{c++ get61} ]
               set lshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lshift"
             } else { error "Cannot unset C++ variable lshift" }
           }

 proc accessor64 {ignored ignored op} {
             global rshift
             if {$op == {read}} {
               set tmp [{c++ get63} ]
               set rshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rshift"
             } else { error "Cannot unset C++ variable rshift" }
           }

 proc accessor66 {ignored ignored op} {
             global lctrl
             if {$op == {read}} {
               set tmp [{c++ get65} ]
               set lctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lctrl"
             } else { error "Cannot unset C++ variable lctrl" }
           }

 proc accessor68 {ignored ignored op} {
             global rctrl
             if {$op == {read}} {
               set tmp [{c++ get67} ]
               set rctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rctrl"
             } else { error "Cannot unset C++ variable rctrl" }
           }

 proc accessor70 {ignored ignored op} {
             global lalt
             if {$op == {read}} {
               set tmp [{c++ get69} ]
               set lalt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lalt"
             } else { error "Cannot unset C++ variable lalt" }
           }

 proc accessor72 {ignored ignored op} {
             global ralt
             if {$op == {read}} {
               set tmp [{c++ get71} ]
               set ralt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ralt"
             } else { error "Cannot unset C++ variable ralt" }
           }

 proc accessor74 {ignored ignored op} {
             global lmeta
             if {$op == {read}} {
               set tmp [{c++ get73} ]
               set lmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lmeta"
             } else { error "Cannot unset C++ variable lmeta" }
           }

 proc accessor76 {ignored ignored op} {
             global rmeta
             if {$op == {read}} {
               set tmp [{c++ get75} ]
               set rmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rmeta"
             } else { error "Cannot unset C++ variable rmeta" }
           }

 proc accessor78 {ignored ignored op} {
             global num
             if {$op == {read}} {
               set tmp [{c++ get77} ]
               set num $tmp

             } elseif {$op == {write}} {
               error "Cannot write to num"
             } else { error "Cannot unset C++ variable num" }
           }

 proc accessor80 {ignored ignored op} {
             global caps
             if {$op == {read}} {
               set tmp [{c++ get79} ]
               set caps $tmp

             } elseif {$op == {write}} {
               error "Cannot write to caps"
             } else { error "Cannot unset C++ variable caps" }
           }

 proc accessor82 {ignored ignored op} {
             global mode
             if {$op == {read}} {
               set tmp [{c++ get81} ]
               set mode $tmp

             } elseif {$op == {write}} {
               error "Cannot write to mode"
             } else { error "Cannot unset C++ variable mode" }
           }

 proc accessor84 {ignored ignored op} {
             global reserved
             if {$op == {read}} {
               set tmp [{c++ get83} ]
               set reserved $tmp

             } elseif {$op == {write}} {
               error "Cannot write to reserved"
             } else { error "Cannot unset C++ variable reserved" }
           }

::itcl::class {SDL_keysym} {
inherit AObject
public variable scancode
 method accessor88 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get86} $this]
               set scancode $tmp

             } elseif {$op == {write}} {
               return [{c++ set87} $this $scancode]
             } else { error "Cannot unset C++ variable scancode" }
           }

public variable sym
 method accessor91 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get89} $this]
               set sym $tmp

             } elseif {$op == {write}} {
               return [{c++ set90} $this $sym]
             } else { error "Cannot unset C++ variable sym" }
           }

public variable mod
 method accessor94 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get92} $this]
               set mod $tmp

             } elseif {$op == {write}} {
               return [{c++ set93} $this $mod]
             } else { error "Cannot unset C++ variable mod" }
           }

public variable unicode
 method accessor97 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get95} $this]
               set unicode $tmp

             } elseif {$op == {write}} {
               return [{c++ set96} $this $unicode]
             } else { error "Cannot unset C++ variable unicode" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set scancode {}
            trace add variable scancode {read write unset} "$this accessor88"
set sym {}
            trace add variable sym {read write unset} "$this accessor91"
set mod {}
            trace add variable mod {read write unset} "$this accessor94"
set unicode {}
            trace add variable unicode {read write unset} "$this accessor97"
}
destructor {
trace remove variable scancode {read write unset} "$this accessor88"
trace remove variable sym {read write unset} "$this accessor91"
trace remove variable mod {read write unset} "$this accessor94"
trace remove variable unicode {read write unset} "$this accessor97"
}
}

::itcl::class {SDL_KeyboardEvent} {
inherit AObject
public variable type
 method accessor101 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get99} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set100} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor104 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get102} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set103} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable keysym
 method accessor107 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get105} $this]
               set keysym $tmp

             } elseif {$op == {write}} {
               return [{c++ set106} $this $keysym]
             } else { error "Cannot unset C++ variable keysym" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor101"
set state {}
            trace add variable state {read write unset} "$this accessor104"
set keysym {}
            trace add variable keysym {read write unset} "$this accessor107"
}
destructor {
trace remove variable type {read write unset} "$this accessor101"
trace remove variable state {read write unset} "$this accessor104"
trace remove variable keysym {read write unset} "$this accessor107"
}
}

 proc accessor109 {ignored ignored op} {
             global SDL_BUTTON_1
             if {$op == {read}} {
               set tmp [{c++ get108} ]
               set SDL_BUTTON_1 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_1"
             } else { error "Cannot unset C++ variable SDL_BUTTON_1" }
           }

 proc accessor111 {ignored ignored op} {
             global SDL_BUTTON_2
             if {$op == {read}} {
               set tmp [{c++ get110} ]
               set SDL_BUTTON_2 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_2"
             } else { error "Cannot unset C++ variable SDL_BUTTON_2" }
           }

 proc accessor113 {ignored ignored op} {
             global SDL_BUTTON_3
             if {$op == {read}} {
               set tmp [{c++ get112} ]
               set SDL_BUTTON_3 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_3"
             } else { error "Cannot unset C++ variable SDL_BUTTON_3" }
           }

 proc accessor115 {ignored ignored op} {
             global SDL_BUTTON_4
             if {$op == {read}} {
               set tmp [{c++ get114} ]
               set SDL_BUTTON_4 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_4"
             } else { error "Cannot unset C++ variable SDL_BUTTON_4" }
           }

 proc accessor117 {ignored ignored op} {
             global SDL_BUTTON_5
             if {$op == {read}} {
               set tmp [{c++ get116} ]
               set SDL_BUTTON_5 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_5"
             } else { error "Cannot unset C++ variable SDL_BUTTON_5" }
           }

proc {SDL_GetModState} {  } {set retpi [uplevel 1 [list {c++ trampoline118} ]]
set ret $retpi
return $ret
}
 proc accessor121 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_INTERVAL
             if {$op == {read}} {
               set tmp [{c++ get120} ]
               set SDL_DEFAULT_REPEAT_INTERVAL $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_INTERVAL"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_INTERVAL" }
           }

 proc accessor123 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_DELAY
             if {$op == {read}} {
               set tmp [{c++ get122} ]
               set SDL_DEFAULT_REPEAT_DELAY $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_DELAY"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_DELAY" }
           }

proc {SDL_EnableKeyRepeat} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline124} $a0 $a1 ]]
return $retpi
}

::itcl::class {SDL_MouseMotionEvent} {
inherit AObject
public variable type
 method accessor129 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get127} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set128} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor132 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get130} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set131} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor135 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get133} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set134} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor138 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get136} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set137} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

public variable xrel
 method accessor141 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get139} $this]
               set xrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set140} $this $xrel]
             } else { error "Cannot unset C++ variable xrel" }
           }

public variable yrel
 method accessor144 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get142} $this]
               set yrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set143} $this $yrel]
             } else { error "Cannot unset C++ variable yrel" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor129"
set state {}
            trace add variable state {read write unset} "$this accessor132"
set x {}
            trace add variable x {read write unset} "$this accessor135"
set y {}
            trace add variable y {read write unset} "$this accessor138"
set xrel {}
            trace add variable xrel {read write unset} "$this accessor141"
set yrel {}
            trace add variable yrel {read write unset} "$this accessor144"
}
destructor {
trace remove variable type {read write unset} "$this accessor129"
trace remove variable state {read write unset} "$this accessor132"
trace remove variable x {read write unset} "$this accessor135"
trace remove variable y {read write unset} "$this accessor138"
trace remove variable xrel {read write unset} "$this accessor141"
trace remove variable yrel {read write unset} "$this accessor144"
}
}

::itcl::class {SDL_MouseButtonEvent} {
inherit AObject
public variable type
 method accessor148 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get146} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set147} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable which
 method accessor151 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get149} $this]
               set which $tmp

             } elseif {$op == {write}} {
               return [{c++ set150} $this $which]
             } else { error "Cannot unset C++ variable which" }
           }

public variable button
 method accessor154 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get152} $this]
               set button $tmp

             } elseif {$op == {write}} {
               return [{c++ set153} $this $button]
             } else { error "Cannot unset C++ variable button" }
           }

public variable state
 method accessor157 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get155} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set156} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor160 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get158} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set159} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor163 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get161} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set162} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor148"
set which {}
            trace add variable which {read write unset} "$this accessor151"
set button {}
            trace add variable button {read write unset} "$this accessor154"
set state {}
            trace add variable state {read write unset} "$this accessor157"
set x {}
            trace add variable x {read write unset} "$this accessor160"
set y {}
            trace add variable y {read write unset} "$this accessor163"
}
destructor {
trace remove variable type {read write unset} "$this accessor148"
trace remove variable which {read write unset} "$this accessor151"
trace remove variable button {read write unset} "$this accessor154"
trace remove variable state {read write unset} "$this accessor157"
trace remove variable x {read write unset} "$this accessor160"
trace remove variable y {read write unset} "$this accessor163"
}
}

proc {SDL_WarpMouse} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline164} $a0 $a1 ]]
return $retpi
}
proc {SDL_GetTicks} {  } {set retpi [uplevel 1 [list {c++ trampoline166} ]]
set ret $retpi
return $ret
}

::itcl::class {Font} {
inherit AObject
namespace eval :: {
proc {c++ new Font default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline169} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}


method {charWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline171} $this $a0 ]]
set ret $retpi
return $ret
}
method {width} { a0  } {set retpi [uplevel 1 [list {c++ trampoline173} $this $a0 ]]
set ret $retpi
return $ret
}
method {getHeight} {  } {set retpi [uplevel 1 [list {c++ trampoline175} $this ]]
set ret $retpi
return $ret
}
method {getRise} {  } {set retpi [uplevel 1 [list {c++ trampoline177} $this ]]
set ret $retpi
return $ret
}
method {getDip} {  } {set retpi [uplevel 1 [list {c++ trampoline179} $this ]]
set ret $retpi
return $ret
}
method {preDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline181} $this ]]
return $retpi
}
method {postDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline183} $this ]]
return $retpi
}
method {drawCh} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline185} $this $a0 $a1 $a2 ]]
return $retpi
}
method {drawStr} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline187} $this $a0 $a1 $a2 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {











}
destructor {











}
}

 proc accessor190 {ignored ignored op} {
             global sysfont
             if {$op == {read}} {
               set tmp [{c++ get189} ]
               set sysfont $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfont"
             } else { error "Cannot unset C++ variable sysfont" }
           }

 proc accessor192 {ignored ignored op} {
             global sysfontStipple
             if {$op == {read}} {
               set tmp [{c++ get191} ]
               set sysfontStipple $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfontStipple"
             } else { error "Cannot unset C++ variable sysfontStipple" }
           }

::itcl::class {GameState} {
inherit AObject
namespace eval :: {
proc {c++ new TclGameState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline194} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {configureGL} {  } {set retpi [uplevel 1 [list {c++ deftramp201} $this ]]
return $retpi
}
method {keyboard} { a0  } {set retpi [uplevel 1 [list {c++ deftramp203} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ deftramp205} $this $a0 ]]
return $retpi
}
method {mouseButton} { a0  } {set retpi [uplevel 1 [list {c++ deftramp207} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {InitState} {
inherit GameState
namespace eval :: {
proc {c++ new InitState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline209} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


 proc accessor213 {ignored ignored op} {
             global gameClass
             if {$op == {read}} {
               set tmp [{c++ get211} ]
               set gameClass $tmp

             } elseif {$op == {write}} {
               return [{c++ set212}  $gameClass]
             } else { error "Cannot unset C++ variable gameClass" }
           }

 proc accessor216 {ignored ignored op} {
             global humanShip
             if {$op == {read}} {
               set tmp [{c++ get214} ]
               set humanShip $tmp

             } elseif {$op == {write}} {
               return [{c++ set215}  $humanShip]
             } else { error "Cannot unset C++ variable humanShip" }
           }

 proc accessor219 {ignored ignored op} {
             global testStateMode
             if {$op == {read}} {
               set tmp [{c++ get217} ]
               set testStateMode $tmp

             } elseif {$op == {write}} {
               return [{c++ set218}  $testStateMode]
             } else { error "Cannot unset C++ variable testStateMode" }
           }

 proc accessor222 {ignored ignored op} {
             global testStateSize
             if {$op == {read}} {
               set tmp [{c++ get220} ]
               set testStateSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set221}  $testStateSize]
             } else { error "Cannot unset C++ variable testStateSize" }
           }

::itcl::class {TestState} {
inherit GameState
namespace eval :: {
proc {c++ new TestState default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline224} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline226} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline228} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}



::itcl::class {GameObject} {
inherit AObject
public variable isRemote
 method accessor233 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get232} $this]
               set isRemote $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isRemote"
             } else { error "Cannot unset C++ variable isRemote" }
           }

public variable isExportable
 method accessor236 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get234} $this]
               set isExportable $tmp

             } elseif {$op == {write}} {
               return [{c++ set235} $this $isExportable]
             } else { error "Cannot unset C++ variable isExportable" }
           }

public variable isTransient
 method accessor239 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get237} $this]
               set isTransient $tmp

             } elseif {$op == {write}} {
               return [{c++ set238} $this $isTransient]
             } else { error "Cannot unset C++ variable isTransient" }
           }

public variable generatesUpdates
 method accessor242 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get240} $this]
               set generatesUpdates $tmp

             } elseif {$op == {write}} {
               return [{c++ set241} $this $generatesUpdates]
             } else { error "Cannot unset C++ variable generatesUpdates" }
           }

public variable tag
 method accessor245 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get243} $this]
               set tag $tmp

             } elseif {$op == {write}} {
               return [{c++ set244} $this $tag]
             } else { error "Cannot unset C++ variable tag" }
           }

public variable ignoreNetworkTag
 method accessor248 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get246} $this]
               set ignoreNetworkTag $tmp

             } elseif {$op == {write}} {
               return [{c++ set247} $this $ignoreNetworkTag]
             } else { error "Cannot unset C++ variable ignoreNetworkTag" }
           }

public variable lastRemoteUpdateSeq
 method accessor250 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get249} $this]
               set lastRemoteUpdateSeq $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lastRemoteUpdateSeq"
             } else { error "Cannot unset C++ variable lastRemoteUpdateSeq" }
           }

protected variable field
 method accessor252 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get251} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable isDead
 method accessor254 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get253} $this]
               set isDead $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isDead"
             } else { error "Cannot unset C++ variable isDead" }
           }

protected variable x
 method accessor257 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get255} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set256} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

protected variable y
 method accessor260 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get258} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set259} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

protected variable vx
 method accessor263 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get261} $this]
               set vx $tmp

             } elseif {$op == {write}} {
               return [{c++ set262} $this $vx]
             } else { error "Cannot unset C++ variable vx" }
           }

protected variable vy
 method accessor266 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get264} $this]
               set vy $tmp

             } elseif {$op == {write}} {
               return [{c++ set265} $this $vy]
             } else { error "Cannot unset C++ variable vy" }
           }

protected variable includeInCollisionDetection
 method accessor269 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get267} $this]
               set includeInCollisionDetection $tmp

             } elseif {$op == {write}} {
               return [{c++ set268} $this $includeInCollisionDetection]
             } else { error "Cannot unset C++ variable includeInCollisionDetection" }
           }

protected variable classification
 method accessor272 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get270} $this]
               set classification $tmp

             } elseif {$op == {write}} {
               return [{c++ set271} $this $classification]
             } else { error "Cannot unset C++ variable classification" }
           }

protected variable decorative
 method accessor275 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get273} $this]
               set decorative $tmp

             } elseif {$op == {write}} {
               return [{c++ set274} $this $decorative]
             } else { error "Cannot unset C++ variable decorative" }
           }

namespace eval :: {
proc {c++ new TclGameObject default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline276} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject position} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline278} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject velocity} { a0 a1 a2 a3 a4 a5 a6  } {set retpi [uplevel 1 [list {c++ trampoline280} $a0 $a1 $a2 $a3 $a4 $a5 $a6 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {getX} {  } {set retpi [uplevel 1 [list {c++ trampoline286} $this ]]
set ret $retpi
return $ret
}
method {getY} {  } {set retpi [uplevel 1 [list {c++ trampoline288} $this ]]
set ret $retpi
return $ret
}
method {getVX} {  } {set retpi [uplevel 1 [list {c++ trampoline290} $this ]]
set ret $retpi
return $ret
}
method {getVY} {  } {set retpi [uplevel 1 [list {c++ trampoline292} $this ]]
set ret $retpi
return $ret
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline294} $this ]]
set ret $retpi
return $ret
}
method {isDecorative} {  } {set retpi [uplevel 1 [list {c++ trampoline296} $this ]]
set ret $retpi
return $ret
}
method {getClassification} {  } {set retpi [uplevel 1 [list {c++ trampoline298} $this ]]
set ret $retpi
return $ret
}
method {okToDecorate} {  } {set retpi [uplevel 1 [list {c++ trampoline300} $this ]]
return $retpi
}
method {teleport} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp303} $this $a0 $a1 $a2 ]]
return $retpi
}
method {getRotation} {  } {set retpi [uplevel 1 [list {c++ deftramp305} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getRadius"]
set ret $retpi
return $ret
}
method {isCollideable} {  } {set retpi [uplevel 1 [list {c++ deftramp309} $this ]]
set ret $retpi
return $ret
}
method {checkCollision} { a0  } {set retpi [uplevel 1 [list {c++ deftramp311} $this $a0 ]]
set ret $retpi
return $ret
}
method {del} {  } {set retpi [uplevel 1 [list {c++ trampoline312} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set isRemote {}
            trace add variable isRemote {read write unset} "$this accessor233"
set isExportable {}
            trace add variable isExportable {read write unset} "$this accessor236"
set isTransient {}
            trace add variable isTransient {read write unset} "$this accessor239"
set generatesUpdates {}
            trace add variable generatesUpdates {read write unset} "$this accessor242"
set tag {}
            trace add variable tag {read write unset} "$this accessor245"
set ignoreNetworkTag {}
            trace add variable ignoreNetworkTag {read write unset} "$this accessor248"
set lastRemoteUpdateSeq {}
            trace add variable lastRemoteUpdateSeq {read write unset} "$this accessor250"
set field {}
            trace add variable field {read write unset} "$this accessor252"
set isDead {}
            trace add variable isDead {read write unset} "$this accessor254"
set x {}
            trace add variable x {read write unset} "$this accessor257"
set y {}
            trace add variable y {read write unset} "$this accessor260"
set vx {}
            trace add variable vx {read write unset} "$this accessor263"
set vy {}
            trace add variable vy {read write unset} "$this accessor266"
set includeInCollisionDetection {}
            trace add variable includeInCollisionDetection {read write unset} "$this accessor269"
set classification {}
            trace add variable classification {read write unset} "$this accessor272"
set decorative {}
            trace add variable decorative {read write unset} "$this accessor275"



















}
destructor {
trace remove variable isRemote {read write unset} "$this accessor233"
trace remove variable isExportable {read write unset} "$this accessor236"
trace remove variable isTransient {read write unset} "$this accessor239"
trace remove variable generatesUpdates {read write unset} "$this accessor242"
trace remove variable tag {read write unset} "$this accessor245"
trace remove variable ignoreNetworkTag {read write unset} "$this accessor248"
trace remove variable lastRemoteUpdateSeq {read write unset} "$this accessor250"
trace remove variable field {read write unset} "$this accessor252"
trace remove variable isDead {read write unset} "$this accessor254"
trace remove variable x {read write unset} "$this accessor257"
trace remove variable y {read write unset} "$this accessor260"
trace remove variable vx {read write unset} "$this accessor263"
trace remove variable vy {read write unset} "$this accessor266"
trace remove variable includeInCollisionDetection {read write unset} "$this accessor269"
trace remove variable classification {read write unset} "$this accessor272"
trace remove variable decorative {read write unset} "$this accessor275"



















}
}


::itcl::class {GameField} {
inherit AObject
public variable fieldClock
 method accessor317 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get316} $this]
               set fieldClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to fieldClock"
             } else { error "Cannot unset C++ variable fieldClock" }
           }

public variable width
 method accessor320 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get318} $this]
               set width $tmp

             } elseif {$op == {write}} {
               return [{c++ set319} $this $width]
             } else { error "Cannot unset C++ variable width" }
           }

public variable height
 method accessor323 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get321} $this]
               set height $tmp

             } elseif {$op == {write}} {
               return [{c++ set322} $this $height]
             } else { error "Cannot unset C++ variable height" }
           }

public variable effects
 method accessor326 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get324} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set325} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable perfectRadar
 method accessor329 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get327} $this]
               set perfectRadar $tmp

             } elseif {$op == {write}} {
               return [{c++ set328} $this $perfectRadar]
             } else { error "Cannot unset C++ variable perfectRadar" }
           }

namespace eval :: {
proc {c++ new GameField default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline330} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline332} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline334} $this ]]
return $retpi
}
method {at} { a0  } {set retpi [uplevel 1 [list {c++ trampoline336} $this $a0 ]]
set ret $retpi
return $ret
}
method {size} {  } {set retpi [uplevel 1 [list {c++ trampoline338} $this ]]
set ret $retpi
return $ret
}
method {add} { a0  } {set retpi [uplevel 1 [list {c++ trampoline340} $this $a0 ]]
return $retpi
}
method {addBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline342} $this $a0 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline344} $this $a0 ]]
return $retpi
}
method {inject} { a0  } {set retpi [uplevel 1 [list {c++ trampoline346} $this $a0 ]]
return $retpi
}
method {clear} {  } {set retpi [uplevel 1 [list {c++ trampoline348} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set fieldClock {}
            trace add variable fieldClock {read write unset} "$this accessor317"
set width {}
            trace add variable width {read write unset} "$this accessor320"
set height {}
            trace add variable height {read write unset} "$this accessor323"
set effects {}
            trace add variable effects {read write unset} "$this accessor326"
set perfectRadar {}
            trace add variable perfectRadar {read write unset} "$this accessor329"










}
destructor {
trace remove variable fieldClock {read write unset} "$this accessor317"
trace remove variable width {read write unset} "$this accessor320"
trace remove variable height {read write unset} "$this accessor323"
trace remove variable effects {read write unset} "$this accessor326"
trace remove variable perfectRadar {read write unset} "$this accessor329"










}
}

::itcl::class {Blast} {
inherit GameObject
public variable blame
 method accessor352 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get351} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               error "Cannot write to blame"
             } else { error "Cannot unset C++ variable blame" }
           }

namespace eval :: {
proc {c++ new Blast default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline353} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDirect} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline355} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withSize} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline357} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withADC} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline359} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDecor} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline361} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDamage} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12  } {set retpi [uplevel 1 [list {c++ trampoline363} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast nonDamageCopy} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline365} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline367} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline369} $this ]]
return $retpi
}
method {getFalloff} {  } {set retpi [uplevel 1 [list {c++ trampoline371} $this ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline373} $this ]]
set ret $retpi
return $ret
}
method {getStrengthAt} { a0  } {set retpi [uplevel 1 [list {c++ trampoline375} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrengthUpon} { a0  } {set retpi [uplevel 1 [list {c++ trampoline377} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline379} $this ]]
set ret $retpi
return $ret
}
method {isDirect} {  } {set retpi [uplevel 1 [list {c++ trampoline381} $this ]]
set ret $retpi
return $ret
}
method {causesDamage} {  } {set retpi [uplevel 1 [list {c++ trampoline383} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set blame {}
            trace add variable blame {read write unset} "$this accessor352"
















}
destructor {
trace remove variable blame {read write unset} "$this accessor352"
















}
}

::itcl::class {CellFragment} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline386} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline388} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline390} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {PlasmaFire} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline393} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline395} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline397} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {Explosion} {
inherit GameObject
public variable hungry
 method accessor402 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get400} $this]
               set hungry $tmp

             } elseif {$op == {write}} {
               return [{c++ set401} $this $hungry]
             } else { error "Cannot unset C++ variable hungry" }
           }

namespace eval :: {
proc {c++ new Explosion stationary} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline403} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion velocity} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13  } {set retpi [uplevel 1 [list {c++ trampoline405} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion smeared} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15  } {set retpi [uplevel 1 [list {c++ trampoline407} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 $a15 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion by} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline409} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

method {multiExplosion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline411} $this $a0 ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline413} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline415} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline417} $this ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline419} $this ]]
set ret $retpi
return $ret
}
method {getDensity} {  } {set retpi [uplevel 1 [list {c++ trampoline421} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set hungry {}
            trace add variable hungry {read write unset} "$this accessor402"










}
destructor {
trace remove variable hungry {read write unset} "$this accessor402"










}
}


::itcl::class {OldStyleExplosion} {
inherit GameObject
namespace eval :: {
proc {c++ new OldStyleExplosion default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline424} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline426} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline428} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline430} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {LightTrail} {
inherit GameObject
namespace eval :: {
proc {c++ new LightTrail default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14  } {set retpi [uplevel 1 [list {c++ trampoline433} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline435} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline437} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline439} $this ]]
set ret $retpi
return $ret
}
method {setWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline441} $this $a0 ]]
return $retpi
}
method {emit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline443} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}







itcl::class fun<void:Ship*,bool>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<void:Ship*,bool>::fun_t {} {}
      } {}
    }
::itcl::class {fun<void:Ship*,bool>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<void:Ship*,bool> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline451} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
return $retpi
}
proc {call} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline455} $a0 $a1 $a2 ]]
return $retpi
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline457} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

::itcl::class {radar_t} {
inherit AObject
namespace eval :: {
proc {c++ new radar_t default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline460} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Ship} {
inherit GameObject
public variable controller
 method accessor465 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get463} $this]
               set controller $tmp

             } elseif {$op == {write}} {
               return [{c++ set464} $this $controller]
             } else { error "Cannot unset C++ variable controller" }
           }

public variable effects
 method accessor468 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get466} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set467} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable shipExistenceFailure
 method accessor471 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get469} $this]
               set shipExistenceFailure $tmp

             } elseif {$op == {write}} {
               return [{c++ set470} $this $shipExistenceFailure]
             } else { error "Cannot unset C++ variable shipExistenceFailure" }
           }


proc {cellCoord} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline472} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {cellSubCoord} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline474} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}
public variable insignia
 method accessor478 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get476} $this]
               set insignia $tmp

             } elseif {$op == {write}} {
               return [{c++ set477} $this $insignia]
             } else { error "Cannot unset C++ variable insignia" }
           }

public variable blame
 method accessor481 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get479} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               return [{c++ set480} $this $blame]
             } else { error "Cannot unset C++ variable blame" }
           }

public variable score
 method accessor484 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get482} $this]
               set score $tmp

             } elseif {$op == {write}} {
               return [{c++ set483} $this $score]
             } else { error "Cannot unset C++ variable score" }
           }

public variable damageMultiplier
 method accessor487 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get485} $this]
               set damageMultiplier $tmp

             } elseif {$op == {write}} {
               return [{c++ set486} $this $damageMultiplier]
             } else { error "Cannot unset C++ variable damageMultiplier" }
           }

public variable diedSpontaneously
 method accessor489 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get488} $this]
               set diedSpontaneously $tmp

             } elseif {$op == {write}} {
               error "Cannot write to diedSpontaneously"
             } else { error "Cannot unset C++ variable diedSpontaneously" }
           }

public variable typeName
 method accessor491 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get490} $this]
               set typeName $tmp

             } elseif {$op == {write}} {
               error "Cannot write to typeName"
             } else { error "Cannot unset C++ variable typeName" }
           }

namespace eval :: {
proc {c++ new Ship default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline492} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}


method {refreshUpdates} {  } {set retpi [uplevel 1 [list {c++ trampoline494} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline496} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline498} $this ]]
return $retpi
}

method {getVRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline500} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline502} $this ]]
set ret $retpi
return $ret
}
method {glSetColour0} {  } {set retpi [uplevel 1 [list {c++ trampoline504} $this ]]
return $retpi
}
method {glSetColour1} { a0  } {set retpi [uplevel 1 [list {c++ trampoline506} $this $a0 ]]
return $retpi
}
method {glSetColour2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline508} $this $a0 $a1 ]]
return $retpi
}
method {setThrust} { a0  } {set retpi [uplevel 1 [list {c++ trampoline510} $this $a0 ]]
return $retpi
}
method {getThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline512} $this ]]
set ret $retpi
return $ret
}
method {getTrueThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline514} $this ]]
set ret $retpi
return $ret
}
method {setThrustOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline516} $this $a0 ]]
return $retpi
}
method {isThrustOn} {  } {set retpi [uplevel 1 [list {c++ trampoline518} $this ]]
set ret $retpi
return $ret
}
method {setBrakeOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline520} $this $a0 ]]
return $retpi
}
method {isBrakeOn} {  } {set retpi [uplevel 1 [list {c++ trampoline522} $this ]]
set ret $retpi
return $ret
}
method {configureEngines} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline524} $this $a0 $a1 $a2 ]]
return $retpi
}
method {configureEngines2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline526} $this $a0 $a1 ]]
return $retpi
}
method {getAcceleration} {  } {set retpi [uplevel 1 [list {c++ trampoline528} $this ]]
set ret $retpi
return $ret
}
method {getRotationRate} {  } {set retpi [uplevel 1 [list {c++ trampoline530} $this ]]
set ret $retpi
return $ret
}
method {getRotationAccel} {  } {set retpi [uplevel 1 [list {c++ trampoline532} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline534} $this ]]
set ret $retpi
return $ret
}
method {getPowerUsagePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline536} $this ]]
set ret $retpi
return $ret
}
method {getPowerSupply} {  } {set retpi [uplevel 1 [list {c++ trampoline538} $this ]]
set ret $retpi
return $ret
}
method {getPowerDrain} {  } {set retpi [uplevel 1 [list {c++ trampoline540} $this ]]
set ret $retpi
return $ret
}
method {getCurrentCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline542} $this ]]
set ret $retpi
return $ret
}
method {getMaximumCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline544} $this ]]
set ret $retpi
return $ret
}
method {getCapacitancePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline546} $this ]]
set ret $retpi
return $ret
}
method {setColour} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline548} $this $a0 $a1 $a2 ]]
return $retpi
}
method {destroyGraphicsInfo} {  } {set retpi [uplevel 1 [list {c++ trampoline550} $this ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline552} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline554} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline556} $this ]]
set ret $retpi
return $ret
}
method {drawPower} { a0  } {set retpi [uplevel 1 [list {c++ trampoline558} $this $a0 ]]
set ret $retpi
return $ret
}
method {getReinforcement} {  } {set retpi [uplevel 1 [list {c++ trampoline560} $this ]]
set ret $retpi
return $ret
}
method {setReinforcement} { a0  } {set retpi [uplevel 1 [list {c++ trampoline562} $this $a0 ]]
return $retpi
}
method {enableSoundEffects} {  } {set retpi [uplevel 1 [list {c++ trampoline564} $this ]]
return $retpi
}

method {hasPower} {  } {set retpi [uplevel 1 [list {c++ trampoline566} $this ]]
set ret $retpi
return $ret
}
method {spontaneouslyDie} {  } {set retpi [uplevel 1 [list {c++ trampoline568} $this ]]
return $retpi
}
method {getCoolingMult} {  } {set retpi [uplevel 1 [list {c++ trampoline570} $this ]]
set ret $retpi
return $ret
}
method {getCellVelocity} { a0  } {set retpi [uplevel 1 [list {c++ trampoline572} $this $a0 ]]
set ret $retpi
return $ret
}

method {spin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline574} $this $a0 ]]
return $retpi
}
method {startTest} {  } {set retpi [uplevel 1 [list {c++ trampoline576} $this ]]
return $retpi
}
method {endTest} {  } {set retpi [uplevel 1 [list {c++ trampoline578} $this ]]
set ret $retpi
return $ret
}

method {applyCollision} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline580} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {cellCount} {  } {set retpi [uplevel 1 [list {c++ trampoline582} $this ]]
set ret $retpi
return $ret
}
method {getRadar} {  } {set retpi [uplevel 1 [list {c++ trampoline584} $this ]]
set ret $retpi
return $ret
}
method {setRadar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline586} $this $a0 ]]
return $retpi
}
method {getDeathAttributions} {  } {set retpi [uplevel 1 [list {c++ trampoline588} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set controller {}
            trace add variable controller {read write unset} "$this accessor465"
set effects {}
            trace add variable effects {read write unset} "$this accessor468"
set shipExistenceFailure {}
            trace add variable shipExistenceFailure {read write unset} "$this accessor471"



set insignia {}
            trace add variable insignia {read write unset} "$this accessor478"
set blame {}
            trace add variable blame {read write unset} "$this accessor481"
set score {}
            trace add variable score {read write unset} "$this accessor484"
set damageMultiplier {}
            trace add variable damageMultiplier {read write unset} "$this accessor487"
set diedSpontaneously {}
            trace add variable diedSpontaneously {read write unset} "$this accessor489"
set typeName {}
            trace add variable typeName {read write unset} "$this accessor491"






















































}
destructor {
trace remove variable controller {read write unset} "$this accessor465"
trace remove variable effects {read write unset} "$this accessor468"
trace remove variable shipExistenceFailure {read write unset} "$this accessor471"



trace remove variable insignia {read write unset} "$this accessor478"
trace remove variable blame {read write unset} "$this accessor481"
trace remove variable score {read write unset} "$this accessor484"
trace remove variable damageMultiplier {read write unset} "$this accessor487"
trace remove variable diedSpontaneously {read write unset} "$this accessor489"
trace remove variable typeName {read write unset} "$this accessor491"






















































}
}

proc {verify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline590} $a0 ]]
set ret $retpi
return $ret
}
proc {loadShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline592} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {saveShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline594} $a0 $a1 ]]
return $retpi
}

::itcl::class {Shield} {
inherit AObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline597} $this $a0 ]]
return $retpi
}
method {updateDist} {  } {set retpi [uplevel 1 [list {c++ trampoline599} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline601} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline603} $this ]]
set ret $retpi
return $ret
}
method {collideWith} { a0  } {set retpi [uplevel 1 [list {c++ trampoline605} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline607} $this ]]
set ret $retpi
return $ret
}
method {getStability} {  } {set retpi [uplevel 1 [list {c++ trampoline609} $this ]]
set ret $retpi
return $ret
}
method {getShip} {  } {set retpi [uplevel 1 [list {c++ trampoline611} $this ]]
set ret $retpi
return $ret
}
method {drawForHUD} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline613} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {









}
destructor {









}
}


proc {insignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline615} $a0 ]]
set ret $retpi
return $ret
}
proc {clear_insignias} {  } {set retpi [uplevel 1 [list {c++ trampoline617} ]]
return $retpi
}

proc {getAlliance} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline619} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {setAlliance} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline621} $a0 $a1 $a2 ]]
return $retpi
}

::itcl::class {EnergyCharge} {
inherit GameObject
namespace eval :: {
proc {c++ new EnergyCharge default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline624} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp627} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline628} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline630} $this ]]
set ret $retpi
return $ret
}
method {getIntensity} {  } {set retpi [uplevel 1 [list {c++ trampoline632} $this ]]
set ret $retpi
return $ret
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline634} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {MagnetoBomb} {
inherit GameObject
namespace eval :: {
proc {c++ new MagnetoBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline637} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp640} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline641} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline643} $this ]]
set ret $retpi
return $ret
}
method {getPower} {  } {set retpi [uplevel 1 [list {c++ trampoline645} $this ]]
set ret $retpi
return $ret
}
method {simulateFailure} {  } {set retpi [uplevel 1 [list {c++ trampoline647} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {SemiguidedBomb} {
inherit MagnetoBomb
namespace eval :: {
proc {c++ new SemiguidedBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline650} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      MagnetoBomb::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {PlasmaBurst} {
inherit GameObject
namespace eval :: {
proc {c++ new PlasmaBurst default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline653} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp656} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline657} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline659} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline661} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {





}
destructor {





}
}

::itcl::class {MonophasicEnergyPulse} {
inherit GameObject
namespace eval :: {
proc {c++ new MonophasicEnergyPulse default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline664} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Missile} {
inherit GameObject
namespace eval :: {
proc {c++ new Missile default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline667} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {EffectsHandler} {
inherit AObject
namespace eval :: {
proc {c++ new EffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline670} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclEffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline672} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {impact} { a0  } {set retpi [uplevel 1 [list {c++ deftramp675} $this $a0 ]]
return $retpi
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ deftramp677} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

 proc accessor679 {ignored ignored op} {
             global nullEffectsHandler
             if {$op == {read}} {
               set tmp [{c++ get678} ]
               set nullEffectsHandler $tmp

             } elseif {$op == {write}} {
               error "Cannot write to nullEffectsHandler"
             } else { error "Cannot unset C++ variable nullEffectsHandler" }
           }

::itcl::class {Background} {
inherit EffectsHandler
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline681} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline683} $this $a0 ]]
return $retpi
}
method {updateReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline685} $this $a0 $a1 ]]
return $retpi
}
method {repopulate} {  } {set retpi [uplevel 1 [list {c++ trampoline687} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {Planet} {
inherit Background
namespace eval :: {
proc {c++ new Planet default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline690} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {StarField} {
inherit Background
namespace eval :: {
proc {c++ new StarField default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline693} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

proc {initStarLists} {  } {set retpi [uplevel 1 [list {c++ trampoline695} ]]
return $retpi
}

::itcl::class {Nebula} {
inherit Background
namespace eval :: {
proc {c++ new Nebula default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline698} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {setFlowEquation} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline700} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {setPressureEquation} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline702} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
method {setPressureResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline704} $this $a0 ]]
return $retpi
}
method {getPressureResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline706} $this ]]
set ret $retpi
return $ret
}
method {setVelocityResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline708} $this $a0 ]]
return $retpi
}
method {getVelocityResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline710} $this ]]
set ret $retpi
return $ret
}
method {setForceMultiplier} { a0  } {set retpi [uplevel 1 [list {c++ trampoline712} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {








}
destructor {








}
}


::itcl::class {Camera} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new TclCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline715} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

protected variable reference
 method accessor719 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get717} $this]
               set reference $tmp

             } elseif {$op == {write}} {
               return [{c++ set718} $this $reference]
             } else { error "Cannot unset C++ variable reference" }
           }

protected method {doSetup} {  } {set retpi [uplevel 1 error "Call to pure-virtual function doSetup"]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp723} $this $a0 ]]
return $retpi
}
method {drawOverlays} {  } {set retpi [uplevel 1 [list {c++ deftramp725} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ deftramp727} $this ]]
return $retpi
}
method {setup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline728} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set reference {}
            trace add variable reference {read write unset} "$this accessor719"





}
destructor {

trace remove variable reference {read write unset} "$this accessor719"





}
}


::itcl::class {DynamicCamera} {
inherit Camera
namespace eval :: {
proc {c++ new DynamicCamera default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline731} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline733} $this $a0 ]]
return $retpi
}
protected method {doSetup} {  } {set retpi [uplevel 1 [list {c++ trampoline735} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ trampoline737} $this ]]
return $retpi
}
method {getZoom} {  } {set retpi [uplevel 1 [list {c++ trampoline739} $this ]]
set ret $retpi
return $ret
}
method {setZoom} { a0  } {set retpi [uplevel 1 [list {c++ trampoline741} $this $a0 ]]
return $retpi
}
method {getRotateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline743} $this ]]
set ret $retpi
return $ret
}
method {setRotateMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline745} $this $a0 ]]
return $retpi
}
method {getLookAhead} {  } {set retpi [uplevel 1 [list {c++ trampoline747} $this ]]
set ret $retpi
return $ret
}
method {setLookAhead} { a0  } {set retpi [uplevel 1 [list {c++ trampoline749} $this $a0 ]]
return $retpi
}
method {getVisualRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline751} $this ]]
set ret $retpi
return $ret
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline753} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {












}
destructor {












}
}


::itcl::class {FixedCamera} {
inherit Camera
namespace eval :: {
proc {c++ new FixedCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline756} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {Controller} {
inherit AObject
public variable ship
 method accessor760 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get759} $this]
               set ship $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ship"
             } else { error "Cannot unset C++ variable ship" }
           }

namespace eval :: {
proc {c++ new TclController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline761} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
return $retpi
}
method {damage} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp766} $this $a0 $a1 $a2 ]]
return $retpi
}
method {otherShipDied} { a0  } {set retpi [uplevel 1 [list {c++ deftramp768} $this $a0 ]]
return $retpi
}
method {notifyScore} { a0  } {set retpi [uplevel 1 [list {c++ deftramp770} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set ship {}
            trace add variable ship {read write unset} "$this accessor760"





}
destructor {
trace remove variable ship {read write unset} "$this accessor760"





}
}


::itcl::class {HumanController} {
inherit Controller
namespace eval :: {
proc {c++ new HumanController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline772} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline774} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline776} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline778} $this $a0 ]]
return $retpi
}
method {button} { a0  } {set retpi [uplevel 1 [list {c++ trampoline780} $this $a0 ]]
return $retpi
}
method {key} { a0  } {set retpi [uplevel 1 [list {c++ trampoline782} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

 proc accessor785 {ignored ignored op} {
             global isCompositionBufferInUse
             if {$op == {read}} {
               set tmp [{c++ get784} ]
               set isCompositionBufferInUse $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isCompositionBufferInUse"
             } else { error "Cannot unset C++ variable isCompositionBufferInUse" }
           }


proc {hc_conf_configure} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline786} $a0 $a1 ]]
return $retpi
}
proc {hc_conf_clear} {  } {set retpi [uplevel 1 [list {c++ trampoline788} ]]
return $retpi
}

::itcl::class {AIControl} {
inherit Controller
namespace eval :: {
proc {c++ new AIControl default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline791} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline793} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {GeneticAI} {
inherit Controller
namespace eval :: {
proc {c++ new GeneticAI default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline796} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline798} $this $a0 ]]
return $retpi
}
public variable species
 method accessor801 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get800} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor803 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get802} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

public variable instance
 method accessor805 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get804} $this]
               set instance $tmp

             } elseif {$op == {write}} {
               error "Cannot write to instance"
             } else { error "Cannot unset C++ variable instance" }
           }

public variable failed
 method accessor807 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get806} $this]
               set failed $tmp

             } elseif {$op == {write}} {
               error "Cannot write to failed"
             } else { error "Cannot unset C++ variable failed" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


set species {}
            trace add variable species {read write unset} "$this accessor801"
set generation {}
            trace add variable generation {read write unset} "$this accessor803"
set instance {}
            trace add variable instance {read write unset} "$this accessor805"
set failed {}
            trace add variable failed {read write unset} "$this accessor807"
}
destructor {


trace remove variable species {read write unset} "$this accessor801"
trace remove variable generation {read write unset} "$this accessor803"
trace remove variable instance {read write unset} "$this accessor805"
trace remove variable failed {read write unset} "$this accessor807"
}
}

proc {calculateGeneticAIFunctionCosts} {  } {set retpi [uplevel 1 [list {c++ trampoline808} ]]
return $retpi
}
::itcl::class {GenAI} {
inherit Controller
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline811} $this $a0 ]]
return $retpi
}
public variable species
 method accessor814 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get813} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor816 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get815} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

method {getScores} {  } {set retpi [uplevel 1 [list {c++ trampoline817} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set species {}
            trace add variable species {read write unset} "$this accessor814"
set generation {}
            trace add variable generation {read write unset} "$this accessor816"

}
destructor {

trace remove variable species {read write unset} "$this accessor814"
trace remove variable generation {read write unset} "$this accessor816"

}
}

proc {GenAI_make} { a0  } {set retpi [uplevel 1 [list {c++ trampoline819} $a0 ]]
set ret $retpi
return $ret
}

::itcl::class {CommonKeyboardClient} {
inherit AObject
namespace eval :: {
proc {c++ new CommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline822} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclCommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline824} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {exit} {  } {set retpi [uplevel 1 [list {c++ deftramp827} $this ]]
return $retpi
}
method {slow} {  } {set retpi [uplevel 1 [list {c++ deftramp829} $this ]]
return $retpi
}
method {fast} {  } {set retpi [uplevel 1 [list {c++ deftramp831} $this ]]
return $retpi
}
method {halt} {  } {set retpi [uplevel 1 [list {c++ deftramp833} $this ]]
return $retpi
}
method {frameXframe} {  } {set retpi [uplevel 1 [list {c++ deftramp835} $this ]]
return $retpi
}
method {statsOn} {  } {set retpi [uplevel 1 [list {c++ deftramp837} $this ]]
return $retpi
}
method {statsOff} {  } {set retpi [uplevel 1 [list {c++ deftramp839} $this ]]
return $retpi
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline840} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {










}
destructor {










}
}


::itcl::class {ForwardingEffectsHandler} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new ForwardingEffectsHandler default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline843} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Spectator} {
inherit GameObject
namespace eval :: {
proc {c++ new Spectator default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline846} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator explicit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline848} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator empty} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline850} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {nextReference} {  } {set retpi [uplevel 1 [list {c++ trampoline852} $this ]]
return $retpi
}
method {requireInsignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline854} $this $a0 ]]
return $retpi
}
method {kill} {  } {set retpi [uplevel 1 [list {c++ trampoline856} $this ]]
return $retpi
}
method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline858} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {GameEnv} {
inherit AObject
namespace eval :: {
proc {c++ new GameEnv customCamera} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline861} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new GameEnv default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline863} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline865} $this ]]
set ret $retpi
return $ret
}
method {setReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline867} $this $a0 $a1 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline869} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline871} $this ]]
return $retpi
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline873} $this ]]
set ret $retpi
return $ret
}
public variable cam
 method accessor877 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get875} $this]
               set cam $tmp

             } elseif {$op == {write}} {
               return [{c++ set876} $this $cam]
             } else { error "Cannot unset C++ variable cam" }
           }

public variable stars
 method accessor880 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get878} $this]
               set stars $tmp

             } elseif {$op == {write}} {
               return [{c++ set879} $this $stars]
             } else { error "Cannot unset C++ variable stars" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







set cam {}
            trace add variable cam {read write unset} "$this accessor877"
set stars {}
            trace add variable stars {read write unset} "$this accessor880"
}
destructor {







trace remove variable cam {read write unset} "$this accessor877"
trace remove variable stars {read write unset} "$this accessor880"
}
}


::itcl::class {Manipulator} {
inherit AObject
namespace eval :: {
proc {c++ new Manipulator default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline882} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} {  } {set retpi [uplevel 1 [list {c++ trampoline884} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline886} $this ]]
return $retpi
}
method {primaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline888} $this $a0 $a1 ]]
return $retpi
}
method {primaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline890} $this $a0 $a1 ]]
return $retpi
}
method {secondaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline892} $this $a0 $a1 ]]
return $retpi
}
method {secondaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline894} $this $a0 $a1 ]]
return $retpi
}
method {scrollUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline896} $this $a0 $a1 ]]
return $retpi
}
method {scrollDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline898} $this $a0 $a1 ]]
return $retpi
}
method {motion} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline900} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
method {resetView} {  } {set retpi [uplevel 1 [list {c++ trampoline902} $this ]]
return $retpi
}
method {pushUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline904} $this ]]
return $retpi
}
method {popUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline906} $this ]]
return $retpi
}
method {commitUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline908} $this ]]
return $retpi
}
method {deactivateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline910} $this ]]
return $retpi
}
method {activateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline912} $this ]]
return $retpi
}
method {addToHistory} {  } {set retpi [uplevel 1 [list {c++ trampoline914} $this ]]
return $retpi
}
method {revertToHistory} { a0  } {set retpi [uplevel 1 [list {c++ trampoline916} $this $a0 ]]
return $retpi
}
method {reloadShip} {  } {set retpi [uplevel 1 [list {c++ trampoline918} $this ]]
set ret $retpi
return $ret
}
method {deleteShip} {  } {set retpi [uplevel 1 [list {c++ trampoline920} $this ]]
return $retpi
}
method {copyMounts} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline922} $this $a0 $a1 ]]
return $retpi
}
method {getCellAt} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline924} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






















}
destructor {






















}
}


 proc accessor927 {ignored ignored op} {
             global planetgen_width
             if {$op == {read}} {
               set tmp [{c++ get926} ]
               set planetgen_width $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_width"
             } else { error "Cannot unset C++ variable planetgen_width" }
           }

 proc accessor929 {ignored ignored op} {
             global planetgen_height
             if {$op == {read}} {
               set tmp [{c++ get928} ]
               set planetgen_height $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_height"
             } else { error "Cannot unset C++ variable planetgen_height" }
           }

::itcl::class {PlanetGeneratorParms} {
inherit AObject
namespace eval :: {
proc {c++ new PlanetGeneratorParms default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline931} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable seed
 method accessor935 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get933} $this]
               set seed $tmp

             } elseif {$op == {write}} {
               return [{c++ set934} $this $seed]
             } else { error "Cannot unset C++ variable seed" }
           }

public variable continents
 method accessor938 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get936} $this]
               set continents $tmp

             } elseif {$op == {write}} {
               return [{c++ set937} $this $continents]
             } else { error "Cannot unset C++ variable continents" }
           }

public variable largeIslands
 method accessor941 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get939} $this]
               set largeIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set940} $this $largeIslands]
             } else { error "Cannot unset C++ variable largeIslands" }
           }

public variable smallIslands
 method accessor944 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get942} $this]
               set smallIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set943} $this $smallIslands]
             } else { error "Cannot unset C++ variable smallIslands" }
           }

public variable islandGrouping
 method accessor947 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get945} $this]
               set islandGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set946} $this $islandGrouping]
             } else { error "Cannot unset C++ variable islandGrouping" }
           }

public variable landSlope
 method accessor950 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get948} $this]
               set landSlope $tmp

             } elseif {$op == {write}} {
               return [{c++ set949} $this $landSlope]
             } else { error "Cannot unset C++ variable landSlope" }
           }

public variable oceans
 method accessor953 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get951} $this]
               set oceans $tmp

             } elseif {$op == {write}} {
               return [{c++ set952} $this $oceans]
             } else { error "Cannot unset C++ variable oceans" }
           }

public variable seas
 method accessor956 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get954} $this]
               set seas $tmp

             } elseif {$op == {write}} {
               return [{c++ set955} $this $seas]
             } else { error "Cannot unset C++ variable seas" }
           }

public variable lakes
 method accessor959 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get957} $this]
               set lakes $tmp

             } elseif {$op == {write}} {
               return [{c++ set958} $this $lakes]
             } else { error "Cannot unset C++ variable lakes" }
           }

public variable rivers
 method accessor962 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get960} $this]
               set rivers $tmp

             } elseif {$op == {write}} {
               return [{c++ set961} $this $rivers]
             } else { error "Cannot unset C++ variable rivers" }
           }

public variable mountainRanges
 method accessor965 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get963} $this]
               set mountainRanges $tmp

             } elseif {$op == {write}} {
               return [{c++ set964} $this $mountainRanges]
             } else { error "Cannot unset C++ variable mountainRanges" }
           }

public variable mountainSteepness
 method accessor968 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get966} $this]
               set mountainSteepness $tmp

             } elseif {$op == {write}} {
               return [{c++ set967} $this $mountainSteepness]
             } else { error "Cannot unset C++ variable mountainSteepness" }
           }

public variable enormousMountains
 method accessor971 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get969} $this]
               set enormousMountains $tmp

             } elseif {$op == {write}} {
               return [{c++ set970} $this $enormousMountains]
             } else { error "Cannot unset C++ variable enormousMountains" }
           }

public variable craters
 method accessor974 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get972} $this]
               set craters $tmp

             } elseif {$op == {write}} {
               return [{c++ set973} $this $craters]
             } else { error "Cannot unset C++ variable craters" }
           }

public variable maxCraterSize
 method accessor977 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get975} $this]
               set maxCraterSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set976} $this $maxCraterSize]
             } else { error "Cannot unset C++ variable maxCraterSize" }
           }

public variable equatorTemperature
 method accessor980 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get978} $this]
               set equatorTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set979} $this $equatorTemperature]
             } else { error "Cannot unset C++ variable equatorTemperature" }
           }

public variable solarEquator
 method accessor983 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get981} $this]
               set solarEquator $tmp

             } elseif {$op == {write}} {
               return [{c++ set982} $this $solarEquator]
             } else { error "Cannot unset C++ variable solarEquator" }
           }

public variable polarTemperature
 method accessor986 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get984} $this]
               set polarTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set985} $this $polarTemperature]
             } else { error "Cannot unset C++ variable polarTemperature" }
           }

public variable altitudeTemperatureDelta
 method accessor989 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get987} $this]
               set altitudeTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set988} $this $altitudeTemperatureDelta]
             } else { error "Cannot unset C++ variable altitudeTemperatureDelta" }
           }

public variable waterTemperatureDelta
 method accessor992 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get990} $this]
               set waterTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set991} $this $waterTemperatureDelta]
             } else { error "Cannot unset C++ variable waterTemperatureDelta" }
           }

public variable freezingPoint
 method accessor995 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get993} $this]
               set freezingPoint $tmp

             } elseif {$op == {write}} {
               return [{c++ set994} $this $freezingPoint]
             } else { error "Cannot unset C++ variable freezingPoint" }
           }

public variable humidity
 method accessor998 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get996} $this]
               set humidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set997} $this $humidity]
             } else { error "Cannot unset C++ variable humidity" }
           }

public variable vapourTransport
 method accessor1001 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get999} $this]
               set vapourTransport $tmp

             } elseif {$op == {write}} {
               return [{c++ set1000} $this $vapourTransport]
             } else { error "Cannot unset C++ variable vapourTransport" }
           }

public variable mountainBlockage
 method accessor1004 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1002} $this]
               set mountainBlockage $tmp

             } elseif {$op == {write}} {
               return [{c++ set1003} $this $mountainBlockage]
             } else { error "Cannot unset C++ variable mountainBlockage" }
           }

public variable vegitationHumidity
 method accessor1007 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1005} $this]
               set vegitationHumidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set1006} $this $vegitationHumidity]
             } else { error "Cannot unset C++ variable vegitationHumidity" }
           }

public variable cities
 method accessor1010 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1008} $this]
               set cities $tmp

             } elseif {$op == {write}} {
               return [{c++ set1009} $this $cities]
             } else { error "Cannot unset C++ variable cities" }
           }

public variable maxCitySize
 method accessor1013 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1011} $this]
               set maxCitySize $tmp

             } elseif {$op == {write}} {
               return [{c++ set1012} $this $maxCitySize]
             } else { error "Cannot unset C++ variable maxCitySize" }
           }

public variable cityGrouping
 method accessor1016 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1014} $this]
               set cityGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set1015} $this $cityGrouping]
             } else { error "Cannot unset C++ variable cityGrouping" }
           }

public variable waterColour
 method accessor1019 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1017} $this]
               set waterColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1018} $this $waterColour]
             } else { error "Cannot unset C++ variable waterColour" }
           }

public variable vegitationColour
 method accessor1022 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1020} $this]
               set vegitationColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1021} $this $vegitationColour]
             } else { error "Cannot unset C++ variable vegitationColour" }
           }

public variable lowerPlanetColour
 method accessor1025 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1023} $this]
               set lowerPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1024} $this $lowerPlanetColour]
             } else { error "Cannot unset C++ variable lowerPlanetColour" }
           }

public variable upperPlanetColour
 method accessor1028 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1026} $this]
               set upperPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1027} $this $upperPlanetColour]
             } else { error "Cannot unset C++ variable upperPlanetColour" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set seed {}
            trace add variable seed {read write unset} "$this accessor935"
set continents {}
            trace add variable continents {read write unset} "$this accessor938"
set largeIslands {}
            trace add variable largeIslands {read write unset} "$this accessor941"
set smallIslands {}
            trace add variable smallIslands {read write unset} "$this accessor944"
set islandGrouping {}
            trace add variable islandGrouping {read write unset} "$this accessor947"
set landSlope {}
            trace add variable landSlope {read write unset} "$this accessor950"
set oceans {}
            trace add variable oceans {read write unset} "$this accessor953"
set seas {}
            trace add variable seas {read write unset} "$this accessor956"
set lakes {}
            trace add variable lakes {read write unset} "$this accessor959"
set rivers {}
            trace add variable rivers {read write unset} "$this accessor962"
set mountainRanges {}
            trace add variable mountainRanges {read write unset} "$this accessor965"
set mountainSteepness {}
            trace add variable mountainSteepness {read write unset} "$this accessor968"
set enormousMountains {}
            trace add variable enormousMountains {read write unset} "$this accessor971"
set craters {}
            trace add variable craters {read write unset} "$this accessor974"
set maxCraterSize {}
            trace add variable maxCraterSize {read write unset} "$this accessor977"
set equatorTemperature {}
            trace add variable equatorTemperature {read write unset} "$this accessor980"
set solarEquator {}
            trace add variable solarEquator {read write unset} "$this accessor983"
set polarTemperature {}
            trace add variable polarTemperature {read write unset} "$this accessor986"
set altitudeTemperatureDelta {}
            trace add variable altitudeTemperatureDelta {read write unset} "$this accessor989"
set waterTemperatureDelta {}
            trace add variable waterTemperatureDelta {read write unset} "$this accessor992"
set freezingPoint {}
            trace add variable freezingPoint {read write unset} "$this accessor995"
set humidity {}
            trace add variable humidity {read write unset} "$this accessor998"
set vapourTransport {}
            trace add variable vapourTransport {read write unset} "$this accessor1001"
set mountainBlockage {}
            trace add variable mountainBlockage {read write unset} "$this accessor1004"
set vegitationHumidity {}
            trace add variable vegitationHumidity {read write unset} "$this accessor1007"
set cities {}
            trace add variable cities {read write unset} "$this accessor1010"
set maxCitySize {}
            trace add variable maxCitySize {read write unset} "$this accessor1013"
set cityGrouping {}
            trace add variable cityGrouping {read write unset} "$this accessor1016"
set waterColour {}
            trace add variable waterColour {read write unset} "$this accessor1019"
set vegitationColour {}
            trace add variable vegitationColour {read write unset} "$this accessor1022"
set lowerPlanetColour {}
            trace add variable lowerPlanetColour {read write unset} "$this accessor1025"
set upperPlanetColour {}
            trace add variable upperPlanetColour {read write unset} "$this accessor1028"
}
destructor {

trace remove variable seed {read write unset} "$this accessor935"
trace remove variable continents {read write unset} "$this accessor938"
trace remove variable largeIslands {read write unset} "$this accessor941"
trace remove variable smallIslands {read write unset} "$this accessor944"
trace remove variable islandGrouping {read write unset} "$this accessor947"
trace remove variable landSlope {read write unset} "$this accessor950"
trace remove variable oceans {read write unset} "$this accessor953"
trace remove variable seas {read write unset} "$this accessor956"
trace remove variable lakes {read write unset} "$this accessor959"
trace remove variable rivers {read write unset} "$this accessor962"
trace remove variable mountainRanges {read write unset} "$this accessor965"
trace remove variable mountainSteepness {read write unset} "$this accessor968"
trace remove variable enormousMountains {read write unset} "$this accessor971"
trace remove variable craters {read write unset} "$this accessor974"
trace remove variable maxCraterSize {read write unset} "$this accessor977"
trace remove variable equatorTemperature {read write unset} "$this accessor980"
trace remove variable solarEquator {read write unset} "$this accessor983"
trace remove variable polarTemperature {read write unset} "$this accessor986"
trace remove variable altitudeTemperatureDelta {read write unset} "$this accessor989"
trace remove variable waterTemperatureDelta {read write unset} "$this accessor992"
trace remove variable freezingPoint {read write unset} "$this accessor995"
trace remove variable humidity {read write unset} "$this accessor998"
trace remove variable vapourTransport {read write unset} "$this accessor1001"
trace remove variable mountainBlockage {read write unset} "$this accessor1004"
trace remove variable vegitationHumidity {read write unset} "$this accessor1007"
trace remove variable cities {read write unset} "$this accessor1010"
trace remove variable maxCitySize {read write unset} "$this accessor1013"
trace remove variable cityGrouping {read write unset} "$this accessor1016"
trace remove variable waterColour {read write unset} "$this accessor1019"
trace remove variable vegitationColour {read write unset} "$this accessor1022"
trace remove variable lowerPlanetColour {read write unset} "$this accessor1025"
trace remove variable upperPlanetColour {read write unset} "$this accessor1028"
}
}

proc {planetgen_begin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1029} $a0 ]]
return $retpi
}
proc {planetgen_what} {  } {set retpi [uplevel 1 [list {c++ trampoline1031} ]]
set ret $retpi
return $ret
}
proc {planetgen_progress} {  } {set retpi [uplevel 1 [list {c++ trampoline1033} ]]
set ret $retpi
return $ret
}
proc {planetgen_done} {  } {set retpi [uplevel 1 [list {c++ trampoline1035} ]]
set ret $retpi
return $ret
}
proc {planetgen_kill} {  } {set retpi [uplevel 1 [list {c++ trampoline1037} ]]
return $retpi
}
proc {planetgen_save} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1039} $a0 $a1 ]]
return $retpi
}

proc {set_hud_message} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1041} $a0 $a1 ]]
return $retpi
}
proc {global_chat_post} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1043} $a0 ]]
return $retpi
}
proc {global_chat_post_local} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1045} $a0 ]]
return $retpi
}
proc {global_chat_post_remote} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1047} $a0 ]]
return $retpi
}
 proc accessor1051 {ignored ignored op} {
             global state
             if {$op == {read}} {
               set tmp [{c++ get1049} ]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set1050}  $state]
             } else { error "Cannot unset C++ variable state" }
           }


 proc accessor1053 {ignored ignored op} {
             global PLATFORM
             if {$op == {read}} {
               set tmp [{c++ get1052} ]
               set PLATFORM $tmp

             } elseif {$op == {write}} {
               error "Cannot write to PLATFORM"
             } else { error "Cannot unset C++ variable PLATFORM" }
           }

 proc accessor1055 {ignored ignored op} {
             global screenW
             if {$op == {read}} {
               set tmp [{c++ get1054} ]
               set screenW $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenW"
             } else { error "Cannot unset C++ variable screenW" }
           }

 proc accessor1057 {ignored ignored op} {
             global screenH
             if {$op == {read}} {
               set tmp [{c++ get1056} ]
               set screenH $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenH"
             } else { error "Cannot unset C++ variable screenH" }
           }

 proc accessor1059 {ignored ignored op} {
             global vheight
             if {$op == {read}} {
               set tmp [{c++ get1058} ]
               set vheight $tmp

             } elseif {$op == {write}} {
               error "Cannot write to vheight"
             } else { error "Cannot unset C++ variable vheight" }
           }

 proc accessor1062 {ignored ignored op} {
             global generalAlphaBlending
             if {$op == {read}} {
               set tmp [{c++ get1060} ]
               set generalAlphaBlending $tmp

             } elseif {$op == {write}} {
               return [{c++ set1061}  $generalAlphaBlending]
             } else { error "Cannot unset C++ variable generalAlphaBlending" }
           }

 proc accessor1065 {ignored ignored op} {
             global alphaBlendingEnabled
             if {$op == {read}} {
               set tmp [{c++ get1063} ]
               set alphaBlendingEnabled $tmp

             } elseif {$op == {write}} {
               return [{c++ set1064}  $alphaBlendingEnabled]
             } else { error "Cannot unset C++ variable alphaBlendingEnabled" }
           }

 proc accessor1068 {ignored ignored op} {
             global smoothScaling
             if {$op == {read}} {
               set tmp [{c++ get1066} ]
               set smoothScaling $tmp

             } elseif {$op == {write}} {
               return [{c++ set1067}  $smoothScaling]
             } else { error "Cannot unset C++ variable smoothScaling" }
           }

 proc accessor1071 {ignored ignored op} {
             global highQuality
             if {$op == {read}} {
               set tmp [{c++ get1069} ]
               set highQuality $tmp

             } elseif {$op == {write}} {
               return [{c++ set1070}  $highQuality]
             } else { error "Cannot unset C++ variable highQuality" }
           }

 proc accessor1074 {ignored ignored op} {
             global antialiasing
             if {$op == {read}} {
               set tmp [{c++ get1072} ]
               set antialiasing $tmp

             } elseif {$op == {write}} {
               return [{c++ set1073}  $antialiasing]
             } else { error "Cannot unset C++ variable antialiasing" }
           }


 proc accessor1076 {ignored ignored op} {
             global headless
             if {$op == {read}} {
               set tmp [{c++ get1075} ]
               set headless $tmp

             } elseif {$op == {write}} {
               error "Cannot write to headless"
             } else { error "Cannot unset C++ variable headless" }
           }

 proc accessor1079 {ignored ignored op} {
             global cameraX1
             if {$op == {read}} {
               set tmp [{c++ get1077} ]
               set cameraX1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1078}  $cameraX1]
             } else { error "Cannot unset C++ variable cameraX1" }
           }

 proc accessor1082 {ignored ignored op} {
             global cameraX2
             if {$op == {read}} {
               set tmp [{c++ get1080} ]
               set cameraX2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1081}  $cameraX2]
             } else { error "Cannot unset C++ variable cameraX2" }
           }

 proc accessor1085 {ignored ignored op} {
             global cameraY1
             if {$op == {read}} {
               set tmp [{c++ get1083} ]
               set cameraY1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1084}  $cameraY1]
             } else { error "Cannot unset C++ variable cameraY1" }
           }

 proc accessor1088 {ignored ignored op} {
             global cameraY2
             if {$op == {read}} {
               set tmp [{c++ get1086} ]
               set cameraY2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1087}  $cameraY2]
             } else { error "Cannot unset C++ variable cameraY2" }
           }

 proc accessor1091 {ignored ignored op} {
             global cameraCX
             if {$op == {read}} {
               set tmp [{c++ get1089} ]
               set cameraCX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1090}  $cameraCX]
             } else { error "Cannot unset C++ variable cameraCX" }
           }

 proc accessor1094 {ignored ignored op} {
             global cameraCY
             if {$op == {read}} {
               set tmp [{c++ get1092} ]
               set cameraCY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1093}  $cameraCY]
             } else { error "Cannot unset C++ variable cameraCY" }
           }

 proc accessor1097 {ignored ignored op} {
             global cameraZoom
             if {$op == {read}} {
               set tmp [{c++ get1095} ]
               set cameraZoom $tmp

             } elseif {$op == {write}} {
               return [{c++ set1096}  $cameraZoom]
             } else { error "Cannot unset C++ variable cameraZoom" }
           }

 proc accessor1100 {ignored ignored op} {
             global cursorX
             if {$op == {read}} {
               set tmp [{c++ get1098} ]
               set cursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1099}  $cursorX]
             } else { error "Cannot unset C++ variable cursorX" }
           }

 proc accessor1103 {ignored ignored op} {
             global cursorY
             if {$op == {read}} {
               set tmp [{c++ get1101} ]
               set cursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1102}  $cursorY]
             } else { error "Cannot unset C++ variable cursorY" }
           }

 proc accessor1106 {ignored ignored op} {
             global oldCursorX
             if {$op == {read}} {
               set tmp [{c++ get1104} ]
               set oldCursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1105}  $oldCursorX]
             } else { error "Cannot unset C++ variable oldCursorX" }
           }

 proc accessor1109 {ignored ignored op} {
             global oldCursorY
             if {$op == {read}} {
               set tmp [{c++ get1107} ]
               set oldCursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1108}  $oldCursorY]
             } else { error "Cannot unset C++ variable oldCursorY" }
           }


 proc accessor1111 {ignored ignored op} {
             global currentFrameTime
             if {$op == {read}} {
               set tmp [{c++ get1110} ]
               set currentFrameTime $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTime"
             } else { error "Cannot unset C++ variable currentFrameTime" }
           }

 proc accessor1113 {ignored ignored op} {
             global currentFrameTimeLeft
             if {$op == {read}} {
               set tmp [{c++ get1112} ]
               set currentFrameTimeLeft $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTimeLeft"
             } else { error "Cannot unset C++ variable currentFrameTimeLeft" }
           }

 proc accessor1115 {ignored ignored op} {
             global currentVFrameLast
             if {$op == {read}} {
               set tmp [{c++ get1114} ]
               set currentVFrameLast $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentVFrameLast"
             } else { error "Cannot unset C++ variable currentVFrameLast" }
           }

 proc accessor1117 {ignored ignored op} {
             global sparkCountMultiplier
             if {$op == {read}} {
               set tmp [{c++ get1116} ]
               set sparkCountMultiplier $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sparkCountMultiplier"
             } else { error "Cannot unset C++ variable sparkCountMultiplier" }
           }

 proc accessor1119 {ignored ignored op} {
             global gameClock
             if {$op == {read}} {
               set tmp [{c++ get1118} ]
               set gameClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to gameClock"
             } else { error "Cannot unset C++ variable gameClock" }
           }

 proc accessor1121 {ignored ignored op} {
             global STD_CELL_SZ
             if {$op == {read}} {
               set tmp [{c++ get1120} ]
               set STD_CELL_SZ $tmp

             } elseif {$op == {write}} {
               error "Cannot write to STD_CELL_SZ"
             } else { error "Cannot unset C++ variable STD_CELL_SZ" }
           }

::itcl::class {SquareIcon} {
inherit AObject
namespace eval :: {
proc {c++ new SquareIcon default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1123} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {load} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1125} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {unload} {  } {set retpi [uplevel 1 [list {c++ trampoline1127} $this ]]
return $retpi
}
method {isLoaded} {  } {set retpi [uplevel 1 [list {c++ trampoline1129} $this ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline1131} $this ]]
return $retpi
}
method {save} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1133} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}




::itcl::class {Antenna} {
inherit AObject
namespace eval :: {
proc {c++ new Antenna default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1138} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable tuner
 method accessor1142 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1140} $this]
               set tuner $tmp

             } elseif {$op == {write}} {
               return [{c++ set1141} $this $tuner]
             } else { error "Cannot unset C++ variable tuner" }
           }

method {setInternetInformation4} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline1143} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {setInternetInformation6} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline1145} $this $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
return $retpi
}
method {getGlobalID4} {  } {set retpi [uplevel 1 [list {c++ trampoline1147} $this ]]
set ret $retpi
return $ret
}
method {getGlobalID6} {  } {set retpi [uplevel 1 [list {c++ trampoline1149} $this ]]
set ret $retpi
return $ret
}
method {hasV4} {  } {set retpi [uplevel 1 [list {c++ trampoline1151} $this ]]
set ret $retpi
return $ret
}
method {hasV6} {  } {set retpi [uplevel 1 [list {c++ trampoline1153} $this ]]
set ret $retpi
return $ret
}
method {processIncomming} {  } {set retpi [uplevel 1 [list {c++ trampoline1155} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set tuner {}
            trace add variable tuner {read write unset} "$this accessor1142"







}
destructor {

trace remove variable tuner {read write unset} "$this accessor1142"







}
}

 proc accessor1158 {ignored ignored op} {
             global antenna
             if {$op == {read}} {
               set tmp [{c++ get1157} ]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

 proc accessor1161 {ignored ignored op} {
             global packetDropMask
             if {$op == {read}} {
               set tmp [{c++ get1159} ]
               set packetDropMask $tmp

             } elseif {$op == {write}} {
               return [{c++ set1160}  $packetDropMask]
             } else { error "Cannot unset C++ variable packetDropMask" }
           }


::itcl::class {Tuner} {
inherit AObject
namespace eval :: {
proc {c++ new Tuner default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1163} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {GlobalID} {
inherit AObject
namespace eval :: {
proc {c++ new GlobalID default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1166} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {toString} {  } {set retpi [uplevel 1 [list {c++ trampoline1168} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {PacketProcessor} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}



::itcl::class {NetworkAssembly} {
inherit AObject
public variable field
 method accessor1174 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1173} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable antenna
 method accessor1176 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1175} $this]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

namespace eval :: {
proc {c++ new NetworkAssembly default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1177} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getTuner} {  } {set retpi [uplevel 1 [list {c++ trampoline1179} $this ]]
set ret $retpi
return $ret
}
method {numConnections} {  } {set retpi [uplevel 1 [list {c++ trampoline1181} $this ]]
set ret $retpi
return $ret
}
method {getConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1183} $this $a0 ]]
set ret $retpi
return $ret
}
method {addConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1185} $this $a0 ]]
return $retpi
}
method {removeConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1187} $this $a0 ]]
return $retpi
}
method {addPacketProcessor} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1189} $this $a0 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1191} $this $a0 ]]
return $retpi
}
method {setFieldSize} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1193} $this $a0 $a1 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set field {}
            trace add variable field {read write unset} "$this accessor1174"
set antenna {}
            trace add variable antenna {read write unset} "$this accessor1176"









}
destructor {
trace remove variable field {read write unset} "$this accessor1174"
trace remove variable antenna {read write unset} "$this accessor1176"









}
}


::itcl::class {NetworkConnection} {
inherit PacketProcessor
public variable parent
 method accessor1197 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1196} $this]
               set parent $tmp

             } elseif {$op == {write}} {
               error "Cannot write to parent"
             } else { error "Cannot unset C++ variable parent" }
           }

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1198} $this $a0 ]]
return $retpi
}
method {getStatus} {  } {set retpi [uplevel 1 [list {c++ trampoline1200} $this ]]
set ret $retpi
return $ret
}
method {getDisconnectReason} {  } {set retpi [uplevel 1 [list {c++ trampoline1202} $this ]]
set ret $retpi
return $ret
}
method {setFieldSize} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1204} $this $a0 $a1 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set parent {}
            trace add variable parent {read write unset} "$this accessor1197"




}
destructor {
trace remove variable parent {read write unset} "$this accessor1197"




}
}


::itcl::class {ConnectionListener} {
inherit PacketProcessor
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}


::itcl::class {GameAdvertiser} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameAdvertiser default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline1208} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {setOverseerId} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1210} $this $a0 ]]
return $retpi
}
method {setPeerCount} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1212} $this $a0 ]]
return $retpi
}
method {setGameMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1214} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {GameDiscoverer} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameDiscoverer default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1217} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {start} {  } {set retpi [uplevel 1 [list {c++ trampoline1219} $this ]]
return $retpi
}
method {poll} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1221} $this $a0 ]]
return $retpi
}
method {progress} {  } {set retpi [uplevel 1 [list {c++ trampoline1223} $this ]]
set ret $retpi
return $ret
}
method {dumpResults} {  } {set retpi [uplevel 1 [list {c++ trampoline1225} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {





}
destructor {





}
}


::itcl::class {InputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

::itcl::class {OutputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

itcl::class fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {} {}
      } {}
    }
::itcl::class {fun<InputNetworkGeraet*:NetworkConnection*>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<InputNetworkGeraet*:NetworkConnection*> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1230} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
set ret $retpi
return $ret
}
proc {call} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1234} $a0 $a1 ]]
set ret $retpi
return $ret
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline1236} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}




::itcl::class {SeqTextOutputGeraet} {
inherit OutputNetworkGeraet
namespace eval :: {
proc {c++ new SeqTextOutputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1240} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {send} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1242} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      OutputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

::itcl::class {SeqTextInputGeraet} {
inherit InputNetworkGeraet
namespace eval :: {
proc {c++ new TclSeqTextInputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1245} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {receiveText} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveText"]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      InputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {ConfReg} {
inherit AObject
method {open} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1250} $this $a0 $a1 ]]
return $retpi
}
method {create} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1252} $this $a0 $a1 ]]
return $retpi
}
method {close} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1254} $this $a0 ]]
return $retpi
}
method {closeAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1256} $this ]]
return $retpi
}
method {modify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1258} $this $a0 ]]
return $retpi
}
method {unmodify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1260} $this $a0 ]]
return $retpi
}
method {sync} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1262} $this $a0 ]]
return $retpi
}
method {syncAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1264} $this ]]
return $retpi
}
method {revert} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1266} $this $a0 ]]
return $retpi
}
method {revertAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1268} $this ]]
return $retpi
}
method {addToWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1270} $this $a0 ]]
return $retpi
}
method {removeFromWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1272} $this $a0 ]]
return $retpi
}
method {clearWhitelist} {  } {set retpi [uplevel 1 [list {c++ trampoline1274} $this ]]
return $retpi
}
method {setWhitelistOnly} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1276} $this $a0 ]]
return $retpi
}
method {renameFile} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1278} $this $a0 $a1 ]]
return $retpi
}

method {exists} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1280} $this $a0 ]]
set ret $retpi
return $ret
}
method {bool} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1282} $this $a0 ]]
set ret $retpi
return $ret
}
method {int} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1284} $this $a0 ]]
set ret $retpi
return $ret
}
method {float} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1286} $this $a0 ]]
set ret $retpi
return $ret
}
method {str} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1288} $this $a0 ]]
set ret $retpi
return $ret
}
method {setb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1290} $this $a0 $a1 ]]
return $retpi
}
method {seti} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1292} $this $a0 $a1 ]]
return $retpi
}
method {setf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1294} $this $a0 $a1 ]]
return $retpi
}
method {sets} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1296} $this $a0 $a1 ]]
return $retpi
}
method {add} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1298} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addb} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1300} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addi} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1302} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addf} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1304} $this $a0 $a1 $a2 ]]
return $retpi
}
method {adds} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1306} $this $a0 $a1 $a2 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1308} $this $a0 ]]
return $retpi
}
method {append} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1310} $this $a0 $a1 ]]
return $retpi
}
method {appendb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1312} $this $a0 $a1 ]]
return $retpi
}
method {appendi} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1314} $this $a0 $a1 ]]
return $retpi
}
method {appendf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1316} $this $a0 $a1 ]]
return $retpi
}
method {appends} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1318} $this $a0 $a1 ]]
return $retpi
}
method {remix} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1320} $this $a0 $a1 ]]
return $retpi
}
method {name} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1322} $this $a0 ]]
set ret $retpi
return $ret
}
method {copy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1324} $this $a0 $a1 ]]
return $retpi
}
method {getType} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1326} $this $a0 ]]
set ret $retpi
return $ret
}
method {length} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1328} $this $a0 ]]
set ret $retpi
return $ret
}
method {isGroup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1330} $this $a0 ]]
set ret $retpi
return $ret
}
method {isArray} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1332} $this $a0 ]]
set ret $retpi
return $ret
}
method {isList} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1334} $this $a0 ]]
set ret $retpi
return $ret
}
method {isAggregate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1336} $this $a0 ]]
set ret $retpi
return $ret
}
method {isScalar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1338} $this $a0 ]]
set ret $retpi
return $ret
}
method {isNumber} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1340} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSourceLine} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1342} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
















































}
destructor {
















































}
}

 proc accessor1345 {ignored ignored op} {
             global globalConf
             if {$op == {read}} {
               set tmp [{c++ get1344} ]
               set globalConf $tmp

             } elseif {$op == {write}} {
               error "Cannot write to globalConf"
             } else { error "Cannot unset C++ variable globalConf" }
           }

proc {confcpy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1346} $a0 $a1 ]]
return $retpi
}
proc {l10n_acceptLanguage} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1348} $a0 ]]
return $retpi
}
proc {l10n_loadCatalogue} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1350} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {l10n_purgeCatalogue} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1352} $a0 ]]
return $retpi
}

proc {_} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1354} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
proc {namegenAny} {  } {set retpi [uplevel 1 [list {c++ trampoline1356} ]]
set ret $retpi
return $ret
}
proc {namegenGet} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1358} $a0 ]]
set ret $retpi
return $ret
}
proc {newInterpreter} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1360} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {delInterpreter} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1362} $a0 ]]
return $retpi
}

proc {safe_source} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1364} $a0 ]]
return $retpi
}
proc {bkg_start} {  } {set retpi [uplevel 1 [list {c++ trampoline1366} ]]
return $retpi
}
proc {bkg_req} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1368} $a0 ]]
return $retpi
}
proc {bkg_ans} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1370} $a0 ]]
return $retpi
}
proc {bkg_req2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1372} $a0 $a1 ]]
return $retpi
}
proc {bkg_ans2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1374} $a0 $a1 ]]
return $retpi
}
proc {bkg_rcv} {  } {set retpi [uplevel 1 [list {c++ trampoline1376} ]]
set ret $retpi
return $ret
}
proc {bkg_get} {  } {set retpi [uplevel 1 [list {c++ trampoline1378} ]]
set ret $retpi
return $ret
}
proc {bkg_wait} {  } {set retpi [uplevel 1 [list {c++ trampoline1380} ]]
return $retpi
}

proc {crypto_init} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1382} $a0 ]]
return $retpi
}
proc {crypto_rand} {  } {set retpi [uplevel 1 [list {c++ trampoline1384} ]]
set ret $retpi
return $ret
}
proc {crypto_powm} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1386} $a0 $a1 ]]
set ret $retpi
return $ret
}

proc {performValidation} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1388} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {getValidationResultA} {  } {set retpi [uplevel 1 [list {c++ trampoline1390} ]]
set ret $retpi
return $ret
}
proc {getValidationResultB} {  } {set retpi [uplevel 1 [list {c++ trampoline1392} ]]
set ret $retpi
return $ret
}

proc {networkTestListen} {  } {set retpi [uplevel 1 [list {c++ trampoline1394} ]]
return $retpi
}
proc {networkTestRun} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1396} $a0 $a1 ]]
set ret $retpi
return $ret
}

proc {ship_mixer_init} {  } {set retpi [uplevel 1 [list {c++ trampoline1398} ]]
return $retpi
}
proc {ship_mixer_end} {  } {set retpi [uplevel 1 [list {c++ trampoline1400} ]]
return $retpi
}

proc {debugTclExports} {  } {set retpi [uplevel 1 [list {c++ trampoline1402} ]]
return $retpi
}































set none {}
trace add variable none {read write unset} accessor60
set lshift {}
trace add variable lshift {read write unset} accessor62
set rshift {}
trace add variable rshift {read write unset} accessor64
set lctrl {}
trace add variable lctrl {read write unset} accessor66
set rctrl {}
trace add variable rctrl {read write unset} accessor68
set lalt {}
trace add variable lalt {read write unset} accessor70
set ralt {}
trace add variable ralt {read write unset} accessor72
set lmeta {}
trace add variable lmeta {read write unset} accessor74
set rmeta {}
trace add variable rmeta {read write unset} accessor76
set num {}
trace add variable num {read write unset} accessor78
set caps {}
trace add variable caps {read write unset} accessor80
set mode {}
trace add variable mode {read write unset} accessor82
set reserved {}
trace add variable reserved {read write unset} accessor84
set glueClass(SDL_keysym) yes





set glueClass(SDL_KeyboardEvent) yes




set SDL_BUTTON_1 {}
trace add variable SDL_BUTTON_1 {read write unset} accessor109
set SDL_BUTTON_2 {}
trace add variable SDL_BUTTON_2 {read write unset} accessor111
set SDL_BUTTON_3 {}
trace add variable SDL_BUTTON_3 {read write unset} accessor113
set SDL_BUTTON_4 {}
trace add variable SDL_BUTTON_4 {read write unset} accessor115
set SDL_BUTTON_5 {}
trace add variable SDL_BUTTON_5 {read write unset} accessor117

set SDL_DEFAULT_REPEAT_INTERVAL {}
trace add variable SDL_DEFAULT_REPEAT_INTERVAL {read write unset} accessor121
set SDL_DEFAULT_REPEAT_DELAY {}
trace add variable SDL_DEFAULT_REPEAT_DELAY {read write unset} accessor123


set glueClass(SDL_MouseMotionEvent) yes







set glueClass(SDL_MouseButtonEvent) yes










set glueClass(Font) yes












set sysfont {}
trace add variable sysfont {read write unset} accessor190
set sysfontStipple {}
trace add variable sysfontStipple {read write unset} accessor192
set glueClass(GameState) yes








set glueClass(InitState) yes



set gameClass {}
trace add variable gameClass {read write unset} accessor213
set humanShip {}
trace add variable humanShip {read write unset} accessor216
set testStateMode {}
trace add variable testStateMode {read write unset} accessor219
set testStateSize {}
trace add variable testStateSize {read write unset} accessor222
set glueClass(TestState) yes






set glueClass(GameObject) yes





































set glueClass(GameField) yes
















set glueClass(Blast) yes


















set glueClass(CellFragment) yes




set glueClass(PlasmaFire) yes




set glueClass(Explosion) yes













set glueClass(OldStyleExplosion) yes






set glueClass(LightTrail) yes














set glueClass(fun<void:Ship*,bool>) yes





set glueClass(radar_t) yes


set glueClass(Ship) yes







































































set glueClass(Shield) yes

















set glueClass(EnergyCharge) yes







set glueClass(MagnetoBomb) yes







set glueClass(SemiguidedBomb) yes


set glueClass(PlasmaBurst) yes






set glueClass(MonophasicEnergyPulse) yes


set glueClass(Missile) yes


set glueClass(EffectsHandler) yes





set nullEffectsHandler {}
trace add variable nullEffectsHandler {read write unset} accessor679
set glueClass(Background) yes






set glueClass(Planet) yes



set glueClass(StarField) yes




set glueClass(Nebula) yes










set glueClass(Camera) yes









set glueClass(DynamicCamera) yes














set glueClass(FixedCamera) yes



set glueClass(Controller) yes








set glueClass(HumanController) yes







set isCompositionBufferInUse {}
trace add variable isCompositionBufferInUse {read write unset} accessor785




set glueClass(AIControl) yes




set glueClass(GeneticAI) yes








set glueClass(GenAI) yes







set glueClass(CommonKeyboardClient) yes












set glueClass(ForwardingEffectsHandler) yes


set glueClass(Spectator) yes








set glueClass(GameEnv) yes











set glueClass(Manipulator) yes
























set planetgen_width {}
trace add variable planetgen_width {read write unset} accessor927
set planetgen_height {}
trace add variable planetgen_height {read write unset} accessor929
set glueClass(PlanetGeneratorParms) yes













































set state {}
trace add variable state {read write unset} accessor1051

set PLATFORM {}
trace add variable PLATFORM {read write unset} accessor1053
set screenW {}
trace add variable screenW {read write unset} accessor1055
set screenH {}
trace add variable screenH {read write unset} accessor1057
set vheight {}
trace add variable vheight {read write unset} accessor1059
set generalAlphaBlending {}
trace add variable generalAlphaBlending {read write unset} accessor1062
set alphaBlendingEnabled {}
trace add variable alphaBlendingEnabled {read write unset} accessor1065
set smoothScaling {}
trace add variable smoothScaling {read write unset} accessor1068
set highQuality {}
trace add variable highQuality {read write unset} accessor1071
set antialiasing {}
trace add variable antialiasing {read write unset} accessor1074

set headless {}
trace add variable headless {read write unset} accessor1076
set cameraX1 {}
trace add variable cameraX1 {read write unset} accessor1079
set cameraX2 {}
trace add variable cameraX2 {read write unset} accessor1082
set cameraY1 {}
trace add variable cameraY1 {read write unset} accessor1085
set cameraY2 {}
trace add variable cameraY2 {read write unset} accessor1088
set cameraCX {}
trace add variable cameraCX {read write unset} accessor1091
set cameraCY {}
trace add variable cameraCY {read write unset} accessor1094
set cameraZoom {}
trace add variable cameraZoom {read write unset} accessor1097
set cursorX {}
trace add variable cursorX {read write unset} accessor1100
set cursorY {}
trace add variable cursorY {read write unset} accessor1103
set oldCursorX {}
trace add variable oldCursorX {read write unset} accessor1106
set oldCursorY {}
trace add variable oldCursorY {read write unset} accessor1109

set currentFrameTime {}
trace add variable currentFrameTime {read write unset} accessor1111
set currentFrameTimeLeft {}
trace add variable currentFrameTimeLeft {read write unset} accessor1113
set currentVFrameLast {}
trace add variable currentVFrameLast {read write unset} accessor1115
set sparkCountMultiplier {}
trace add variable sparkCountMultiplier {read write unset} accessor1117
set gameClock {}
trace add variable gameClock {read write unset} accessor1119
set STD_CELL_SZ {}
trace add variable STD_CELL_SZ {read write unset} accessor1121
set glueClass(SquareIcon) yes










set glueClass(Antenna) yes










set antenna {}
trace add variable antenna {read write unset} accessor1158
set packetDropMask {}
trace add variable packetDropMask {read write unset} accessor1161

set glueClass(Tuner) yes



set glueClass(GlobalID) yes




set glueClass(PacketProcessor) yes



set glueClass(NetworkAssembly) yes













set glueClass(NetworkConnection) yes







set glueClass(ConnectionListener) yes


set glueClass(GameAdvertiser) yes






set glueClass(GameDiscoverer) yes







set glueClass(InputNetworkGeraet) yes

set glueClass(OutputNetworkGeraet) yes


set glueClass(fun<InputNetworkGeraet*:NetworkConnection*>) yes








set glueClass(SeqTextOutputGeraet) yes



set glueClass(SeqTextInputGeraet) yes




set glueClass(ConfReg) yes

















































set globalConf {}
trace add variable globalConf {read write unset} accessor1345





































safe_source tcl/autosource.tcl
