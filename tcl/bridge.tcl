
  package require Itcl

  # AUTOGENERATED BY generate.tcl. DO NOT EDIT DIRECTLY.
  # See readme.txt.

  #Our base Tcl glue code (eval'd to hardwire the magic cookie)
  eval [format {
    itcl::class AObject {
      # Ensure all code uses the fully-qualified name for C++ to recognize it
      method fqn {} {::return $this}

      protected constructor {cppClass constname cppArgs} {
        if {[::string length $constname]} {
          # Intercept errors so we don't leak the magic number
          if {[catch {
            "::c++ new $cppClass $constname" $this %s {*}$cppArgs
          } err]} {
            error "Bad constructor call: $cppClass $constname: $err"
          }
        }
      }
      destructor {
        {::c++ delete} $this %s
      }

      method super {sup cname {args {}}} {
        ${sup}::constructor $sup $cname $args
      }

      # Prevent access to the magic cookie by redirecting
      # all info requests to the global one
      method info {args} {
        ::namespace eval :: ::info {*}$args
      }
    }
  } ${ABENDSTERN-MAGIC-COOKIE-1} ${ABENDSTERN-MAGIC-COOKIE-1}]
  unset ABENDSTERN-MAGIC-COOKIE-1

  # Have rename commit suicide
  # rename rename {}

  set glueClass(AObject) yes

  proc new {clazz args} {
    global glueClass
    if {[info exists glueClass($clazz)]} {
      [$clazz #auto $clazz [lindex $args 0] [lrange $args 1 [llength $args]]] fqn
    } else {
      [$clazz #auto {*}$args] fqn
    }
  }

proc {c++ delete} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1} $a0 $a1 ]]
return $retpi
}
proc {glBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline3} $a0 ]]
return $retpi
}
proc {glEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline5} ]]
return $retpi
}
proc {glVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline7} $a0 $a1 ]]
return $retpi
}
proc {glColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline9} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {glPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline11} ]]
return $retpi
}
proc {glPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline13} ]]
return $retpi
}
proc {glLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline15} ]]
return $retpi
}
proc {glTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline17} $a0 $a1 ]]
return $retpi
}
proc {glRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline19} $a0 ]]
return $retpi
}
proc {glScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline21} $a0 $a1 ]]
return $retpi
}
proc {glUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline23} $a0 ]]
return $retpi
}
proc {glReset} {  } {set retpi [uplevel 1 [list {c++ trampoline25} ]]
return $retpi
}

proc {acsgi_begin} {  } {set retpi [uplevel 1 [list {c++ trampoline27} ]]
return $retpi
}
proc {acsgi_end} {  } {set retpi [uplevel 1 [list {c++ trampoline29} ]]
return $retpi
}
proc {acsgi_draw} {  } {set retpi [uplevel 1 [list {c++ trampoline31} ]]
return $retpi
}
proc {acsgi_textNormal} { a0  } {set retpi [uplevel 1 [list {c++ trampoline33} $a0 ]]
return $retpi
}
proc {cglBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline35} $a0 ]]
return $retpi
}
proc {cglEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline37} ]]
return $retpi
}
proc {cglVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline39} $a0 $a1 ]]
return $retpi
}
proc {cglColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline41} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {cglPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline43} ]]
return $retpi
}
proc {cglPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline45} ]]
return $retpi
}
proc {cglLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline47} ]]
return $retpi
}
proc {cglTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline49} $a0 $a1 ]]
return $retpi
}
proc {cglRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline51} $a0 ]]
return $retpi
}
proc {cglScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline53} $a0 $a1 ]]
return $retpi
}
proc {cglUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline55} $a0 ]]
return $retpi
}
proc {cglText} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline57} $a0 $a1 $a2 ]]
return $retpi
}
 proc accessor60 {ignored ignored op} {
             global SDLK_LAST
             if {$op == {read}} {
               set tmp [{c++ get59} ]
               set SDLK_LAST $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDLK_LAST"
             } else { error "Cannot unset C++ variable SDLK_LAST" }
           }

proc {SDLKeyToInt} { a0  } {set retpi [uplevel 1 [list {c++ trampoline61} $a0 ]]
set ret $retpi
return $ret
}
 proc accessor64 {ignored ignored op} {
             global none
             if {$op == {read}} {
               set tmp [{c++ get63} ]
               set none $tmp

             } elseif {$op == {write}} {
               error "Cannot write to none"
             } else { error "Cannot unset C++ variable none" }
           }

 proc accessor66 {ignored ignored op} {
             global lshift
             if {$op == {read}} {
               set tmp [{c++ get65} ]
               set lshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lshift"
             } else { error "Cannot unset C++ variable lshift" }
           }

 proc accessor68 {ignored ignored op} {
             global rshift
             if {$op == {read}} {
               set tmp [{c++ get67} ]
               set rshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rshift"
             } else { error "Cannot unset C++ variable rshift" }
           }

 proc accessor70 {ignored ignored op} {
             global lctrl
             if {$op == {read}} {
               set tmp [{c++ get69} ]
               set lctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lctrl"
             } else { error "Cannot unset C++ variable lctrl" }
           }

 proc accessor72 {ignored ignored op} {
             global rctrl
             if {$op == {read}} {
               set tmp [{c++ get71} ]
               set rctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rctrl"
             } else { error "Cannot unset C++ variable rctrl" }
           }

 proc accessor74 {ignored ignored op} {
             global lalt
             if {$op == {read}} {
               set tmp [{c++ get73} ]
               set lalt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lalt"
             } else { error "Cannot unset C++ variable lalt" }
           }

 proc accessor76 {ignored ignored op} {
             global ralt
             if {$op == {read}} {
               set tmp [{c++ get75} ]
               set ralt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ralt"
             } else { error "Cannot unset C++ variable ralt" }
           }

 proc accessor78 {ignored ignored op} {
             global lmeta
             if {$op == {read}} {
               set tmp [{c++ get77} ]
               set lmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lmeta"
             } else { error "Cannot unset C++ variable lmeta" }
           }

 proc accessor80 {ignored ignored op} {
             global rmeta
             if {$op == {read}} {
               set tmp [{c++ get79} ]
               set rmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rmeta"
             } else { error "Cannot unset C++ variable rmeta" }
           }

 proc accessor82 {ignored ignored op} {
             global num
             if {$op == {read}} {
               set tmp [{c++ get81} ]
               set num $tmp

             } elseif {$op == {write}} {
               error "Cannot write to num"
             } else { error "Cannot unset C++ variable num" }
           }

 proc accessor84 {ignored ignored op} {
             global caps
             if {$op == {read}} {
               set tmp [{c++ get83} ]
               set caps $tmp

             } elseif {$op == {write}} {
               error "Cannot write to caps"
             } else { error "Cannot unset C++ variable caps" }
           }

 proc accessor86 {ignored ignored op} {
             global mode
             if {$op == {read}} {
               set tmp [{c++ get85} ]
               set mode $tmp

             } elseif {$op == {write}} {
               error "Cannot write to mode"
             } else { error "Cannot unset C++ variable mode" }
           }

 proc accessor88 {ignored ignored op} {
             global reserved
             if {$op == {read}} {
               set tmp [{c++ get87} ]
               set reserved $tmp

             } elseif {$op == {write}} {
               error "Cannot write to reserved"
             } else { error "Cannot unset C++ variable reserved" }
           }

::itcl::class {SDL_keysym} {
inherit AObject
public variable scancode
 method accessor92 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get90} $this]
               set scancode $tmp

             } elseif {$op == {write}} {
               return [{c++ set91} $this $scancode]
             } else { error "Cannot unset C++ variable scancode" }
           }

public variable sym
 method accessor95 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get93} $this]
               set sym $tmp

             } elseif {$op == {write}} {
               return [{c++ set94} $this $sym]
             } else { error "Cannot unset C++ variable sym" }
           }

public variable mod
 method accessor98 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get96} $this]
               set mod $tmp

             } elseif {$op == {write}} {
               return [{c++ set97} $this $mod]
             } else { error "Cannot unset C++ variable mod" }
           }

public variable unicode
 method accessor101 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get99} $this]
               set unicode $tmp

             } elseif {$op == {write}} {
               return [{c++ set100} $this $unicode]
             } else { error "Cannot unset C++ variable unicode" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set scancode {}
            trace add variable scancode {read write unset} "$this accessor92"
set sym {}
            trace add variable sym {read write unset} "$this accessor95"
set mod {}
            trace add variable mod {read write unset} "$this accessor98"
set unicode {}
            trace add variable unicode {read write unset} "$this accessor101"
}
destructor {
trace remove variable scancode {read write unset} "$this accessor92"
trace remove variable sym {read write unset} "$this accessor95"
trace remove variable mod {read write unset} "$this accessor98"
trace remove variable unicode {read write unset} "$this accessor101"
}
}

::itcl::class {SDL_KeyboardEvent} {
inherit AObject
public variable type
 method accessor105 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get103} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set104} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor108 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get106} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set107} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable keysym
 method accessor111 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get109} $this]
               set keysym $tmp

             } elseif {$op == {write}} {
               return [{c++ set110} $this $keysym]
             } else { error "Cannot unset C++ variable keysym" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor105"
set state {}
            trace add variable state {read write unset} "$this accessor108"
set keysym {}
            trace add variable keysym {read write unset} "$this accessor111"
}
destructor {
trace remove variable type {read write unset} "$this accessor105"
trace remove variable state {read write unset} "$this accessor108"
trace remove variable keysym {read write unset} "$this accessor111"
}
}

 proc accessor113 {ignored ignored op} {
             global SDL_BUTTON_1
             if {$op == {read}} {
               set tmp [{c++ get112} ]
               set SDL_BUTTON_1 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_1"
             } else { error "Cannot unset C++ variable SDL_BUTTON_1" }
           }

 proc accessor115 {ignored ignored op} {
             global SDL_BUTTON_2
             if {$op == {read}} {
               set tmp [{c++ get114} ]
               set SDL_BUTTON_2 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_2"
             } else { error "Cannot unset C++ variable SDL_BUTTON_2" }
           }

 proc accessor117 {ignored ignored op} {
             global SDL_BUTTON_3
             if {$op == {read}} {
               set tmp [{c++ get116} ]
               set SDL_BUTTON_3 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_3"
             } else { error "Cannot unset C++ variable SDL_BUTTON_3" }
           }

 proc accessor119 {ignored ignored op} {
             global SDL_BUTTON_4
             if {$op == {read}} {
               set tmp [{c++ get118} ]
               set SDL_BUTTON_4 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_4"
             } else { error "Cannot unset C++ variable SDL_BUTTON_4" }
           }

 proc accessor121 {ignored ignored op} {
             global SDL_BUTTON_5
             if {$op == {read}} {
               set tmp [{c++ get120} ]
               set SDL_BUTTON_5 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_5"
             } else { error "Cannot unset C++ variable SDL_BUTTON_5" }
           }

proc {SDL_GetModState} {  } {set retpi [uplevel 1 [list {c++ trampoline122} ]]
set ret $retpi
return $ret
}
 proc accessor125 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_INTERVAL
             if {$op == {read}} {
               set tmp [{c++ get124} ]
               set SDL_DEFAULT_REPEAT_INTERVAL $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_INTERVAL"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_INTERVAL" }
           }

 proc accessor127 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_DELAY
             if {$op == {read}} {
               set tmp [{c++ get126} ]
               set SDL_DEFAULT_REPEAT_DELAY $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_DELAY"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_DELAY" }
           }

proc {SDL_EnableKeyRepeat} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline128} $a0 $a1 ]]
return $retpi
}

::itcl::class {SDL_MouseMotionEvent} {
inherit AObject
public variable type
 method accessor133 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get131} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set132} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor136 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get134} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set135} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor139 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get137} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set138} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor142 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get140} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set141} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

public variable xrel
 method accessor145 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get143} $this]
               set xrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set144} $this $xrel]
             } else { error "Cannot unset C++ variable xrel" }
           }

public variable yrel
 method accessor148 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get146} $this]
               set yrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set147} $this $yrel]
             } else { error "Cannot unset C++ variable yrel" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor133"
set state {}
            trace add variable state {read write unset} "$this accessor136"
set x {}
            trace add variable x {read write unset} "$this accessor139"
set y {}
            trace add variable y {read write unset} "$this accessor142"
set xrel {}
            trace add variable xrel {read write unset} "$this accessor145"
set yrel {}
            trace add variable yrel {read write unset} "$this accessor148"
}
destructor {
trace remove variable type {read write unset} "$this accessor133"
trace remove variable state {read write unset} "$this accessor136"
trace remove variable x {read write unset} "$this accessor139"
trace remove variable y {read write unset} "$this accessor142"
trace remove variable xrel {read write unset} "$this accessor145"
trace remove variable yrel {read write unset} "$this accessor148"
}
}

::itcl::class {SDL_MouseButtonEvent} {
inherit AObject
public variable type
 method accessor152 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get150} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set151} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable which
 method accessor155 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get153} $this]
               set which $tmp

             } elseif {$op == {write}} {
               return [{c++ set154} $this $which]
             } else { error "Cannot unset C++ variable which" }
           }

public variable button
 method accessor158 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get156} $this]
               set button $tmp

             } elseif {$op == {write}} {
               return [{c++ set157} $this $button]
             } else { error "Cannot unset C++ variable button" }
           }

public variable state
 method accessor161 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get159} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set160} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor164 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get162} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set163} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor167 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get165} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set166} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor152"
set which {}
            trace add variable which {read write unset} "$this accessor155"
set button {}
            trace add variable button {read write unset} "$this accessor158"
set state {}
            trace add variable state {read write unset} "$this accessor161"
set x {}
            trace add variable x {read write unset} "$this accessor164"
set y {}
            trace add variable y {read write unset} "$this accessor167"
}
destructor {
trace remove variable type {read write unset} "$this accessor152"
trace remove variable which {read write unset} "$this accessor155"
trace remove variable button {read write unset} "$this accessor158"
trace remove variable state {read write unset} "$this accessor161"
trace remove variable x {read write unset} "$this accessor164"
trace remove variable y {read write unset} "$this accessor167"
}
}

proc {SDL_GetKeyName} { a0  } {set retpi [uplevel 1 [list {c++ trampoline168} $a0 ]]
set ret $retpi
return $ret
}
proc {SDL_WarpMouse} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline170} $a0 $a1 ]]
return $retpi
}
proc {SDL_GetTicks} {  } {set retpi [uplevel 1 [list {c++ trampoline172} ]]
set ret $retpi
return $ret
}

 proc accessor175 {ignored ignored op} {
             global preliminaryRunMode
             if {$op == {read}} {
               set tmp [{c++ get174} ]
               set preliminaryRunMode $tmp

             } elseif {$op == {write}} {
               error "Cannot write to preliminaryRunMode"
             } else { error "Cannot unset C++ variable preliminaryRunMode" }
           }

 proc accessor177 {ignored ignored op} {
             global THIS_GL_TYPE
             if {$op == {read}} {
               set tmp [{c++ get176} ]
               set THIS_GL_TYPE $tmp

             } elseif {$op == {write}} {
               error "Cannot write to THIS_GL_TYPE"
             } else { error "Cannot unset C++ variable THIS_GL_TYPE" }
           }

 proc accessor180 {ignored ignored op} {
             global recommendedGLType
             if {$op == {read}} {
               set tmp [{c++ get178} ]
               set recommendedGLType $tmp

             } elseif {$op == {write}} {
               return [{c++ set179}  $recommendedGLType]
             } else { error "Cannot unset C++ variable recommendedGLType" }
           }

proc {exitPreliminaryRunMode} {  } {set retpi [uplevel 1 [list {c++ trampoline181} ]]
return $retpi
}

::itcl::class {Font} {
inherit AObject
namespace eval :: {
proc {c++ new Font default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline184} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}


method {charWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline186} $this $a0 ]]
set ret $retpi
return $ret
}
method {width} { a0  } {set retpi [uplevel 1 [list {c++ trampoline188} $this $a0 ]]
set ret $retpi
return $ret
}
method {getHeight} {  } {set retpi [uplevel 1 [list {c++ trampoline190} $this ]]
set ret $retpi
return $ret
}
method {getRise} {  } {set retpi [uplevel 1 [list {c++ trampoline192} $this ]]
set ret $retpi
return $ret
}
method {getDip} {  } {set retpi [uplevel 1 [list {c++ trampoline194} $this ]]
set ret $retpi
return $ret
}
method {preDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline196} $this ]]
return $retpi
}
method {postDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline198} $this ]]
return $retpi
}
method {drawCh} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline200} $this $a0 $a1 $a2 ]]
return $retpi
}
method {drawStr} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline202} $this $a0 $a1 $a2 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {











}
destructor {











}
}

 proc accessor205 {ignored ignored op} {
             global sysfont
             if {$op == {read}} {
               set tmp [{c++ get204} ]
               set sysfont $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfont"
             } else { error "Cannot unset C++ variable sysfont" }
           }

 proc accessor207 {ignored ignored op} {
             global sysfontStipple
             if {$op == {read}} {
               set tmp [{c++ get206} ]
               set sysfontStipple $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfontStipple"
             } else { error "Cannot unset C++ variable sysfontStipple" }
           }

::itcl::class {GameState} {
inherit AObject
namespace eval :: {
proc {c++ new TclGameState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline209} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {configureGL} {  } {set retpi [uplevel 1 [list {c++ deftramp216} $this ]]
return $retpi
}
method {keyboard} { a0  } {set retpi [uplevel 1 [list {c++ deftramp218} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ deftramp220} $this $a0 ]]
return $retpi
}
method {mouseButton} { a0  } {set retpi [uplevel 1 [list {c++ deftramp222} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {InitState} {
inherit GameState
namespace eval :: {
proc {c++ new InitState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline224} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


 proc accessor228 {ignored ignored op} {
             global gameClass
             if {$op == {read}} {
               set tmp [{c++ get226} ]
               set gameClass $tmp

             } elseif {$op == {write}} {
               return [{c++ set227}  $gameClass]
             } else { error "Cannot unset C++ variable gameClass" }
           }

 proc accessor231 {ignored ignored op} {
             global humanShip
             if {$op == {read}} {
               set tmp [{c++ get229} ]
               set humanShip $tmp

             } elseif {$op == {write}} {
               return [{c++ set230}  $humanShip]
             } else { error "Cannot unset C++ variable humanShip" }
           }

 proc accessor234 {ignored ignored op} {
             global testStateMode
             if {$op == {read}} {
               set tmp [{c++ get232} ]
               set testStateMode $tmp

             } elseif {$op == {write}} {
               return [{c++ set233}  $testStateMode]
             } else { error "Cannot unset C++ variable testStateMode" }
           }

 proc accessor237 {ignored ignored op} {
             global testStateSize
             if {$op == {read}} {
               set tmp [{c++ get235} ]
               set testStateSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set236}  $testStateSize]
             } else { error "Cannot unset C++ variable testStateSize" }
           }

::itcl::class {TestState} {
inherit GameState
namespace eval :: {
proc {c++ new TestState default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline239} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline241} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline243} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}



::itcl::class {GameObject} {
inherit AObject
public variable isRemote
 method accessor248 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get247} $this]
               set isRemote $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isRemote"
             } else { error "Cannot unset C++ variable isRemote" }
           }

public variable isExportable
 method accessor251 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get249} $this]
               set isExportable $tmp

             } elseif {$op == {write}} {
               return [{c++ set250} $this $isExportable]
             } else { error "Cannot unset C++ variable isExportable" }
           }

public variable tag
 method accessor254 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get252} $this]
               set tag $tmp

             } elseif {$op == {write}} {
               return [{c++ set253} $this $tag]
             } else { error "Cannot unset C++ variable tag" }
           }

public variable ignoreNetworkTag
 method accessor257 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get255} $this]
               set ignoreNetworkTag $tmp

             } elseif {$op == {write}} {
               return [{c++ set256} $this $ignoreNetworkTag]
             } else { error "Cannot unset C++ variable ignoreNetworkTag" }
           }

protected variable field
 method accessor259 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get258} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable isDead
 method accessor261 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get260} $this]
               set isDead $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isDead"
             } else { error "Cannot unset C++ variable isDead" }
           }

protected variable x
 method accessor264 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get262} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set263} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

protected variable y
 method accessor267 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get265} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set266} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

protected variable vx
 method accessor270 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get268} $this]
               set vx $tmp

             } elseif {$op == {write}} {
               return [{c++ set269} $this $vx]
             } else { error "Cannot unset C++ variable vx" }
           }

protected variable vy
 method accessor273 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get271} $this]
               set vy $tmp

             } elseif {$op == {write}} {
               return [{c++ set272} $this $vy]
             } else { error "Cannot unset C++ variable vy" }
           }

protected variable includeInCollisionDetection
 method accessor276 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get274} $this]
               set includeInCollisionDetection $tmp

             } elseif {$op == {write}} {
               return [{c++ set275} $this $includeInCollisionDetection]
             } else { error "Cannot unset C++ variable includeInCollisionDetection" }
           }

protected variable classification
 method accessor279 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get277} $this]
               set classification $tmp

             } elseif {$op == {write}} {
               return [{c++ set278} $this $classification]
             } else { error "Cannot unset C++ variable classification" }
           }

protected variable decorative
 method accessor282 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get280} $this]
               set decorative $tmp

             } elseif {$op == {write}} {
               return [{c++ set281} $this $decorative]
             } else { error "Cannot unset C++ variable decorative" }
           }

namespace eval :: {
proc {c++ new TclGameObject default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline283} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject position} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline285} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject velocity} { a0 a1 a2 a3 a4 a5 a6  } {set retpi [uplevel 1 [list {c++ trampoline287} $a0 $a1 $a2 $a3 $a4 $a5 $a6 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {getX} {  } {set retpi [uplevel 1 [list {c++ trampoline293} $this ]]
set ret $retpi
return $ret
}
method {getY} {  } {set retpi [uplevel 1 [list {c++ trampoline295} $this ]]
set ret $retpi
return $ret
}
method {getVX} {  } {set retpi [uplevel 1 [list {c++ trampoline297} $this ]]
set ret $retpi
return $ret
}
method {getVY} {  } {set retpi [uplevel 1 [list {c++ trampoline299} $this ]]
set ret $retpi
return $ret
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline301} $this ]]
set ret $retpi
return $ret
}
method {isDecorative} {  } {set retpi [uplevel 1 [list {c++ trampoline303} $this ]]
set ret $retpi
return $ret
}
method {getClassification} {  } {set retpi [uplevel 1 [list {c++ trampoline305} $this ]]
set ret $retpi
return $ret
}
method {okToDecorate} {  } {set retpi [uplevel 1 [list {c++ trampoline307} $this ]]
return $retpi
}
method {teleport} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp310} $this $a0 $a1 $a2 ]]
return $retpi
}
method {getRotation} {  } {set retpi [uplevel 1 [list {c++ deftramp312} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getRadius"]
set ret $retpi
return $ret
}
method {isCollideable} {  } {set retpi [uplevel 1 [list {c++ deftramp316} $this ]]
set ret $retpi
return $ret
}
method {checkCollision} { a0  } {set retpi [uplevel 1 [list {c++ deftramp318} $this $a0 ]]
set ret $retpi
return $ret
}
method {del} {  } {set retpi [uplevel 1 [list {c++ trampoline319} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set isRemote {}
            trace add variable isRemote {read write unset} "$this accessor248"
set isExportable {}
            trace add variable isExportable {read write unset} "$this accessor251"
set tag {}
            trace add variable tag {read write unset} "$this accessor254"
set ignoreNetworkTag {}
            trace add variable ignoreNetworkTag {read write unset} "$this accessor257"
set field {}
            trace add variable field {read write unset} "$this accessor259"
set isDead {}
            trace add variable isDead {read write unset} "$this accessor261"
set x {}
            trace add variable x {read write unset} "$this accessor264"
set y {}
            trace add variable y {read write unset} "$this accessor267"
set vx {}
            trace add variable vx {read write unset} "$this accessor270"
set vy {}
            trace add variable vy {read write unset} "$this accessor273"
set includeInCollisionDetection {}
            trace add variable includeInCollisionDetection {read write unset} "$this accessor276"
set classification {}
            trace add variable classification {read write unset} "$this accessor279"
set decorative {}
            trace add variable decorative {read write unset} "$this accessor282"



















}
destructor {
trace remove variable isRemote {read write unset} "$this accessor248"
trace remove variable isExportable {read write unset} "$this accessor251"
trace remove variable tag {read write unset} "$this accessor254"
trace remove variable ignoreNetworkTag {read write unset} "$this accessor257"
trace remove variable field {read write unset} "$this accessor259"
trace remove variable isDead {read write unset} "$this accessor261"
trace remove variable x {read write unset} "$this accessor264"
trace remove variable y {read write unset} "$this accessor267"
trace remove variable vx {read write unset} "$this accessor270"
trace remove variable vy {read write unset} "$this accessor273"
trace remove variable includeInCollisionDetection {read write unset} "$this accessor276"
trace remove variable classification {read write unset} "$this accessor279"
trace remove variable decorative {read write unset} "$this accessor282"



















}
}


::itcl::class {GameField} {
inherit AObject
public variable fieldClock
 method accessor324 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get323} $this]
               set fieldClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to fieldClock"
             } else { error "Cannot unset C++ variable fieldClock" }
           }

public variable width
 method accessor327 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get325} $this]
               set width $tmp

             } elseif {$op == {write}} {
               return [{c++ set326} $this $width]
             } else { error "Cannot unset C++ variable width" }
           }

public variable height
 method accessor330 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get328} $this]
               set height $tmp

             } elseif {$op == {write}} {
               return [{c++ set329} $this $height]
             } else { error "Cannot unset C++ variable height" }
           }

public variable effects
 method accessor333 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get331} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set332} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable perfectRadar
 method accessor336 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get334} $this]
               set perfectRadar $tmp

             } elseif {$op == {write}} {
               return [{c++ set335} $this $perfectRadar]
             } else { error "Cannot unset C++ variable perfectRadar" }
           }

namespace eval :: {
proc {c++ new GameField default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline337} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline339} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline341} $this ]]
return $retpi
}
method {at} { a0  } {set retpi [uplevel 1 [list {c++ trampoline343} $this $a0 ]]
set ret $retpi
return $ret
}
method {size} {  } {set retpi [uplevel 1 [list {c++ trampoline345} $this ]]
set ret $retpi
return $ret
}
method {add} { a0  } {set retpi [uplevel 1 [list {c++ trampoline347} $this $a0 ]]
return $retpi
}
method {addBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline349} $this $a0 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline351} $this $a0 ]]
return $retpi
}
method {inject} { a0  } {set retpi [uplevel 1 [list {c++ trampoline353} $this $a0 ]]
return $retpi
}
method {clear} {  } {set retpi [uplevel 1 [list {c++ trampoline355} $this ]]
return $retpi
}
method {updateBoundaries} {  } {set retpi [uplevel 1 [list {c++ trampoline357} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set fieldClock {}
            trace add variable fieldClock {read write unset} "$this accessor324"
set width {}
            trace add variable width {read write unset} "$this accessor327"
set height {}
            trace add variable height {read write unset} "$this accessor330"
set effects {}
            trace add variable effects {read write unset} "$this accessor333"
set perfectRadar {}
            trace add variable perfectRadar {read write unset} "$this accessor336"











}
destructor {
trace remove variable fieldClock {read write unset} "$this accessor324"
trace remove variable width {read write unset} "$this accessor327"
trace remove variable height {read write unset} "$this accessor330"
trace remove variable effects {read write unset} "$this accessor333"
trace remove variable perfectRadar {read write unset} "$this accessor336"











}
}

::itcl::class {Blast} {
inherit GameObject
public variable blame
 method accessor361 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get360} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               error "Cannot write to blame"
             } else { error "Cannot unset C++ variable blame" }
           }

namespace eval :: {
proc {c++ new Blast default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline362} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDirect} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline364} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withSize} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline366} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withADC} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline368} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDecor} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline370} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDamage} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12  } {set retpi [uplevel 1 [list {c++ trampoline372} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast nonDamageCopy} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline374} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline376} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline378} $this ]]
return $retpi
}
method {getFalloff} {  } {set retpi [uplevel 1 [list {c++ trampoline380} $this ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline382} $this ]]
set ret $retpi
return $ret
}
method {getStrengthAt} { a0  } {set retpi [uplevel 1 [list {c++ trampoline384} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrengthUpon} { a0  } {set retpi [uplevel 1 [list {c++ trampoline386} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline388} $this ]]
set ret $retpi
return $ret
}
method {isDirect} {  } {set retpi [uplevel 1 [list {c++ trampoline390} $this ]]
set ret $retpi
return $ret
}
method {causesDamage} {  } {set retpi [uplevel 1 [list {c++ trampoline392} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set blame {}
            trace add variable blame {read write unset} "$this accessor361"
















}
destructor {
trace remove variable blame {read write unset} "$this accessor361"
















}
}

::itcl::class {CellFragment} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline395} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline397} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline399} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {PlasmaFire} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline402} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline404} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline406} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {Explosion} {
inherit GameObject
public variable hungry
 method accessor411 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get409} $this]
               set hungry $tmp

             } elseif {$op == {write}} {
               return [{c++ set410} $this $hungry]
             } else { error "Cannot unset C++ variable hungry" }
           }

namespace eval :: {
proc {c++ new Explosion stationary} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline412} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion velocity} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13  } {set retpi [uplevel 1 [list {c++ trampoline414} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion smeared} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15  } {set retpi [uplevel 1 [list {c++ trampoline416} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 $a15 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion by} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline418} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

method {multiExplosion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline420} $this $a0 ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline422} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline424} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline426} $this ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline428} $this ]]
set ret $retpi
return $ret
}
method {getDensity} {  } {set retpi [uplevel 1 [list {c++ trampoline430} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set hungry {}
            trace add variable hungry {read write unset} "$this accessor411"










}
destructor {
trace remove variable hungry {read write unset} "$this accessor411"










}
}


::itcl::class {OldStyleExplosion} {
inherit GameObject
namespace eval :: {
proc {c++ new OldStyleExplosion default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline433} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline435} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline437} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline439} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {LightTrail} {
inherit GameObject
namespace eval :: {
proc {c++ new LightTrail default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14  } {set retpi [uplevel 1 [list {c++ trampoline442} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline444} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline446} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline448} $this ]]
set ret $retpi
return $ret
}
method {setWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline450} $this $a0 ]]
return $retpi
}
method {emit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline452} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}







itcl::class fun<void:Ship*,bool>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<void:Ship*,bool>::fun_t {} {}
      } {}
    }
::itcl::class {fun<void:Ship*,bool>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<void:Ship*,bool> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline460} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
return $retpi
}
proc {call} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline464} $a0 $a1 $a2 ]]
return $retpi
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline466} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

::itcl::class {radar_t} {
inherit AObject
namespace eval :: {
proc {c++ new radar_t default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline469} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Ship} {
inherit GameObject
public variable controller
 method accessor474 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get472} $this]
               set controller $tmp

             } elseif {$op == {write}} {
               return [{c++ set473} $this $controller]
             } else { error "Cannot unset C++ variable controller" }
           }

public variable effects
 method accessor477 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get475} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set476} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable shipExistenceFailure
 method accessor480 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get478} $this]
               set shipExistenceFailure $tmp

             } elseif {$op == {write}} {
               return [{c++ set479} $this $shipExistenceFailure]
             } else { error "Cannot unset C++ variable shipExistenceFailure" }
           }


proc {cellCoord} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline481} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {cellSubCoord} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline483} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}
public variable insignia
 method accessor487 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get485} $this]
               set insignia $tmp

             } elseif {$op == {write}} {
               return [{c++ set486} $this $insignia]
             } else { error "Cannot unset C++ variable insignia" }
           }

public variable blame
 method accessor490 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get488} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               return [{c++ set489} $this $blame]
             } else { error "Cannot unset C++ variable blame" }
           }

public variable score
 method accessor493 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get491} $this]
               set score $tmp

             } elseif {$op == {write}} {
               return [{c++ set492} $this $score]
             } else { error "Cannot unset C++ variable score" }
           }

public variable damageMultiplier
 method accessor496 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get494} $this]
               set damageMultiplier $tmp

             } elseif {$op == {write}} {
               return [{c++ set495} $this $damageMultiplier]
             } else { error "Cannot unset C++ variable damageMultiplier" }
           }

public variable diedSpontaneously
 method accessor498 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get497} $this]
               set diedSpontaneously $tmp

             } elseif {$op == {write}} {
               error "Cannot write to diedSpontaneously"
             } else { error "Cannot unset C++ variable diedSpontaneously" }
           }

public variable typeName
 method accessor500 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get499} $this]
               set typeName $tmp

             } elseif {$op == {write}} {
               error "Cannot write to typeName"
             } else { error "Cannot unset C++ variable typeName" }
           }

namespace eval :: {
proc {c++ new Ship default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline501} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}


method {refreshUpdates} {  } {set retpi [uplevel 1 [list {c++ trampoline503} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline505} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline507} $this ]]
return $retpi
}

method {getVRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline509} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline511} $this ]]
set ret $retpi
return $ret
}
method {glSetColour0} {  } {set retpi [uplevel 1 [list {c++ trampoline513} $this ]]
return $retpi
}
method {glSetColour1} { a0  } {set retpi [uplevel 1 [list {c++ trampoline515} $this $a0 ]]
return $retpi
}
method {glSetColour2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline517} $this $a0 $a1 ]]
return $retpi
}
method {setThrust} { a0  } {set retpi [uplevel 1 [list {c++ trampoline519} $this $a0 ]]
return $retpi
}
method {getThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline521} $this ]]
set ret $retpi
return $ret
}
method {getTrueThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline523} $this ]]
set ret $retpi
return $ret
}
method {setThrustOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline525} $this $a0 ]]
return $retpi
}
method {isThrustOn} {  } {set retpi [uplevel 1 [list {c++ trampoline527} $this ]]
set ret $retpi
return $ret
}
method {setBrakeOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline529} $this $a0 ]]
return $retpi
}
method {isBrakeOn} {  } {set retpi [uplevel 1 [list {c++ trampoline531} $this ]]
set ret $retpi
return $ret
}
method {configureEngines} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline533} $this $a0 $a1 $a2 ]]
return $retpi
}
method {configureEngines2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline535} $this $a0 $a1 ]]
return $retpi
}
method {getAcceleration} {  } {set retpi [uplevel 1 [list {c++ trampoline537} $this ]]
set ret $retpi
return $ret
}
method {getRotationRate} {  } {set retpi [uplevel 1 [list {c++ trampoline539} $this ]]
set ret $retpi
return $ret
}
method {getRotationAccel} {  } {set retpi [uplevel 1 [list {c++ trampoline541} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline543} $this ]]
set ret $retpi
return $ret
}
method {getPowerUsagePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline545} $this ]]
set ret $retpi
return $ret
}
method {getPowerSupply} {  } {set retpi [uplevel 1 [list {c++ trampoline547} $this ]]
set ret $retpi
return $ret
}
method {getPowerDrain} {  } {set retpi [uplevel 1 [list {c++ trampoline549} $this ]]
set ret $retpi
return $ret
}
method {getCurrentCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline551} $this ]]
set ret $retpi
return $ret
}
method {getMaximumCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline553} $this ]]
set ret $retpi
return $ret
}
method {getCapacitancePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline555} $this ]]
set ret $retpi
return $ret
}
method {setColour} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline557} $this $a0 $a1 $a2 ]]
return $retpi
}
method {destroyGraphicsInfo} {  } {set retpi [uplevel 1 [list {c++ trampoline559} $this ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline561} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline563} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline565} $this ]]
set ret $retpi
return $ret
}
method {drawPower} { a0  } {set retpi [uplevel 1 [list {c++ trampoline567} $this $a0 ]]
set ret $retpi
return $ret
}
method {getReinforcement} {  } {set retpi [uplevel 1 [list {c++ trampoline569} $this ]]
set ret $retpi
return $ret
}
method {setReinforcement} { a0  } {set retpi [uplevel 1 [list {c++ trampoline571} $this $a0 ]]
return $retpi
}
method {enableSoundEffects} {  } {set retpi [uplevel 1 [list {c++ trampoline573} $this ]]
return $retpi
}

method {hasPower} {  } {set retpi [uplevel 1 [list {c++ trampoline575} $this ]]
set ret $retpi
return $ret
}
method {spontaneouslyDie} {  } {set retpi [uplevel 1 [list {c++ trampoline577} $this ]]
return $retpi
}
method {getCoolingMult} {  } {set retpi [uplevel 1 [list {c++ trampoline579} $this ]]
set ret $retpi
return $ret
}
method {getCellVelocity} { a0  } {set retpi [uplevel 1 [list {c++ trampoline581} $this $a0 ]]
set ret $retpi
return $ret
}

method {spin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline583} $this $a0 ]]
return $retpi
}
method {startTest} {  } {set retpi [uplevel 1 [list {c++ trampoline585} $this ]]
return $retpi
}
method {endTest} {  } {set retpi [uplevel 1 [list {c++ trampoline587} $this ]]
set ret $retpi
return $ret
}

method {applyCollision} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline589} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {cellCount} {  } {set retpi [uplevel 1 [list {c++ trampoline591} $this ]]
set ret $retpi
return $ret
}
method {getRadar} {  } {set retpi [uplevel 1 [list {c++ trampoline593} $this ]]
set ret $retpi
return $ret
}
method {setRadar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline595} $this $a0 ]]
return $retpi
}
method {getDeathAttributions} {  } {set retpi [uplevel 1 [list {c++ trampoline597} $this ]]
set ret $retpi
return $ret
}
method {categorise} {  } {set retpi [uplevel 1 [list {c++ trampoline599} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set controller {}
            trace add variable controller {read write unset} "$this accessor474"
set effects {}
            trace add variable effects {read write unset} "$this accessor477"
set shipExistenceFailure {}
            trace add variable shipExistenceFailure {read write unset} "$this accessor480"



set insignia {}
            trace add variable insignia {read write unset} "$this accessor487"
set blame {}
            trace add variable blame {read write unset} "$this accessor490"
set score {}
            trace add variable score {read write unset} "$this accessor493"
set damageMultiplier {}
            trace add variable damageMultiplier {read write unset} "$this accessor496"
set diedSpontaneously {}
            trace add variable diedSpontaneously {read write unset} "$this accessor498"
set typeName {}
            trace add variable typeName {read write unset} "$this accessor500"























































}
destructor {
trace remove variable controller {read write unset} "$this accessor474"
trace remove variable effects {read write unset} "$this accessor477"
trace remove variable shipExistenceFailure {read write unset} "$this accessor480"



trace remove variable insignia {read write unset} "$this accessor487"
trace remove variable blame {read write unset} "$this accessor490"
trace remove variable score {read write unset} "$this accessor493"
trace remove variable damageMultiplier {read write unset} "$this accessor496"
trace remove variable diedSpontaneously {read write unset} "$this accessor498"
trace remove variable typeName {read write unset} "$this accessor500"























































}
}

::itcl::class {ShipImageRenderer} {
inherit AObject
method {renderNext} {  } {set retpi [uplevel 1 [list {c++ trampoline602} $this ]]
set ret $retpi
return $ret
}
method {save} { a0  } {set retpi [uplevel 1 [list {c++ trampoline604} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

proc {ShipImageRenderer_create} { a0  } {set retpi [uplevel 1 [list {c++ trampoline606} $a0 ]]
set ret $retpi
return $ret
}
proc {verify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline608} $a0 ]]
set ret $retpi
return $ret
}
proc {loadShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline610} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {saveShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline612} $a0 $a1 ]]
return $retpi
}

::itcl::class {Shield} {
inherit AObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline615} $this $a0 ]]
return $retpi
}
method {updateDist} {  } {set retpi [uplevel 1 [list {c++ trampoline617} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline619} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline621} $this ]]
set ret $retpi
return $ret
}
method {collideWith} { a0  } {set retpi [uplevel 1 [list {c++ trampoline623} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline625} $this ]]
set ret $retpi
return $ret
}
method {getStability} {  } {set retpi [uplevel 1 [list {c++ trampoline627} $this ]]
set ret $retpi
return $ret
}
method {getShip} {  } {set retpi [uplevel 1 [list {c++ trampoline629} $this ]]
set ret $retpi
return $ret
}
method {drawForHUD} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline631} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {









}
destructor {









}
}


proc {insignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline633} $a0 ]]
set ret $retpi
return $ret
}
proc {clear_insignias} {  } {set retpi [uplevel 1 [list {c++ trampoline635} ]]
return $retpi
}

proc {getAlliance} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline637} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {setAlliance} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline639} $a0 $a1 $a2 ]]
return $retpi
}

::itcl::class {EnergyCharge} {
inherit GameObject
namespace eval :: {
proc {c++ new EnergyCharge default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline642} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp645} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline646} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline648} $this ]]
set ret $retpi
return $ret
}
method {getIntensity} {  } {set retpi [uplevel 1 [list {c++ trampoline650} $this ]]
set ret $retpi
return $ret
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline652} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {MagnetoBomb} {
inherit GameObject
namespace eval :: {
proc {c++ new MagnetoBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline655} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp658} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline659} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline661} $this ]]
set ret $retpi
return $ret
}
method {getPower} {  } {set retpi [uplevel 1 [list {c++ trampoline663} $this ]]
set ret $retpi
return $ret
}
method {simulateFailure} {  } {set retpi [uplevel 1 [list {c++ trampoline665} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {SemiguidedBomb} {
inherit MagnetoBomb
namespace eval :: {
proc {c++ new SemiguidedBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline668} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      MagnetoBomb::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {PlasmaBurst} {
inherit GameObject
namespace eval :: {
proc {c++ new PlasmaBurst default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline671} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp674} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline675} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline677} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline679} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {





}
destructor {





}
}

::itcl::class {MonophasicEnergyPulse} {
inherit GameObject
namespace eval :: {
proc {c++ new MonophasicEnergyPulse default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline682} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Missile} {
inherit GameObject
namespace eval :: {
proc {c++ new Missile default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline685} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {EffectsHandler} {
inherit AObject
namespace eval :: {
proc {c++ new EffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline688} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclEffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline690} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {impact} { a0  } {set retpi [uplevel 1 [list {c++ deftramp693} $this $a0 ]]
return $retpi
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ deftramp695} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

 proc accessor697 {ignored ignored op} {
             global nullEffectsHandler
             if {$op == {read}} {
               set tmp [{c++ get696} ]
               set nullEffectsHandler $tmp

             } elseif {$op == {write}} {
               error "Cannot write to nullEffectsHandler"
             } else { error "Cannot unset C++ variable nullEffectsHandler" }
           }

::itcl::class {Background} {
inherit EffectsHandler
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline699} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline701} $this $a0 ]]
return $retpi
}
method {updateReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline703} $this $a0 $a1 ]]
return $retpi
}
method {repopulate} {  } {set retpi [uplevel 1 [list {c++ trampoline705} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {Planet} {
inherit Background
namespace eval :: {
proc {c++ new Planet default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline708} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {StarField} {
inherit Background
namespace eval :: {
proc {c++ new StarField default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline711} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

proc {initStarLists} {  } {set retpi [uplevel 1 [list {c++ trampoline713} ]]
return $retpi
}

::itcl::class {Nebula} {
inherit Background
namespace eval :: {
proc {c++ new Nebula default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline716} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {setFlowEquation} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline718} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {setPressureEquation} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline720} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
method {setPressureResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline722} $this $a0 ]]
return $retpi
}
method {getPressureResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline724} $this ]]
set ret $retpi
return $ret
}
method {setVelocityResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline726} $this $a0 ]]
return $retpi
}
method {getVelocityResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline728} $this ]]
set ret $retpi
return $ret
}
method {setForceMultiplier} { a0  } {set retpi [uplevel 1 [list {c++ trampoline730} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {








}
destructor {








}
}


::itcl::class {Camera} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new TclCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline733} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

protected variable reference
 method accessor737 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get735} $this]
               set reference $tmp

             } elseif {$op == {write}} {
               return [{c++ set736} $this $reference]
             } else { error "Cannot unset C++ variable reference" }
           }

protected method {doSetup} {  } {set retpi [uplevel 1 error "Call to pure-virtual function doSetup"]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp741} $this $a0 ]]
return $retpi
}
method {drawOverlays} {  } {set retpi [uplevel 1 [list {c++ deftramp743} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ deftramp745} $this ]]
return $retpi
}
method {setup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline746} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set reference {}
            trace add variable reference {read write unset} "$this accessor737"





}
destructor {

trace remove variable reference {read write unset} "$this accessor737"





}
}


::itcl::class {DynamicCamera} {
inherit Camera
namespace eval :: {
proc {c++ new DynamicCamera default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline749} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline751} $this $a0 ]]
return $retpi
}
protected method {doSetup} {  } {set retpi [uplevel 1 [list {c++ trampoline753} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ trampoline755} $this ]]
return $retpi
}
method {getZoom} {  } {set retpi [uplevel 1 [list {c++ trampoline757} $this ]]
set ret $retpi
return $ret
}
method {setZoom} { a0  } {set retpi [uplevel 1 [list {c++ trampoline759} $this $a0 ]]
return $retpi
}
method {getRotateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline761} $this ]]
set ret $retpi
return $ret
}
method {setRotateMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline763} $this $a0 ]]
return $retpi
}
method {getLookAhead} {  } {set retpi [uplevel 1 [list {c++ trampoline765} $this ]]
set ret $retpi
return $ret
}
method {setLookAhead} { a0  } {set retpi [uplevel 1 [list {c++ trampoline767} $this $a0 ]]
return $retpi
}
method {getVisualRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline769} $this ]]
set ret $retpi
return $ret
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline771} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {












}
destructor {












}
}


::itcl::class {FixedCamera} {
inherit Camera
namespace eval :: {
proc {c++ new FixedCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline774} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {Controller} {
inherit AObject
public variable ship
 method accessor778 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get777} $this]
               set ship $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ship"
             } else { error "Cannot unset C++ variable ship" }
           }

namespace eval :: {
proc {c++ new TclController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline779} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
return $retpi
}
method {damage} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp784} $this $a0 $a1 $a2 ]]
return $retpi
}
method {otherShipDied} { a0  } {set retpi [uplevel 1 [list {c++ deftramp786} $this $a0 ]]
return $retpi
}
method {notifyScore} { a0  } {set retpi [uplevel 1 [list {c++ deftramp788} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set ship {}
            trace add variable ship {read write unset} "$this accessor778"





}
destructor {
trace remove variable ship {read write unset} "$this accessor778"





}
}


::itcl::class {HumanController} {
inherit Controller
namespace eval :: {
proc {c++ new HumanController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline790} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline792} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline794} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline796} $this $a0 ]]
return $retpi
}
method {button} { a0  } {set retpi [uplevel 1 [list {c++ trampoline798} $this $a0 ]]
return $retpi
}
method {key} { a0  } {set retpi [uplevel 1 [list {c++ trampoline800} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

 proc accessor803 {ignored ignored op} {
             global isCompositionBufferInUse
             if {$op == {read}} {
               set tmp [{c++ get802} ]
               set isCompositionBufferInUse $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isCompositionBufferInUse"
             } else { error "Cannot unset C++ variable isCompositionBufferInUse" }
           }

 proc accessor806 {ignored ignored op} {
             global compositionBufferPrefix
             if {$op == {read}} {
               set tmp [{c++ get804} ]
               set compositionBufferPrefix $tmp

             } elseif {$op == {write}} {
               return [{c++ set805}  $compositionBufferPrefix]
             } else { error "Cannot unset C++ variable compositionBufferPrefix" }
           }


proc {hc_conf_configure} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline807} $a0 $a1 ]]
return $retpi
}
proc {hc_conf_clear} {  } {set retpi [uplevel 1 [list {c++ trampoline809} ]]
return $retpi
}

::itcl::class {AIControl} {
inherit Controller
namespace eval :: {
proc {c++ new AIControl default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline812} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline814} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {GeneticAI} {
inherit Controller
namespace eval :: {
proc {c++ new GeneticAI default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline817} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline819} $this $a0 ]]
return $retpi
}
public variable species
 method accessor822 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get821} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor824 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get823} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

public variable instance
 method accessor826 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get825} $this]
               set instance $tmp

             } elseif {$op == {write}} {
               error "Cannot write to instance"
             } else { error "Cannot unset C++ variable instance" }
           }

public variable failed
 method accessor828 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get827} $this]
               set failed $tmp

             } elseif {$op == {write}} {
               error "Cannot write to failed"
             } else { error "Cannot unset C++ variable failed" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


set species {}
            trace add variable species {read write unset} "$this accessor822"
set generation {}
            trace add variable generation {read write unset} "$this accessor824"
set instance {}
            trace add variable instance {read write unset} "$this accessor826"
set failed {}
            trace add variable failed {read write unset} "$this accessor828"
}
destructor {


trace remove variable species {read write unset} "$this accessor822"
trace remove variable generation {read write unset} "$this accessor824"
trace remove variable instance {read write unset} "$this accessor826"
trace remove variable failed {read write unset} "$this accessor828"
}
}

proc {calculateGeneticAIFunctionCosts} {  } {set retpi [uplevel 1 [list {c++ trampoline829} ]]
return $retpi
}
::itcl::class {GenAI} {
inherit Controller
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline832} $this $a0 ]]
return $retpi
}
public variable species
 method accessor835 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get834} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor837 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get836} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

method {getScores} {  } {set retpi [uplevel 1 [list {c++ trampoline838} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set species {}
            trace add variable species {read write unset} "$this accessor835"
set generation {}
            trace add variable generation {read write unset} "$this accessor837"

}
destructor {

trace remove variable species {read write unset} "$this accessor835"
trace remove variable generation {read write unset} "$this accessor837"

}
}

proc {GenAI_make} { a0  } {set retpi [uplevel 1 [list {c++ trampoline840} $a0 ]]
set ret $retpi
return $ret
}

::itcl::class {CommonKeyboardClient} {
inherit AObject
namespace eval :: {
proc {c++ new CommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline843} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclCommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline845} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {exit} {  } {set retpi [uplevel 1 [list {c++ deftramp848} $this ]]
return $retpi
}
method {slow} {  } {set retpi [uplevel 1 [list {c++ deftramp850} $this ]]
return $retpi
}
method {fast} {  } {set retpi [uplevel 1 [list {c++ deftramp852} $this ]]
return $retpi
}
method {halt} {  } {set retpi [uplevel 1 [list {c++ deftramp854} $this ]]
return $retpi
}
method {frameXframe} {  } {set retpi [uplevel 1 [list {c++ deftramp856} $this ]]
return $retpi
}
method {statsOn} {  } {set retpi [uplevel 1 [list {c++ deftramp858} $this ]]
return $retpi
}
method {statsOff} {  } {set retpi [uplevel 1 [list {c++ deftramp860} $this ]]
return $retpi
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline861} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {










}
destructor {










}
}


::itcl::class {ForwardingEffectsHandler} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new ForwardingEffectsHandler default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline864} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Spectator} {
inherit GameObject
namespace eval :: {
proc {c++ new Spectator default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline867} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator explicit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline869} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator empty} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline871} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {nextReference} {  } {set retpi [uplevel 1 [list {c++ trampoline873} $this ]]
return $retpi
}
method {requireInsignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline875} $this $a0 ]]
return $retpi
}
method {kill} {  } {set retpi [uplevel 1 [list {c++ trampoline877} $this ]]
return $retpi
}
method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline879} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {GameEnv} {
inherit AObject
namespace eval :: {
proc {c++ new GameEnv customCamera} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline882} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new GameEnv default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline884} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline886} $this ]]
set ret $retpi
return $ret
}
method {setReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline888} $this $a0 $a1 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline890} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline892} $this ]]
return $retpi
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline894} $this ]]
set ret $retpi
return $ret
}
public variable cam
 method accessor898 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get896} $this]
               set cam $tmp

             } elseif {$op == {write}} {
               return [{c++ set897} $this $cam]
             } else { error "Cannot unset C++ variable cam" }
           }

public variable stars
 method accessor901 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get899} $this]
               set stars $tmp

             } elseif {$op == {write}} {
               return [{c++ set900} $this $stars]
             } else { error "Cannot unset C++ variable stars" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







set cam {}
            trace add variable cam {read write unset} "$this accessor898"
set stars {}
            trace add variable stars {read write unset} "$this accessor901"
}
destructor {







trace remove variable cam {read write unset} "$this accessor898"
trace remove variable stars {read write unset} "$this accessor901"
}
}


::itcl::class {Manipulator} {
inherit AObject
namespace eval :: {
proc {c++ new Manipulator default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline903} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} {  } {set retpi [uplevel 1 [list {c++ trampoline905} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline907} $this ]]
return $retpi
}
method {primaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline909} $this $a0 $a1 ]]
return $retpi
}
method {primaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline911} $this $a0 $a1 ]]
return $retpi
}
method {secondaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline913} $this $a0 $a1 ]]
return $retpi
}
method {secondaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline915} $this $a0 $a1 ]]
return $retpi
}
method {scrollUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline917} $this $a0 $a1 ]]
return $retpi
}
method {scrollDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline919} $this $a0 $a1 ]]
return $retpi
}
method {motion} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline921} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
method {resetView} {  } {set retpi [uplevel 1 [list {c++ trampoline923} $this ]]
return $retpi
}
method {pushUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline925} $this ]]
return $retpi
}
method {popUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline927} $this ]]
return $retpi
}
method {commitUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline929} $this ]]
return $retpi
}
method {deactivateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline931} $this ]]
return $retpi
}
method {activateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline933} $this ]]
return $retpi
}
method {addToHistory} {  } {set retpi [uplevel 1 [list {c++ trampoline935} $this ]]
return $retpi
}
method {revertToHistory} { a0  } {set retpi [uplevel 1 [list {c++ trampoline937} $this $a0 ]]
return $retpi
}
method {reloadShip} {  } {set retpi [uplevel 1 [list {c++ trampoline939} $this ]]
set ret $retpi
return $ret
}
method {deleteShip} {  } {set retpi [uplevel 1 [list {c++ trampoline941} $this ]]
return $retpi
}
method {copyMounts} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline943} $this $a0 $a1 ]]
return $retpi
}
method {getCellAt} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline945} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






















}
destructor {






















}
}


 proc accessor948 {ignored ignored op} {
             global planetgen_width
             if {$op == {read}} {
               set tmp [{c++ get947} ]
               set planetgen_width $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_width"
             } else { error "Cannot unset C++ variable planetgen_width" }
           }

 proc accessor950 {ignored ignored op} {
             global planetgen_height
             if {$op == {read}} {
               set tmp [{c++ get949} ]
               set planetgen_height $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_height"
             } else { error "Cannot unset C++ variable planetgen_height" }
           }

::itcl::class {PlanetGeneratorParms} {
inherit AObject
namespace eval :: {
proc {c++ new PlanetGeneratorParms default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline952} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable seed
 method accessor956 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get954} $this]
               set seed $tmp

             } elseif {$op == {write}} {
               return [{c++ set955} $this $seed]
             } else { error "Cannot unset C++ variable seed" }
           }

public variable continents
 method accessor959 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get957} $this]
               set continents $tmp

             } elseif {$op == {write}} {
               return [{c++ set958} $this $continents]
             } else { error "Cannot unset C++ variable continents" }
           }

public variable largeIslands
 method accessor962 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get960} $this]
               set largeIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set961} $this $largeIslands]
             } else { error "Cannot unset C++ variable largeIslands" }
           }

public variable smallIslands
 method accessor965 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get963} $this]
               set smallIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set964} $this $smallIslands]
             } else { error "Cannot unset C++ variable smallIslands" }
           }

public variable islandGrouping
 method accessor968 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get966} $this]
               set islandGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set967} $this $islandGrouping]
             } else { error "Cannot unset C++ variable islandGrouping" }
           }

public variable landSlope
 method accessor971 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get969} $this]
               set landSlope $tmp

             } elseif {$op == {write}} {
               return [{c++ set970} $this $landSlope]
             } else { error "Cannot unset C++ variable landSlope" }
           }

public variable oceans
 method accessor974 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get972} $this]
               set oceans $tmp

             } elseif {$op == {write}} {
               return [{c++ set973} $this $oceans]
             } else { error "Cannot unset C++ variable oceans" }
           }

public variable seas
 method accessor977 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get975} $this]
               set seas $tmp

             } elseif {$op == {write}} {
               return [{c++ set976} $this $seas]
             } else { error "Cannot unset C++ variable seas" }
           }

public variable lakes
 method accessor980 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get978} $this]
               set lakes $tmp

             } elseif {$op == {write}} {
               return [{c++ set979} $this $lakes]
             } else { error "Cannot unset C++ variable lakes" }
           }

public variable rivers
 method accessor983 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get981} $this]
               set rivers $tmp

             } elseif {$op == {write}} {
               return [{c++ set982} $this $rivers]
             } else { error "Cannot unset C++ variable rivers" }
           }

public variable mountainRanges
 method accessor986 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get984} $this]
               set mountainRanges $tmp

             } elseif {$op == {write}} {
               return [{c++ set985} $this $mountainRanges]
             } else { error "Cannot unset C++ variable mountainRanges" }
           }

public variable mountainSteepness
 method accessor989 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get987} $this]
               set mountainSteepness $tmp

             } elseif {$op == {write}} {
               return [{c++ set988} $this $mountainSteepness]
             } else { error "Cannot unset C++ variable mountainSteepness" }
           }

public variable enormousMountains
 method accessor992 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get990} $this]
               set enormousMountains $tmp

             } elseif {$op == {write}} {
               return [{c++ set991} $this $enormousMountains]
             } else { error "Cannot unset C++ variable enormousMountains" }
           }

public variable craters
 method accessor995 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get993} $this]
               set craters $tmp

             } elseif {$op == {write}} {
               return [{c++ set994} $this $craters]
             } else { error "Cannot unset C++ variable craters" }
           }

public variable maxCraterSize
 method accessor998 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get996} $this]
               set maxCraterSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set997} $this $maxCraterSize]
             } else { error "Cannot unset C++ variable maxCraterSize" }
           }

public variable equatorTemperature
 method accessor1001 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get999} $this]
               set equatorTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set1000} $this $equatorTemperature]
             } else { error "Cannot unset C++ variable equatorTemperature" }
           }

public variable solarEquator
 method accessor1004 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1002} $this]
               set solarEquator $tmp

             } elseif {$op == {write}} {
               return [{c++ set1003} $this $solarEquator]
             } else { error "Cannot unset C++ variable solarEquator" }
           }

public variable polarTemperature
 method accessor1007 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1005} $this]
               set polarTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set1006} $this $polarTemperature]
             } else { error "Cannot unset C++ variable polarTemperature" }
           }

public variable altitudeTemperatureDelta
 method accessor1010 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1008} $this]
               set altitudeTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set1009} $this $altitudeTemperatureDelta]
             } else { error "Cannot unset C++ variable altitudeTemperatureDelta" }
           }

public variable waterTemperatureDelta
 method accessor1013 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1011} $this]
               set waterTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set1012} $this $waterTemperatureDelta]
             } else { error "Cannot unset C++ variable waterTemperatureDelta" }
           }

public variable freezingPoint
 method accessor1016 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1014} $this]
               set freezingPoint $tmp

             } elseif {$op == {write}} {
               return [{c++ set1015} $this $freezingPoint]
             } else { error "Cannot unset C++ variable freezingPoint" }
           }

public variable humidity
 method accessor1019 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1017} $this]
               set humidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set1018} $this $humidity]
             } else { error "Cannot unset C++ variable humidity" }
           }

public variable vapourTransport
 method accessor1022 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1020} $this]
               set vapourTransport $tmp

             } elseif {$op == {write}} {
               return [{c++ set1021} $this $vapourTransport]
             } else { error "Cannot unset C++ variable vapourTransport" }
           }

public variable mountainBlockage
 method accessor1025 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1023} $this]
               set mountainBlockage $tmp

             } elseif {$op == {write}} {
               return [{c++ set1024} $this $mountainBlockage]
             } else { error "Cannot unset C++ variable mountainBlockage" }
           }

public variable vegitationHumidity
 method accessor1028 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1026} $this]
               set vegitationHumidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set1027} $this $vegitationHumidity]
             } else { error "Cannot unset C++ variable vegitationHumidity" }
           }

public variable cities
 method accessor1031 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1029} $this]
               set cities $tmp

             } elseif {$op == {write}} {
               return [{c++ set1030} $this $cities]
             } else { error "Cannot unset C++ variable cities" }
           }

public variable maxCitySize
 method accessor1034 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1032} $this]
               set maxCitySize $tmp

             } elseif {$op == {write}} {
               return [{c++ set1033} $this $maxCitySize]
             } else { error "Cannot unset C++ variable maxCitySize" }
           }

public variable cityGrouping
 method accessor1037 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1035} $this]
               set cityGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set1036} $this $cityGrouping]
             } else { error "Cannot unset C++ variable cityGrouping" }
           }

public variable waterColour
 method accessor1040 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1038} $this]
               set waterColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1039} $this $waterColour]
             } else { error "Cannot unset C++ variable waterColour" }
           }

public variable vegitationColour
 method accessor1043 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1041} $this]
               set vegitationColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1042} $this $vegitationColour]
             } else { error "Cannot unset C++ variable vegitationColour" }
           }

public variable lowerPlanetColour
 method accessor1046 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1044} $this]
               set lowerPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1045} $this $lowerPlanetColour]
             } else { error "Cannot unset C++ variable lowerPlanetColour" }
           }

public variable upperPlanetColour
 method accessor1049 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1047} $this]
               set upperPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1048} $this $upperPlanetColour]
             } else { error "Cannot unset C++ variable upperPlanetColour" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set seed {}
            trace add variable seed {read write unset} "$this accessor956"
set continents {}
            trace add variable continents {read write unset} "$this accessor959"
set largeIslands {}
            trace add variable largeIslands {read write unset} "$this accessor962"
set smallIslands {}
            trace add variable smallIslands {read write unset} "$this accessor965"
set islandGrouping {}
            trace add variable islandGrouping {read write unset} "$this accessor968"
set landSlope {}
            trace add variable landSlope {read write unset} "$this accessor971"
set oceans {}
            trace add variable oceans {read write unset} "$this accessor974"
set seas {}
            trace add variable seas {read write unset} "$this accessor977"
set lakes {}
            trace add variable lakes {read write unset} "$this accessor980"
set rivers {}
            trace add variable rivers {read write unset} "$this accessor983"
set mountainRanges {}
            trace add variable mountainRanges {read write unset} "$this accessor986"
set mountainSteepness {}
            trace add variable mountainSteepness {read write unset} "$this accessor989"
set enormousMountains {}
            trace add variable enormousMountains {read write unset} "$this accessor992"
set craters {}
            trace add variable craters {read write unset} "$this accessor995"
set maxCraterSize {}
            trace add variable maxCraterSize {read write unset} "$this accessor998"
set equatorTemperature {}
            trace add variable equatorTemperature {read write unset} "$this accessor1001"
set solarEquator {}
            trace add variable solarEquator {read write unset} "$this accessor1004"
set polarTemperature {}
            trace add variable polarTemperature {read write unset} "$this accessor1007"
set altitudeTemperatureDelta {}
            trace add variable altitudeTemperatureDelta {read write unset} "$this accessor1010"
set waterTemperatureDelta {}
            trace add variable waterTemperatureDelta {read write unset} "$this accessor1013"
set freezingPoint {}
            trace add variable freezingPoint {read write unset} "$this accessor1016"
set humidity {}
            trace add variable humidity {read write unset} "$this accessor1019"
set vapourTransport {}
            trace add variable vapourTransport {read write unset} "$this accessor1022"
set mountainBlockage {}
            trace add variable mountainBlockage {read write unset} "$this accessor1025"
set vegitationHumidity {}
            trace add variable vegitationHumidity {read write unset} "$this accessor1028"
set cities {}
            trace add variable cities {read write unset} "$this accessor1031"
set maxCitySize {}
            trace add variable maxCitySize {read write unset} "$this accessor1034"
set cityGrouping {}
            trace add variable cityGrouping {read write unset} "$this accessor1037"
set waterColour {}
            trace add variable waterColour {read write unset} "$this accessor1040"
set vegitationColour {}
            trace add variable vegitationColour {read write unset} "$this accessor1043"
set lowerPlanetColour {}
            trace add variable lowerPlanetColour {read write unset} "$this accessor1046"
set upperPlanetColour {}
            trace add variable upperPlanetColour {read write unset} "$this accessor1049"
}
destructor {

trace remove variable seed {read write unset} "$this accessor956"
trace remove variable continents {read write unset} "$this accessor959"
trace remove variable largeIslands {read write unset} "$this accessor962"
trace remove variable smallIslands {read write unset} "$this accessor965"
trace remove variable islandGrouping {read write unset} "$this accessor968"
trace remove variable landSlope {read write unset} "$this accessor971"
trace remove variable oceans {read write unset} "$this accessor974"
trace remove variable seas {read write unset} "$this accessor977"
trace remove variable lakes {read write unset} "$this accessor980"
trace remove variable rivers {read write unset} "$this accessor983"
trace remove variable mountainRanges {read write unset} "$this accessor986"
trace remove variable mountainSteepness {read write unset} "$this accessor989"
trace remove variable enormousMountains {read write unset} "$this accessor992"
trace remove variable craters {read write unset} "$this accessor995"
trace remove variable maxCraterSize {read write unset} "$this accessor998"
trace remove variable equatorTemperature {read write unset} "$this accessor1001"
trace remove variable solarEquator {read write unset} "$this accessor1004"
trace remove variable polarTemperature {read write unset} "$this accessor1007"
trace remove variable altitudeTemperatureDelta {read write unset} "$this accessor1010"
trace remove variable waterTemperatureDelta {read write unset} "$this accessor1013"
trace remove variable freezingPoint {read write unset} "$this accessor1016"
trace remove variable humidity {read write unset} "$this accessor1019"
trace remove variable vapourTransport {read write unset} "$this accessor1022"
trace remove variable mountainBlockage {read write unset} "$this accessor1025"
trace remove variable vegitationHumidity {read write unset} "$this accessor1028"
trace remove variable cities {read write unset} "$this accessor1031"
trace remove variable maxCitySize {read write unset} "$this accessor1034"
trace remove variable cityGrouping {read write unset} "$this accessor1037"
trace remove variable waterColour {read write unset} "$this accessor1040"
trace remove variable vegitationColour {read write unset} "$this accessor1043"
trace remove variable lowerPlanetColour {read write unset} "$this accessor1046"
trace remove variable upperPlanetColour {read write unset} "$this accessor1049"
}
}

proc {planetgen_begin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1050} $a0 ]]
return $retpi
}
proc {planetgen_what} {  } {set retpi [uplevel 1 [list {c++ trampoline1052} ]]
set ret $retpi
return $ret
}
proc {planetgen_progress} {  } {set retpi [uplevel 1 [list {c++ trampoline1054} ]]
set ret $retpi
return $ret
}
proc {planetgen_done} {  } {set retpi [uplevel 1 [list {c++ trampoline1056} ]]
set ret $retpi
return $ret
}
proc {planetgen_kill} {  } {set retpi [uplevel 1 [list {c++ trampoline1058} ]]
return $retpi
}
proc {planetgen_save} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1060} $a0 $a1 ]]
return $retpi
}

proc {set_hud_message} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1062} $a0 $a1 ]]
return $retpi
}
proc {global_chat_post} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1064} $a0 ]]
return $retpi
}
proc {global_chat_post_local} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1066} $a0 ]]
return $retpi
}
proc {global_chat_post_remote} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1068} $a0 ]]
return $retpi
}
 proc accessor1072 {ignored ignored op} {
             global state
             if {$op == {read}} {
               set tmp [{c++ get1070} ]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set1071}  $state]
             } else { error "Cannot unset C++ variable state" }
           }


 proc accessor1074 {ignored ignored op} {
             global PLATFORM
             if {$op == {read}} {
               set tmp [{c++ get1073} ]
               set PLATFORM $tmp

             } elseif {$op == {write}} {
               error "Cannot write to PLATFORM"
             } else { error "Cannot unset C++ variable PLATFORM" }
           }

 proc accessor1076 {ignored ignored op} {
             global screenW
             if {$op == {read}} {
               set tmp [{c++ get1075} ]
               set screenW $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenW"
             } else { error "Cannot unset C++ variable screenW" }
           }

 proc accessor1078 {ignored ignored op} {
             global screenH
             if {$op == {read}} {
               set tmp [{c++ get1077} ]
               set screenH $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenH"
             } else { error "Cannot unset C++ variable screenH" }
           }

 proc accessor1080 {ignored ignored op} {
             global vheight
             if {$op == {read}} {
               set tmp [{c++ get1079} ]
               set vheight $tmp

             } elseif {$op == {write}} {
               error "Cannot write to vheight"
             } else { error "Cannot unset C++ variable vheight" }
           }

 proc accessor1083 {ignored ignored op} {
             global generalAlphaBlending
             if {$op == {read}} {
               set tmp [{c++ get1081} ]
               set generalAlphaBlending $tmp

             } elseif {$op == {write}} {
               return [{c++ set1082}  $generalAlphaBlending]
             } else { error "Cannot unset C++ variable generalAlphaBlending" }
           }

 proc accessor1086 {ignored ignored op} {
             global alphaBlendingEnabled
             if {$op == {read}} {
               set tmp [{c++ get1084} ]
               set alphaBlendingEnabled $tmp

             } elseif {$op == {write}} {
               return [{c++ set1085}  $alphaBlendingEnabled]
             } else { error "Cannot unset C++ variable alphaBlendingEnabled" }
           }

 proc accessor1089 {ignored ignored op} {
             global smoothScaling
             if {$op == {read}} {
               set tmp [{c++ get1087} ]
               set smoothScaling $tmp

             } elseif {$op == {write}} {
               return [{c++ set1088}  $smoothScaling]
             } else { error "Cannot unset C++ variable smoothScaling" }
           }

 proc accessor1092 {ignored ignored op} {
             global highQuality
             if {$op == {read}} {
               set tmp [{c++ get1090} ]
               set highQuality $tmp

             } elseif {$op == {write}} {
               return [{c++ set1091}  $highQuality]
             } else { error "Cannot unset C++ variable highQuality" }
           }

 proc accessor1095 {ignored ignored op} {
             global antialiasing
             if {$op == {read}} {
               set tmp [{c++ get1093} ]
               set antialiasing $tmp

             } elseif {$op == {write}} {
               return [{c++ set1094}  $antialiasing]
             } else { error "Cannot unset C++ variable antialiasing" }
           }


 proc accessor1097 {ignored ignored op} {
             global headless
             if {$op == {read}} {
               set tmp [{c++ get1096} ]
               set headless $tmp

             } elseif {$op == {write}} {
               error "Cannot write to headless"
             } else { error "Cannot unset C++ variable headless" }
           }

 proc accessor1100 {ignored ignored op} {
             global cameraX1
             if {$op == {read}} {
               set tmp [{c++ get1098} ]
               set cameraX1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1099}  $cameraX1]
             } else { error "Cannot unset C++ variable cameraX1" }
           }

 proc accessor1103 {ignored ignored op} {
             global cameraX2
             if {$op == {read}} {
               set tmp [{c++ get1101} ]
               set cameraX2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1102}  $cameraX2]
             } else { error "Cannot unset C++ variable cameraX2" }
           }

 proc accessor1106 {ignored ignored op} {
             global cameraY1
             if {$op == {read}} {
               set tmp [{c++ get1104} ]
               set cameraY1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1105}  $cameraY1]
             } else { error "Cannot unset C++ variable cameraY1" }
           }

 proc accessor1109 {ignored ignored op} {
             global cameraY2
             if {$op == {read}} {
               set tmp [{c++ get1107} ]
               set cameraY2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1108}  $cameraY2]
             } else { error "Cannot unset C++ variable cameraY2" }
           }

 proc accessor1112 {ignored ignored op} {
             global cameraCX
             if {$op == {read}} {
               set tmp [{c++ get1110} ]
               set cameraCX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1111}  $cameraCX]
             } else { error "Cannot unset C++ variable cameraCX" }
           }

 proc accessor1115 {ignored ignored op} {
             global cameraCY
             if {$op == {read}} {
               set tmp [{c++ get1113} ]
               set cameraCY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1114}  $cameraCY]
             } else { error "Cannot unset C++ variable cameraCY" }
           }

 proc accessor1118 {ignored ignored op} {
             global cameraZoom
             if {$op == {read}} {
               set tmp [{c++ get1116} ]
               set cameraZoom $tmp

             } elseif {$op == {write}} {
               return [{c++ set1117}  $cameraZoom]
             } else { error "Cannot unset C++ variable cameraZoom" }
           }

 proc accessor1121 {ignored ignored op} {
             global cursorX
             if {$op == {read}} {
               set tmp [{c++ get1119} ]
               set cursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1120}  $cursorX]
             } else { error "Cannot unset C++ variable cursorX" }
           }

 proc accessor1124 {ignored ignored op} {
             global cursorY
             if {$op == {read}} {
               set tmp [{c++ get1122} ]
               set cursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1123}  $cursorY]
             } else { error "Cannot unset C++ variable cursorY" }
           }

 proc accessor1127 {ignored ignored op} {
             global oldCursorX
             if {$op == {read}} {
               set tmp [{c++ get1125} ]
               set oldCursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1126}  $oldCursorX]
             } else { error "Cannot unset C++ variable oldCursorX" }
           }

 proc accessor1130 {ignored ignored op} {
             global oldCursorY
             if {$op == {read}} {
               set tmp [{c++ get1128} ]
               set oldCursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1129}  $oldCursorY]
             } else { error "Cannot unset C++ variable oldCursorY" }
           }


 proc accessor1132 {ignored ignored op} {
             global currentFrameTime
             if {$op == {read}} {
               set tmp [{c++ get1131} ]
               set currentFrameTime $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTime"
             } else { error "Cannot unset C++ variable currentFrameTime" }
           }

 proc accessor1134 {ignored ignored op} {
             global currentFrameTimeLeft
             if {$op == {read}} {
               set tmp [{c++ get1133} ]
               set currentFrameTimeLeft $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTimeLeft"
             } else { error "Cannot unset C++ variable currentFrameTimeLeft" }
           }

 proc accessor1136 {ignored ignored op} {
             global currentVFrameLast
             if {$op == {read}} {
               set tmp [{c++ get1135} ]
               set currentVFrameLast $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentVFrameLast"
             } else { error "Cannot unset C++ variable currentVFrameLast" }
           }

 proc accessor1138 {ignored ignored op} {
             global frameRate
             if {$op == {read}} {
               set tmp [{c++ get1137} ]
               set frameRate $tmp

             } elseif {$op == {write}} {
               error "Cannot write to frameRate"
             } else { error "Cannot unset C++ variable frameRate" }
           }

 proc accessor1140 {ignored ignored op} {
             global sparkCountMultiplier
             if {$op == {read}} {
               set tmp [{c++ get1139} ]
               set sparkCountMultiplier $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sparkCountMultiplier"
             } else { error "Cannot unset C++ variable sparkCountMultiplier" }
           }

 proc accessor1142 {ignored ignored op} {
             global gameClock
             if {$op == {read}} {
               set tmp [{c++ get1141} ]
               set gameClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to gameClock"
             } else { error "Cannot unset C++ variable gameClock" }
           }

 proc accessor1144 {ignored ignored op} {
             global STD_CELL_SZ
             if {$op == {read}} {
               set tmp [{c++ get1143} ]
               set STD_CELL_SZ $tmp

             } elseif {$op == {write}} {
               error "Cannot write to STD_CELL_SZ"
             } else { error "Cannot unset C++ variable STD_CELL_SZ" }
           }

::itcl::class {SquareIcon} {
inherit AObject
namespace eval :: {
proc {c++ new SquareIcon default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1146} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {load} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1148} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {unload} {  } {set retpi [uplevel 1 [list {c++ trampoline1150} $this ]]
return $retpi
}
method {isLoaded} {  } {set retpi [uplevel 1 [list {c++ trampoline1152} $this ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline1154} $this ]]
return $retpi
}
method {save} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1156} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}




::itcl::class {Antenna} {
inherit AObject
namespace eval :: {
proc {c++ new Antenna default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1161} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable tuner
 method accessor1165 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1163} $this]
               set tuner $tmp

             } elseif {$op == {write}} {
               return [{c++ set1164} $this $tuner]
             } else { error "Cannot unset C++ variable tuner" }
           }

method {setInternetInformation4} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline1166} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {setInternetInformation6} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline1168} $this $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
return $retpi
}
method {getGlobalID4} {  } {set retpi [uplevel 1 [list {c++ trampoline1170} $this ]]
set ret $retpi
return $ret
}
method {getGlobalID6} {  } {set retpi [uplevel 1 [list {c++ trampoline1172} $this ]]
set ret $retpi
return $ret
}
method {hasV4} {  } {set retpi [uplevel 1 [list {c++ trampoline1174} $this ]]
set ret $retpi
return $ret
}
method {hasV6} {  } {set retpi [uplevel 1 [list {c++ trampoline1176} $this ]]
set ret $retpi
return $ret
}
method {processIncomming} {  } {set retpi [uplevel 1 [list {c++ trampoline1178} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set tuner {}
            trace add variable tuner {read write unset} "$this accessor1165"







}
destructor {

trace remove variable tuner {read write unset} "$this accessor1165"







}
}

 proc accessor1181 {ignored ignored op} {
             global antenna
             if {$op == {read}} {
               set tmp [{c++ get1180} ]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

 proc accessor1184 {ignored ignored op} {
             global packetDropMask
             if {$op == {read}} {
               set tmp [{c++ get1182} ]
               set packetDropMask $tmp

             } elseif {$op == {write}} {
               return [{c++ set1183}  $packetDropMask]
             } else { error "Cannot unset C++ variable packetDropMask" }
           }


::itcl::class {Tuner} {
inherit AObject
namespace eval :: {
proc {c++ new Tuner default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1186} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {GlobalID} {
inherit AObject
namespace eval :: {
proc {c++ new GlobalID default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1189} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {toString} {  } {set retpi [uplevel 1 [list {c++ trampoline1191} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {PacketProcessor} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}



::itcl::class {NetworkAssembly} {
inherit AObject
public variable field
 method accessor1197 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1196} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable antenna
 method accessor1199 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1198} $this]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

namespace eval :: {
proc {c++ new NetworkAssembly default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1200} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getTuner} {  } {set retpi [uplevel 1 [list {c++ trampoline1202} $this ]]
set ret $retpi
return $ret
}
method {numConnections} {  } {set retpi [uplevel 1 [list {c++ trampoline1204} $this ]]
set ret $retpi
return $ret
}
method {getConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1206} $this $a0 ]]
set ret $retpi
return $ret
}
method {addConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1208} $this $a0 ]]
return $retpi
}
method {removeConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1210} $this $a0 ]]
return $retpi
}
method {addPacketProcessor} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1212} $this $a0 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1214} $this $a0 ]]
return $retpi
}
method {setFieldSize} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1216} $this $a0 $a1 ]]
return $retpi
}
method {changeField} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1218} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set field {}
            trace add variable field {read write unset} "$this accessor1197"
set antenna {}
            trace add variable antenna {read write unset} "$this accessor1199"










}
destructor {
trace remove variable field {read write unset} "$this accessor1197"
trace remove variable antenna {read write unset} "$this accessor1199"










}
}



::itcl::class {NetworkConnection} {
inherit PacketProcessor
public variable parent
 method accessor1223 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1222} $this]
               set parent $tmp

             } elseif {$op == {write}} {
               error "Cannot write to parent"
             } else { error "Cannot unset C++ variable parent" }
           }

public variable scg
 method accessor1225 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1224} $this]
               set scg $tmp

             } elseif {$op == {write}} {
               error "Cannot write to scg"
             } else { error "Cannot unset C++ variable scg" }
           }

public variable blameMask
 method accessor1228 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1226} $this]
               set blameMask $tmp

             } elseif {$op == {write}} {
               return [{c++ set1227} $this $blameMask]
             } else { error "Cannot unset C++ variable blameMask" }
           }

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1229} $this $a0 ]]
return $retpi
}
method {getStatus} {  } {set retpi [uplevel 1 [list {c++ trampoline1231} $this ]]
set ret $retpi
return $ret
}
method {getDisconnectReason} {  } {set retpi [uplevel 1 [list {c++ trampoline1233} $this ]]
set ret $retpi
return $ret
}
method {setFieldSize} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1235} $this $a0 $a1 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set parent {}
            trace add variable parent {read write unset} "$this accessor1223"
set scg {}
            trace add variable scg {read write unset} "$this accessor1225"
set blameMask {}
            trace add variable blameMask {read write unset} "$this accessor1228"




}
destructor {
trace remove variable parent {read write unset} "$this accessor1223"
trace remove variable scg {read write unset} "$this accessor1225"
trace remove variable blameMask {read write unset} "$this accessor1228"




}
}


::itcl::class {ConnectionListener} {
inherit PacketProcessor
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}


::itcl::class {InputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

::itcl::class {OutputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

itcl::class fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {} {}
      } {}
    }
::itcl::class {fun<InputNetworkGeraet*:NetworkConnection*>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<InputNetworkGeraet*:NetworkConnection*> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1241} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
set ret $retpi
return $ret
}
proc {call} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1245} $a0 $a1 ]]
set ret $retpi
return $ret
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline1247} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {SynchronousControlGeraet} {
inherit AObject
method {openChannel} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1250} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {GameAdvertiser} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameAdvertiser default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline1253} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {setOverseerId} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1255} $this $a0 ]]
return $retpi
}
method {setPeerCount} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1257} $this $a0 ]]
return $retpi
}
method {setGameMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1259} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {GameDiscoverer} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameDiscoverer default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1262} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {start} {  } {set retpi [uplevel 1 [list {c++ trampoline1264} $this ]]
return $retpi
}
method {poll} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1266} $this $a0 ]]
return $retpi
}
method {progress} {  } {set retpi [uplevel 1 [list {c++ trampoline1268} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}




::itcl::class {SeqTextOutputGeraet} {
inherit OutputNetworkGeraet
namespace eval :: {
proc {c++ new SeqTextOutputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1272} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {send} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1274} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      OutputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

::itcl::class {SeqTextInputGeraet} {
inherit InputNetworkGeraet
namespace eval :: {
proc {c++ new TclSeqTextInputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1277} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {receiveText} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveText"]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      InputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {Peer} {
inherit AObject
public variable gid
 method accessor1283 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1282} $this]
               set gid $tmp

             } elseif {$op == {write}} {
               error "Cannot write to gid"
             } else { error "Cannot unset C++ variable gid" }
           }

public variable nid
 method accessor1285 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1284} $this]
               set nid $tmp

             } elseif {$op == {write}} {
               error "Cannot write to nid"
             } else { error "Cannot unset C++ variable nid" }
           }

public variable overseerReady
 method accessor1287 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1286} $this]
               set overseerReady $tmp

             } elseif {$op == {write}} {
               error "Cannot write to overseerReady"
             } else { error "Cannot unset C++ variable overseerReady" }
           }

public variable connectionAttempts
 method accessor1289 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1288} $this]
               set connectionAttempts $tmp

             } elseif {$op == {write}} {
               error "Cannot write to connectionAttempts"
             } else { error "Cannot unset C++ variable connectionAttempts" }
           }

public variable cxn
 method accessor1291 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1290} $this]
               set cxn $tmp

             } elseif {$op == {write}} {
               error "Cannot write to cxn"
             } else { error "Cannot unset C++ variable cxn" }
           }

public variable screenName
 method accessor1293 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1292} $this]
               set screenName $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenName"
             } else { error "Cannot unset C++ variable screenName" }
           }

public variable receivedStx
 method accessor1295 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1294} $this]
               set receivedStx $tmp

             } elseif {$op == {write}} {
               error "Cannot write to receivedStx"
             } else { error "Cannot unset C++ variable receivedStx" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set gid {}
            trace add variable gid {read write unset} "$this accessor1283"
set nid {}
            trace add variable nid {read write unset} "$this accessor1285"
set overseerReady {}
            trace add variable overseerReady {read write unset} "$this accessor1287"
set connectionAttempts {}
            trace add variable connectionAttempts {read write unset} "$this accessor1289"
set cxn {}
            trace add variable cxn {read write unset} "$this accessor1291"
set screenName {}
            trace add variable screenName {read write unset} "$this accessor1293"
set receivedStx {}
            trace add variable receivedStx {read write unset} "$this accessor1295"
}
destructor {
trace remove variable gid {read write unset} "$this accessor1283"
trace remove variable nid {read write unset} "$this accessor1285"
trace remove variable overseerReady {read write unset} "$this accessor1287"
trace remove variable connectionAttempts {read write unset} "$this accessor1289"
trace remove variable cxn {read write unset} "$this accessor1291"
trace remove variable screenName {read write unset} "$this accessor1293"
trace remove variable receivedStx {read write unset} "$this accessor1295"
}
}

::itcl::class {NetIface} {
inherit AObject
namespace eval :: {
proc {c++ new TclNetIface default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1297} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {addPeer} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function addPeer"]
return $retpi
}
method {delPeer} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function delPeer"]
return $retpi
}
method {setOverseer} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function setOverseer"]
return $retpi
}
method {receiveBroadcast} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveBroadcast"]
return $retpi
}
method {receiveOverseer} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveOverseer"]
return $retpi
}
method {receiveUnicast} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveUnicast"]
return $retpi
}
method {alterDatp} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function alterDatp"]
set ret $retpi
return $ret
}
method {alterDats} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function alterDats"]
set ret $retpi
return $ret
}
method {setGameMode} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function setGameMode"]
return $retpi
}
method {getGameMode} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getGameMode"]
set ret $retpi
return $ret
}
method {connectionLost} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function connectionLost"]
return $retpi
}
method {getFullDats} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getFullDats"]
set ret $retpi
return $ret
}
method {receiveShip} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveShip"]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {














}
destructor {














}
}

::itcl::class {NetworkGame} {
inherit AObject
namespace eval :: {
proc {c++ new NetworkGame default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1326} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {getLocalPeer} {  } {set retpi [uplevel 1 [list {c++ trampoline1328} $this ]]
set ret $retpi
return $ret
}
method {getOverseer} {  } {set retpi [uplevel 1 [list {c++ trampoline1330} $this ]]
set ret $retpi
return $ret
}
method {getPeerByConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1332} $this $a0 ]]
set ret $retpi
return $ret
}
method {getDisconnectReason} {  } {set retpi [uplevel 1 [list {c++ trampoline1334} $this ]]
set ret $retpi
return $ret
}
method {setNetIface} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1336} $this $a0 ]]
return $retpi
}
method {setAdvertising} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1338} $this $a0 ]]
return $retpi
}
method {stopAdvertising} {  } {set retpi [uplevel 1 [list {c++ trampoline1340} $this ]]
return $retpi
}
method {startDiscoveryScan} {  } {set retpi [uplevel 1 [list {c++ trampoline1342} $this ]]
return $retpi
}
method {discoveryScanProgress} {  } {set retpi [uplevel 1 [list {c++ trampoline1344} $this ]]
set ret $retpi
return $ret
}
method {discoveryScanDone} {  } {set retpi [uplevel 1 [list {c++ trampoline1346} $this ]]
set ret $retpi
return $ret
}
method {getDiscoveryResults} {  } {set retpi [uplevel 1 [list {c++ trampoline1348} $this ]]
set ret $retpi
return $ret
}
method {setLocalPeerName} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1350} $this $a0 ]]
return $retpi
}
method {setLocalPeerNID} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1352} $this $a0 ]]
return $retpi
}
method {setLocalPeerNIDAuto} {  } {set retpi [uplevel 1 [list {c++ trampoline1354} $this ]]
return $retpi
}
method {connectToNothing} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1356} $this $a0 $a1 ]]
return $retpi
}
method {connectToDiscovery} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1358} $this $a0 ]]
return $retpi
}
method {connectToLan} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1360} $this $a0 $a1 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1362} $this $a0 ]]
return $retpi
}
method {updateFieldSize} {  } {set retpi [uplevel 1 [list {c++ trampoline1364} $this ]]
return $retpi
}
method {changeField} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1366} $this $a0 ]]
return $retpi
}
method {alterDats} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1368} $this $a0 $a1 ]]
return $retpi
}
method {alterDatp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1370} $this $a0 $a1 ]]
return $retpi
}
method {sendUnicast} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1372} $this $a0 $a1 ]]
return $retpi
}
method {sendOverseer} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1374} $this $a0 $a1 ]]
return $retpi
}
method {sendBroadcast} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1376} $this $a0 ]]
return $retpi
}
method {sendGameMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1378} $this $a0 ]]
return $retpi
}
method {setBlameMask} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1380} $this $a0 $a1 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




























}
destructor {




























}
}


::itcl::class {ConfReg} {
inherit AObject
method {open} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1383} $this $a0 $a1 ]]
return $retpi
}
method {create} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1385} $this $a0 $a1 ]]
return $retpi
}
method {close} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1387} $this $a0 ]]
return $retpi
}
method {closeAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1389} $this ]]
return $retpi
}
method {modify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1391} $this $a0 ]]
return $retpi
}
method {unmodify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1393} $this $a0 ]]
return $retpi
}
method {sync} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1395} $this $a0 ]]
return $retpi
}
method {syncAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1397} $this ]]
return $retpi
}
method {revert} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1399} $this $a0 ]]
return $retpi
}
method {revertAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1401} $this ]]
return $retpi
}
method {addToWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1403} $this $a0 ]]
return $retpi
}
method {removeFromWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1405} $this $a0 ]]
return $retpi
}
method {clearWhitelist} {  } {set retpi [uplevel 1 [list {c++ trampoline1407} $this ]]
return $retpi
}
method {setWhitelistOnly} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1409} $this $a0 ]]
return $retpi
}
method {renameFile} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1411} $this $a0 $a1 ]]
return $retpi
}

method {exists} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1413} $this $a0 ]]
set ret $retpi
return $ret
}
method {bool} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1415} $this $a0 ]]
set ret $retpi
return $ret
}
method {int} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1417} $this $a0 ]]
set ret $retpi
return $ret
}
method {float} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1419} $this $a0 ]]
set ret $retpi
return $ret
}
method {str} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1421} $this $a0 ]]
set ret $retpi
return $ret
}
method {setb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1423} $this $a0 $a1 ]]
return $retpi
}
method {seti} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1425} $this $a0 $a1 ]]
return $retpi
}
method {setf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1427} $this $a0 $a1 ]]
return $retpi
}
method {sets} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1429} $this $a0 $a1 ]]
return $retpi
}
method {add} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1431} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addb} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1433} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addi} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1435} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addf} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1437} $this $a0 $a1 $a2 ]]
return $retpi
}
method {adds} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1439} $this $a0 $a1 $a2 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1441} $this $a0 ]]
return $retpi
}
method {append} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1443} $this $a0 $a1 ]]
return $retpi
}
method {appendb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1445} $this $a0 $a1 ]]
return $retpi
}
method {appendi} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1447} $this $a0 $a1 ]]
return $retpi
}
method {appendf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1449} $this $a0 $a1 ]]
return $retpi
}
method {appends} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1451} $this $a0 $a1 ]]
return $retpi
}
method {remix} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1453} $this $a0 $a1 ]]
return $retpi
}
method {name} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1455} $this $a0 ]]
set ret $retpi
return $ret
}
method {copy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1457} $this $a0 $a1 ]]
return $retpi
}
method {getType} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1459} $this $a0 ]]
set ret $retpi
return $ret
}
method {length} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1461} $this $a0 ]]
set ret $retpi
return $ret
}
method {isGroup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1463} $this $a0 ]]
set ret $retpi
return $ret
}
method {isArray} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1465} $this $a0 ]]
set ret $retpi
return $ret
}
method {isList} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1467} $this $a0 ]]
set ret $retpi
return $ret
}
method {isAggregate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1469} $this $a0 ]]
set ret $retpi
return $ret
}
method {isScalar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1471} $this $a0 ]]
set ret $retpi
return $ret
}
method {isNumber} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1473} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSourceLine} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1475} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
















































}
destructor {
















































}
}

 proc accessor1478 {ignored ignored op} {
             global globalConf
             if {$op == {read}} {
               set tmp [{c++ get1477} ]
               set globalConf $tmp

             } elseif {$op == {write}} {
               error "Cannot write to globalConf"
             } else { error "Cannot unset C++ variable globalConf" }
           }

proc {confcpy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1479} $a0 $a1 ]]
return $retpi
}
proc {l10n_acceptLanguage} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1481} $a0 ]]
return $retpi
}
proc {l10n_loadCatalogue} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1483} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {l10n_purgeCatalogue} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1485} $a0 ]]
return $retpi
}

proc {_} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1487} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
proc {namegenAny} {  } {set retpi [uplevel 1 [list {c++ trampoline1489} ]]
set ret $retpi
return $ret
}
proc {namegenGet} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1491} $a0 ]]
set ret $retpi
return $ret
}
proc {newInterpreter} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1493} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {delInterpreter} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1495} $a0 ]]
return $retpi
}

proc {safe_source} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1497} $a0 ]]
return $retpi
}
proc {bkg_start} {  } {set retpi [uplevel 1 [list {c++ trampoline1499} ]]
return $retpi
}
proc {bkg_req} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1501} $a0 ]]
return $retpi
}
proc {bkg_ans} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1503} $a0 ]]
return $retpi
}
proc {bkg_req2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1505} $a0 $a1 ]]
return $retpi
}
proc {bkg_ans2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1507} $a0 $a1 ]]
return $retpi
}
proc {bkg_rcv} {  } {set retpi [uplevel 1 [list {c++ trampoline1509} ]]
set ret $retpi
return $ret
}
proc {bkg_get} {  } {set retpi [uplevel 1 [list {c++ trampoline1511} ]]
set ret $retpi
return $ret
}
proc {bkg_wait} {  } {set retpi [uplevel 1 [list {c++ trampoline1513} ]]
return $retpi
}

proc {crypto_init} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1515} $a0 ]]
return $retpi
}
proc {crypto_rand} {  } {set retpi [uplevel 1 [list {c++ trampoline1517} ]]
set ret $retpi
return $ret
}
proc {crypto_powm} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1519} $a0 $a1 ]]
set ret $retpi
return $ret
}

proc {performValidation} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1521} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {getValidationResultA} {  } {set retpi [uplevel 1 [list {c++ trampoline1523} ]]
set ret $retpi
return $ret
}
proc {getValidationResultB} {  } {set retpi [uplevel 1 [list {c++ trampoline1525} ]]
set ret $retpi
return $ret
}

::itcl::class {NetworkTest} {
inherit TestState
namespace eval :: {
proc {c++ new NetworkTest default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1528} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      TestState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


proc {ship_mixer_init} {  } {set retpi [uplevel 1 [list {c++ trampoline1530} ]]
return $retpi
}
proc {ship_mixer_end} {  } {set retpi [uplevel 1 [list {c++ trampoline1532} ]]
return $retpi
}

proc {joystick_count} {  } {set retpi [uplevel 1 [list {c++ trampoline1534} ]]
set ret $retpi
return $ret
}
proc {joystick_name} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1536} $a0 ]]
set ret $retpi
return $ret
}
proc {joystick_axisCount} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1538} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {joystick_buttonCount} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1540} $a0 $a1 ]]
set ret $retpi
return $ret
}

proc {frame_recorder_enable} {  } {set retpi [uplevel 1 [list {c++ trampoline1542} ]]
return $retpi
}
proc {frame_recorder_setFrameRate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1544} $a0 ]]
return $retpi
}

proc {debugTclExports} {  } {set retpi [uplevel 1 [list {c++ trampoline1546} ]]
return $retpi
}































set SDLK_LAST {}
trace add variable SDLK_LAST {read write unset} accessor60

set none {}
trace add variable none {read write unset} accessor64
set lshift {}
trace add variable lshift {read write unset} accessor66
set rshift {}
trace add variable rshift {read write unset} accessor68
set lctrl {}
trace add variable lctrl {read write unset} accessor70
set rctrl {}
trace add variable rctrl {read write unset} accessor72
set lalt {}
trace add variable lalt {read write unset} accessor74
set ralt {}
trace add variable ralt {read write unset} accessor76
set lmeta {}
trace add variable lmeta {read write unset} accessor78
set rmeta {}
trace add variable rmeta {read write unset} accessor80
set num {}
trace add variable num {read write unset} accessor82
set caps {}
trace add variable caps {read write unset} accessor84
set mode {}
trace add variable mode {read write unset} accessor86
set reserved {}
trace add variable reserved {read write unset} accessor88
set glueClass(SDL_keysym) yes





set glueClass(SDL_KeyboardEvent) yes




set SDL_BUTTON_1 {}
trace add variable SDL_BUTTON_1 {read write unset} accessor113
set SDL_BUTTON_2 {}
trace add variable SDL_BUTTON_2 {read write unset} accessor115
set SDL_BUTTON_3 {}
trace add variable SDL_BUTTON_3 {read write unset} accessor117
set SDL_BUTTON_4 {}
trace add variable SDL_BUTTON_4 {read write unset} accessor119
set SDL_BUTTON_5 {}
trace add variable SDL_BUTTON_5 {read write unset} accessor121

set SDL_DEFAULT_REPEAT_INTERVAL {}
trace add variable SDL_DEFAULT_REPEAT_INTERVAL {read write unset} accessor125
set SDL_DEFAULT_REPEAT_DELAY {}
trace add variable SDL_DEFAULT_REPEAT_DELAY {read write unset} accessor127


set glueClass(SDL_MouseMotionEvent) yes







set glueClass(SDL_MouseButtonEvent) yes











set preliminaryRunMode {}
trace add variable preliminaryRunMode {read write unset} accessor175
set THIS_GL_TYPE {}
trace add variable THIS_GL_TYPE {read write unset} accessor177
set recommendedGLType {}
trace add variable recommendedGLType {read write unset} accessor180


set glueClass(Font) yes












set sysfont {}
trace add variable sysfont {read write unset} accessor205
set sysfontStipple {}
trace add variable sysfontStipple {read write unset} accessor207
set glueClass(GameState) yes








set glueClass(InitState) yes



set gameClass {}
trace add variable gameClass {read write unset} accessor228
set humanShip {}
trace add variable humanShip {read write unset} accessor231
set testStateMode {}
trace add variable testStateMode {read write unset} accessor234
set testStateSize {}
trace add variable testStateSize {read write unset} accessor237
set glueClass(TestState) yes






set glueClass(GameObject) yes


































set glueClass(GameField) yes

















set glueClass(Blast) yes


















set glueClass(CellFragment) yes




set glueClass(PlasmaFire) yes




set glueClass(Explosion) yes













set glueClass(OldStyleExplosion) yes






set glueClass(LightTrail) yes














set glueClass(fun<void:Ship*,bool>) yes





set glueClass(radar_t) yes


set glueClass(Ship) yes




































































set glueClass(ShipImageRenderer) yes








set glueClass(Shield) yes

















set glueClass(EnergyCharge) yes







set glueClass(MagnetoBomb) yes







set glueClass(SemiguidedBomb) yes


set glueClass(PlasmaBurst) yes






set glueClass(MonophasicEnergyPulse) yes


set glueClass(Missile) yes


set glueClass(EffectsHandler) yes





set nullEffectsHandler {}
trace add variable nullEffectsHandler {read write unset} accessor697
set glueClass(Background) yes






set glueClass(Planet) yes



set glueClass(StarField) yes




set glueClass(Nebula) yes










set glueClass(Camera) yes









set glueClass(DynamicCamera) yes














set glueClass(FixedCamera) yes



set glueClass(Controller) yes








set glueClass(HumanController) yes







set isCompositionBufferInUse {}
trace add variable isCompositionBufferInUse {read write unset} accessor803
set compositionBufferPrefix {}
trace add variable compositionBufferPrefix {read write unset} accessor806




set glueClass(AIControl) yes




set glueClass(GeneticAI) yes








set glueClass(GenAI) yes







set glueClass(CommonKeyboardClient) yes












set glueClass(ForwardingEffectsHandler) yes


set glueClass(Spectator) yes








set glueClass(GameEnv) yes











set glueClass(Manipulator) yes
























set planetgen_width {}
trace add variable planetgen_width {read write unset} accessor948
set planetgen_height {}
trace add variable planetgen_height {read write unset} accessor950
set glueClass(PlanetGeneratorParms) yes













































set state {}
trace add variable state {read write unset} accessor1072

set PLATFORM {}
trace add variable PLATFORM {read write unset} accessor1074
set screenW {}
trace add variable screenW {read write unset} accessor1076
set screenH {}
trace add variable screenH {read write unset} accessor1078
set vheight {}
trace add variable vheight {read write unset} accessor1080
set generalAlphaBlending {}
trace add variable generalAlphaBlending {read write unset} accessor1083
set alphaBlendingEnabled {}
trace add variable alphaBlendingEnabled {read write unset} accessor1086
set smoothScaling {}
trace add variable smoothScaling {read write unset} accessor1089
set highQuality {}
trace add variable highQuality {read write unset} accessor1092
set antialiasing {}
trace add variable antialiasing {read write unset} accessor1095

set headless {}
trace add variable headless {read write unset} accessor1097
set cameraX1 {}
trace add variable cameraX1 {read write unset} accessor1100
set cameraX2 {}
trace add variable cameraX2 {read write unset} accessor1103
set cameraY1 {}
trace add variable cameraY1 {read write unset} accessor1106
set cameraY2 {}
trace add variable cameraY2 {read write unset} accessor1109
set cameraCX {}
trace add variable cameraCX {read write unset} accessor1112
set cameraCY {}
trace add variable cameraCY {read write unset} accessor1115
set cameraZoom {}
trace add variable cameraZoom {read write unset} accessor1118
set cursorX {}
trace add variable cursorX {read write unset} accessor1121
set cursorY {}
trace add variable cursorY {read write unset} accessor1124
set oldCursorX {}
trace add variable oldCursorX {read write unset} accessor1127
set oldCursorY {}
trace add variable oldCursorY {read write unset} accessor1130

set currentFrameTime {}
trace add variable currentFrameTime {read write unset} accessor1132
set currentFrameTimeLeft {}
trace add variable currentFrameTimeLeft {read write unset} accessor1134
set currentVFrameLast {}
trace add variable currentVFrameLast {read write unset} accessor1136
set frameRate {}
trace add variable frameRate {read write unset} accessor1138
set sparkCountMultiplier {}
trace add variable sparkCountMultiplier {read write unset} accessor1140
set gameClock {}
trace add variable gameClock {read write unset} accessor1142
set STD_CELL_SZ {}
trace add variable STD_CELL_SZ {read write unset} accessor1144
set glueClass(SquareIcon) yes










set glueClass(Antenna) yes










set antenna {}
trace add variable antenna {read write unset} accessor1181
set packetDropMask {}
trace add variable packetDropMask {read write unset} accessor1184

set glueClass(Tuner) yes



set glueClass(GlobalID) yes




set glueClass(PacketProcessor) yes



set glueClass(NetworkAssembly) yes















set glueClass(NetworkConnection) yes









set glueClass(ConnectionListener) yes


set glueClass(InputNetworkGeraet) yes

set glueClass(OutputNetworkGeraet) yes


set glueClass(fun<InputNetworkGeraet*:NetworkConnection*>) yes






set glueClass(SynchronousControlGeraet) yes



set glueClass(GameAdvertiser) yes






set glueClass(GameDiscoverer) yes








set glueClass(SeqTextOutputGeraet) yes



set glueClass(SeqTextInputGeraet) yes




set glueClass(Peer) yes








set glueClass(NetIface) yes















set glueClass(NetworkGame) yes






























set glueClass(ConfReg) yes

















































set globalConf {}
trace add variable globalConf {read write unset} accessor1478





























set glueClass(NetworkTest) yes
















safe_source tcl/autosource.tcl
