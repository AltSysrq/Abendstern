
  package require Itcl

  # AUTOGENERATED BY generate.tcl. DO NOT EDIT DIRECTLY.
  # See readme.txt.

  #Our base Tcl glue code (eval'd to hardwire the magic cookie)
  eval [format {
    itcl::class AObject {
      # Ensure all code uses the fully-qualified name for C++ to recognize it
      method fqn {} {::return $this}

      protected constructor {cppClass constname cppArgs} {
        if {[::string length $constname]} {
          # Intercept errors so we don't leak the magic number
          if {[catch {
            "::c++ new $cppClass $constname" $this %s {*}$cppArgs
          } err]} {
            error "Bad constructor call: $cppClass $constname: $err"
          }
        }
      }
      destructor {
        {::c++ delete} $this %s
      }

      method super {sup cname {args {}}} {
        ${sup}::constructor $sup $cname $args
      }

      # Prevent access to the magic cookie by redirecting
      # all info requests to the global one
      method info {args} {
        ::namespace eval :: ::info {*}$args
      }
    }
  } ${ABENDSTERN-MAGIC-COOKIE-1} ${ABENDSTERN-MAGIC-COOKIE-1}]
  unset ABENDSTERN-MAGIC-COOKIE-1

  # Have rename commit suicide
  # rename rename {}

  set glueClass(AObject) yes

  proc new {clazz args} {
    global glueClass
    if {[info exists glueClass($clazz)]} {
      [$clazz #auto $clazz [lindex $args 0] [lrange $args 1 [llength $args]]] fqn
    } else {
      [$clazz #auto {*}$args] fqn
    }
  }

proc {c++ delete} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1} $a0 $a1 ]]
return $retpi
}
proc {glBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline3} $a0 ]]
return $retpi
}
proc {glEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline5} ]]
return $retpi
}
proc {glVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline7} $a0 $a1 ]]
return $retpi
}
proc {glColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline9} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {glPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline11} ]]
return $retpi
}
proc {glPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline13} ]]
return $retpi
}
proc {glLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline15} ]]
return $retpi
}
proc {glTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline17} $a0 $a1 ]]
return $retpi
}
proc {glRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline19} $a0 ]]
return $retpi
}
proc {glScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline21} $a0 $a1 ]]
return $retpi
}
proc {glUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline23} $a0 ]]
return $retpi
}
proc {glReset} {  } {set retpi [uplevel 1 [list {c++ trampoline25} ]]
return $retpi
}

proc {acsgi_begin} {  } {set retpi [uplevel 1 [list {c++ trampoline27} ]]
return $retpi
}
proc {acsgi_end} {  } {set retpi [uplevel 1 [list {c++ trampoline29} ]]
return $retpi
}
proc {acsgi_draw} {  } {set retpi [uplevel 1 [list {c++ trampoline31} ]]
return $retpi
}
proc {acsgi_textNormal} { a0  } {set retpi [uplevel 1 [list {c++ trampoline33} $a0 ]]
return $retpi
}
proc {cglBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline35} $a0 ]]
return $retpi
}
proc {cglEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline37} ]]
return $retpi
}
proc {cglVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline39} $a0 $a1 ]]
return $retpi
}
proc {cglColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline41} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {cglPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline43} ]]
return $retpi
}
proc {cglPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline45} ]]
return $retpi
}
proc {cglLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline47} ]]
return $retpi
}
proc {cglTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline49} $a0 $a1 ]]
return $retpi
}
proc {cglRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline51} $a0 ]]
return $retpi
}
proc {cglScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline53} $a0 $a1 ]]
return $retpi
}
proc {cglUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline55} $a0 ]]
return $retpi
}
proc {cglText} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline57} $a0 $a1 $a2 ]]
return $retpi
}
 proc accessor60 {ignored ignored op} {
             global SDLK_LAST
             if {$op == {read}} {
               set tmp [{c++ get59} ]
               set SDLK_LAST $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDLK_LAST"
             } else { error "Cannot unset C++ variable SDLK_LAST" }
           }

proc {SDLKeyToInt} { a0  } {set retpi [uplevel 1 [list {c++ trampoline61} $a0 ]]
set ret $retpi
return $ret
}
 proc accessor64 {ignored ignored op} {
             global none
             if {$op == {read}} {
               set tmp [{c++ get63} ]
               set none $tmp

             } elseif {$op == {write}} {
               error "Cannot write to none"
             } else { error "Cannot unset C++ variable none" }
           }

 proc accessor66 {ignored ignored op} {
             global lshift
             if {$op == {read}} {
               set tmp [{c++ get65} ]
               set lshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lshift"
             } else { error "Cannot unset C++ variable lshift" }
           }

 proc accessor68 {ignored ignored op} {
             global rshift
             if {$op == {read}} {
               set tmp [{c++ get67} ]
               set rshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rshift"
             } else { error "Cannot unset C++ variable rshift" }
           }

 proc accessor70 {ignored ignored op} {
             global lctrl
             if {$op == {read}} {
               set tmp [{c++ get69} ]
               set lctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lctrl"
             } else { error "Cannot unset C++ variable lctrl" }
           }

 proc accessor72 {ignored ignored op} {
             global rctrl
             if {$op == {read}} {
               set tmp [{c++ get71} ]
               set rctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rctrl"
             } else { error "Cannot unset C++ variable rctrl" }
           }

 proc accessor74 {ignored ignored op} {
             global lalt
             if {$op == {read}} {
               set tmp [{c++ get73} ]
               set lalt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lalt"
             } else { error "Cannot unset C++ variable lalt" }
           }

 proc accessor76 {ignored ignored op} {
             global ralt
             if {$op == {read}} {
               set tmp [{c++ get75} ]
               set ralt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ralt"
             } else { error "Cannot unset C++ variable ralt" }
           }

 proc accessor78 {ignored ignored op} {
             global lmeta
             if {$op == {read}} {
               set tmp [{c++ get77} ]
               set lmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lmeta"
             } else { error "Cannot unset C++ variable lmeta" }
           }

 proc accessor80 {ignored ignored op} {
             global rmeta
             if {$op == {read}} {
               set tmp [{c++ get79} ]
               set rmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rmeta"
             } else { error "Cannot unset C++ variable rmeta" }
           }

 proc accessor82 {ignored ignored op} {
             global num
             if {$op == {read}} {
               set tmp [{c++ get81} ]
               set num $tmp

             } elseif {$op == {write}} {
               error "Cannot write to num"
             } else { error "Cannot unset C++ variable num" }
           }

 proc accessor84 {ignored ignored op} {
             global caps
             if {$op == {read}} {
               set tmp [{c++ get83} ]
               set caps $tmp

             } elseif {$op == {write}} {
               error "Cannot write to caps"
             } else { error "Cannot unset C++ variable caps" }
           }

 proc accessor86 {ignored ignored op} {
             global mode
             if {$op == {read}} {
               set tmp [{c++ get85} ]
               set mode $tmp

             } elseif {$op == {write}} {
               error "Cannot write to mode"
             } else { error "Cannot unset C++ variable mode" }
           }

 proc accessor88 {ignored ignored op} {
             global reserved
             if {$op == {read}} {
               set tmp [{c++ get87} ]
               set reserved $tmp

             } elseif {$op == {write}} {
               error "Cannot write to reserved"
             } else { error "Cannot unset C++ variable reserved" }
           }

::itcl::class {SDL_keysym} {
inherit AObject
public variable scancode
 method accessor92 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get90} $this]
               set scancode $tmp

             } elseif {$op == {write}} {
               return [{c++ set91} $this $scancode]
             } else { error "Cannot unset C++ variable scancode" }
           }

public variable sym
 method accessor95 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get93} $this]
               set sym $tmp

             } elseif {$op == {write}} {
               return [{c++ set94} $this $sym]
             } else { error "Cannot unset C++ variable sym" }
           }

public variable mod
 method accessor98 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get96} $this]
               set mod $tmp

             } elseif {$op == {write}} {
               return [{c++ set97} $this $mod]
             } else { error "Cannot unset C++ variable mod" }
           }

public variable unicode
 method accessor101 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get99} $this]
               set unicode $tmp

             } elseif {$op == {write}} {
               return [{c++ set100} $this $unicode]
             } else { error "Cannot unset C++ variable unicode" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set scancode {}
            trace add variable scancode {read write unset} "$this accessor92"
set sym {}
            trace add variable sym {read write unset} "$this accessor95"
set mod {}
            trace add variable mod {read write unset} "$this accessor98"
set unicode {}
            trace add variable unicode {read write unset} "$this accessor101"
}
destructor {
trace remove variable scancode {read write unset} "$this accessor92"
trace remove variable sym {read write unset} "$this accessor95"
trace remove variable mod {read write unset} "$this accessor98"
trace remove variable unicode {read write unset} "$this accessor101"
}
}

::itcl::class {SDL_KeyboardEvent} {
inherit AObject
public variable type
 method accessor105 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get103} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set104} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor108 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get106} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set107} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable keysym
 method accessor111 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get109} $this]
               set keysym $tmp

             } elseif {$op == {write}} {
               return [{c++ set110} $this $keysym]
             } else { error "Cannot unset C++ variable keysym" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor105"
set state {}
            trace add variable state {read write unset} "$this accessor108"
set keysym {}
            trace add variable keysym {read write unset} "$this accessor111"
}
destructor {
trace remove variable type {read write unset} "$this accessor105"
trace remove variable state {read write unset} "$this accessor108"
trace remove variable keysym {read write unset} "$this accessor111"
}
}

 proc accessor113 {ignored ignored op} {
             global SDL_BUTTON_1
             if {$op == {read}} {
               set tmp [{c++ get112} ]
               set SDL_BUTTON_1 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_1"
             } else { error "Cannot unset C++ variable SDL_BUTTON_1" }
           }

 proc accessor115 {ignored ignored op} {
             global SDL_BUTTON_2
             if {$op == {read}} {
               set tmp [{c++ get114} ]
               set SDL_BUTTON_2 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_2"
             } else { error "Cannot unset C++ variable SDL_BUTTON_2" }
           }

 proc accessor117 {ignored ignored op} {
             global SDL_BUTTON_3
             if {$op == {read}} {
               set tmp [{c++ get116} ]
               set SDL_BUTTON_3 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_3"
             } else { error "Cannot unset C++ variable SDL_BUTTON_3" }
           }

 proc accessor119 {ignored ignored op} {
             global SDL_BUTTON_4
             if {$op == {read}} {
               set tmp [{c++ get118} ]
               set SDL_BUTTON_4 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_4"
             } else { error "Cannot unset C++ variable SDL_BUTTON_4" }
           }

 proc accessor121 {ignored ignored op} {
             global SDL_BUTTON_5
             if {$op == {read}} {
               set tmp [{c++ get120} ]
               set SDL_BUTTON_5 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_5"
             } else { error "Cannot unset C++ variable SDL_BUTTON_5" }
           }

proc {SDL_GetModState} {  } {set retpi [uplevel 1 [list {c++ trampoline122} ]]
set ret $retpi
return $ret
}
 proc accessor125 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_INTERVAL
             if {$op == {read}} {
               set tmp [{c++ get124} ]
               set SDL_DEFAULT_REPEAT_INTERVAL $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_INTERVAL"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_INTERVAL" }
           }

 proc accessor127 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_DELAY
             if {$op == {read}} {
               set tmp [{c++ get126} ]
               set SDL_DEFAULT_REPEAT_DELAY $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_DELAY"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_DELAY" }
           }

proc {SDL_EnableKeyRepeat} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline128} $a0 $a1 ]]
return $retpi
}

::itcl::class {SDL_MouseMotionEvent} {
inherit AObject
public variable type
 method accessor133 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get131} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set132} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor136 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get134} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set135} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor139 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get137} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set138} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor142 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get140} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set141} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

public variable xrel
 method accessor145 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get143} $this]
               set xrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set144} $this $xrel]
             } else { error "Cannot unset C++ variable xrel" }
           }

public variable yrel
 method accessor148 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get146} $this]
               set yrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set147} $this $yrel]
             } else { error "Cannot unset C++ variable yrel" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor133"
set state {}
            trace add variable state {read write unset} "$this accessor136"
set x {}
            trace add variable x {read write unset} "$this accessor139"
set y {}
            trace add variable y {read write unset} "$this accessor142"
set xrel {}
            trace add variable xrel {read write unset} "$this accessor145"
set yrel {}
            trace add variable yrel {read write unset} "$this accessor148"
}
destructor {
trace remove variable type {read write unset} "$this accessor133"
trace remove variable state {read write unset} "$this accessor136"
trace remove variable x {read write unset} "$this accessor139"
trace remove variable y {read write unset} "$this accessor142"
trace remove variable xrel {read write unset} "$this accessor145"
trace remove variable yrel {read write unset} "$this accessor148"
}
}

::itcl::class {SDL_MouseButtonEvent} {
inherit AObject
public variable type
 method accessor152 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get150} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set151} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable which
 method accessor155 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get153} $this]
               set which $tmp

             } elseif {$op == {write}} {
               return [{c++ set154} $this $which]
             } else { error "Cannot unset C++ variable which" }
           }

public variable button
 method accessor158 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get156} $this]
               set button $tmp

             } elseif {$op == {write}} {
               return [{c++ set157} $this $button]
             } else { error "Cannot unset C++ variable button" }
           }

public variable state
 method accessor161 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get159} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set160} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor164 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get162} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set163} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor167 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get165} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set166} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor152"
set which {}
            trace add variable which {read write unset} "$this accessor155"
set button {}
            trace add variable button {read write unset} "$this accessor158"
set state {}
            trace add variable state {read write unset} "$this accessor161"
set x {}
            trace add variable x {read write unset} "$this accessor164"
set y {}
            trace add variable y {read write unset} "$this accessor167"
}
destructor {
trace remove variable type {read write unset} "$this accessor152"
trace remove variable which {read write unset} "$this accessor155"
trace remove variable button {read write unset} "$this accessor158"
trace remove variable state {read write unset} "$this accessor161"
trace remove variable x {read write unset} "$this accessor164"
trace remove variable y {read write unset} "$this accessor167"
}
}

proc {SDL_GetKeyName} { a0  } {set retpi [uplevel 1 [list {c++ trampoline168} $a0 ]]
set ret $retpi
return $ret
}
proc {SDL_WarpMouse} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline170} $a0 $a1 ]]
return $retpi
}
proc {SDL_GetTicks} {  } {set retpi [uplevel 1 [list {c++ trampoline172} ]]
set ret $retpi
return $ret
}

 proc accessor175 {ignored ignored op} {
             global preliminaryRunMode
             if {$op == {read}} {
               set tmp [{c++ get174} ]
               set preliminaryRunMode $tmp

             } elseif {$op == {write}} {
               error "Cannot write to preliminaryRunMode"
             } else { error "Cannot unset C++ variable preliminaryRunMode" }
           }

 proc accessor177 {ignored ignored op} {
             global THIS_GL_TYPE
             if {$op == {read}} {
               set tmp [{c++ get176} ]
               set THIS_GL_TYPE $tmp

             } elseif {$op == {write}} {
               error "Cannot write to THIS_GL_TYPE"
             } else { error "Cannot unset C++ variable THIS_GL_TYPE" }
           }

 proc accessor180 {ignored ignored op} {
             global recommendedGLType
             if {$op == {read}} {
               set tmp [{c++ get178} ]
               set recommendedGLType $tmp

             } elseif {$op == {write}} {
               return [{c++ set179}  $recommendedGLType]
             } else { error "Cannot unset C++ variable recommendedGLType" }
           }

proc {exitPreliminaryRunMode} {  } {set retpi [uplevel 1 [list {c++ trampoline181} ]]
return $retpi
}

::itcl::class {Font} {
inherit AObject
namespace eval :: {
proc {c++ new Font default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline184} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}


method {charWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline186} $this $a0 ]]
set ret $retpi
return $ret
}
method {width} { a0  } {set retpi [uplevel 1 [list {c++ trampoline188} $this $a0 ]]
set ret $retpi
return $ret
}
method {getHeight} {  } {set retpi [uplevel 1 [list {c++ trampoline190} $this ]]
set ret $retpi
return $ret
}
method {getRise} {  } {set retpi [uplevel 1 [list {c++ trampoline192} $this ]]
set ret $retpi
return $ret
}
method {getDip} {  } {set retpi [uplevel 1 [list {c++ trampoline194} $this ]]
set ret $retpi
return $ret
}
method {preDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline196} $this ]]
return $retpi
}
method {postDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline198} $this ]]
return $retpi
}
method {drawCh} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline200} $this $a0 $a1 $a2 ]]
return $retpi
}
method {drawStr} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline202} $this $a0 $a1 $a2 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {











}
destructor {











}
}

 proc accessor205 {ignored ignored op} {
             global sysfont
             if {$op == {read}} {
               set tmp [{c++ get204} ]
               set sysfont $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfont"
             } else { error "Cannot unset C++ variable sysfont" }
           }

 proc accessor207 {ignored ignored op} {
             global sysfontStipple
             if {$op == {read}} {
               set tmp [{c++ get206} ]
               set sysfontStipple $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfontStipple"
             } else { error "Cannot unset C++ variable sysfontStipple" }
           }

::itcl::class {GameState} {
inherit AObject
namespace eval :: {
proc {c++ new TclGameState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline209} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {configureGL} {  } {set retpi [uplevel 1 [list {c++ deftramp216} $this ]]
return $retpi
}
method {keyboard} { a0  } {set retpi [uplevel 1 [list {c++ deftramp218} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ deftramp220} $this $a0 ]]
return $retpi
}
method {mouseButton} { a0  } {set retpi [uplevel 1 [list {c++ deftramp222} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {InitState} {
inherit GameState
namespace eval :: {
proc {c++ new InitState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline224} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


 proc accessor228 {ignored ignored op} {
             global gameClass
             if {$op == {read}} {
               set tmp [{c++ get226} ]
               set gameClass $tmp

             } elseif {$op == {write}} {
               return [{c++ set227}  $gameClass]
             } else { error "Cannot unset C++ variable gameClass" }
           }

 proc accessor231 {ignored ignored op} {
             global humanShip
             if {$op == {read}} {
               set tmp [{c++ get229} ]
               set humanShip $tmp

             } elseif {$op == {write}} {
               return [{c++ set230}  $humanShip]
             } else { error "Cannot unset C++ variable humanShip" }
           }

 proc accessor234 {ignored ignored op} {
             global testStateMode
             if {$op == {read}} {
               set tmp [{c++ get232} ]
               set testStateMode $tmp

             } elseif {$op == {write}} {
               return [{c++ set233}  $testStateMode]
             } else { error "Cannot unset C++ variable testStateMode" }
           }

 proc accessor237 {ignored ignored op} {
             global testStateSize
             if {$op == {read}} {
               set tmp [{c++ get235} ]
               set testStateSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set236}  $testStateSize]
             } else { error "Cannot unset C++ variable testStateSize" }
           }

::itcl::class {TestState} {
inherit GameState
namespace eval :: {
proc {c++ new TestState default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline239} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline241} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline243} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}



::itcl::class {GameObject} {
inherit AObject
public variable isRemote
 method accessor248 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get247} $this]
               set isRemote $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isRemote"
             } else { error "Cannot unset C++ variable isRemote" }
           }

public variable isExportable
 method accessor251 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get249} $this]
               set isExportable $tmp

             } elseif {$op == {write}} {
               return [{c++ set250} $this $isExportable]
             } else { error "Cannot unset C++ variable isExportable" }
           }

public variable tag
 method accessor254 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get252} $this]
               set tag $tmp

             } elseif {$op == {write}} {
               return [{c++ set253} $this $tag]
             } else { error "Cannot unset C++ variable tag" }
           }

public variable ignoreNetworkTag
 method accessor257 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get255} $this]
               set ignoreNetworkTag $tmp

             } elseif {$op == {write}} {
               return [{c++ set256} $this $ignoreNetworkTag]
             } else { error "Cannot unset C++ variable ignoreNetworkTag" }
           }

protected variable field
 method accessor259 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get258} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable isDead
 method accessor261 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get260} $this]
               set isDead $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isDead"
             } else { error "Cannot unset C++ variable isDead" }
           }

protected variable x
 method accessor264 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get262} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set263} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

protected variable y
 method accessor267 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get265} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set266} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

protected variable vx
 method accessor270 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get268} $this]
               set vx $tmp

             } elseif {$op == {write}} {
               return [{c++ set269} $this $vx]
             } else { error "Cannot unset C++ variable vx" }
           }

protected variable vy
 method accessor273 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get271} $this]
               set vy $tmp

             } elseif {$op == {write}} {
               return [{c++ set272} $this $vy]
             } else { error "Cannot unset C++ variable vy" }
           }

protected variable includeInCollisionDetection
 method accessor276 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get274} $this]
               set includeInCollisionDetection $tmp

             } elseif {$op == {write}} {
               return [{c++ set275} $this $includeInCollisionDetection]
             } else { error "Cannot unset C++ variable includeInCollisionDetection" }
           }

protected variable classification
 method accessor279 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get277} $this]
               set classification $tmp

             } elseif {$op == {write}} {
               return [{c++ set278} $this $classification]
             } else { error "Cannot unset C++ variable classification" }
           }

protected variable decorative
 method accessor282 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get280} $this]
               set decorative $tmp

             } elseif {$op == {write}} {
               return [{c++ set281} $this $decorative]
             } else { error "Cannot unset C++ variable decorative" }
           }

namespace eval :: {
proc {c++ new TclGameObject default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline283} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject position} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline285} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject velocity} { a0 a1 a2 a3 a4 a5 a6  } {set retpi [uplevel 1 [list {c++ trampoline287} $a0 $a1 $a2 $a3 $a4 $a5 $a6 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {getX} {  } {set retpi [uplevel 1 [list {c++ trampoline293} $this ]]
set ret $retpi
return $ret
}
method {getY} {  } {set retpi [uplevel 1 [list {c++ trampoline295} $this ]]
set ret $retpi
return $ret
}
method {getVX} {  } {set retpi [uplevel 1 [list {c++ trampoline297} $this ]]
set ret $retpi
return $ret
}
method {getVY} {  } {set retpi [uplevel 1 [list {c++ trampoline299} $this ]]
set ret $retpi
return $ret
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline301} $this ]]
set ret $retpi
return $ret
}
method {isDecorative} {  } {set retpi [uplevel 1 [list {c++ trampoline303} $this ]]
set ret $retpi
return $ret
}
method {getClassification} {  } {set retpi [uplevel 1 [list {c++ trampoline305} $this ]]
set ret $retpi
return $ret
}
method {okToDecorate} {  } {set retpi [uplevel 1 [list {c++ trampoline307} $this ]]
return $retpi
}
method {teleport} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp310} $this $a0 $a1 $a2 ]]
return $retpi
}
method {getRotation} {  } {set retpi [uplevel 1 [list {c++ deftramp312} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getRadius"]
set ret $retpi
return $ret
}
method {isCollideable} {  } {set retpi [uplevel 1 [list {c++ deftramp316} $this ]]
set ret $retpi
return $ret
}
method {checkCollision} { a0  } {set retpi [uplevel 1 [list {c++ deftramp318} $this $a0 ]]
set ret $retpi
return $ret
}
method {del} {  } {set retpi [uplevel 1 [list {c++ trampoline319} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set isRemote {}
            trace add variable isRemote {read write unset} "$this accessor248"
set isExportable {}
            trace add variable isExportable {read write unset} "$this accessor251"
set tag {}
            trace add variable tag {read write unset} "$this accessor254"
set ignoreNetworkTag {}
            trace add variable ignoreNetworkTag {read write unset} "$this accessor257"
set field {}
            trace add variable field {read write unset} "$this accessor259"
set isDead {}
            trace add variable isDead {read write unset} "$this accessor261"
set x {}
            trace add variable x {read write unset} "$this accessor264"
set y {}
            trace add variable y {read write unset} "$this accessor267"
set vx {}
            trace add variable vx {read write unset} "$this accessor270"
set vy {}
            trace add variable vy {read write unset} "$this accessor273"
set includeInCollisionDetection {}
            trace add variable includeInCollisionDetection {read write unset} "$this accessor276"
set classification {}
            trace add variable classification {read write unset} "$this accessor279"
set decorative {}
            trace add variable decorative {read write unset} "$this accessor282"



















}
destructor {
trace remove variable isRemote {read write unset} "$this accessor248"
trace remove variable isExportable {read write unset} "$this accessor251"
trace remove variable tag {read write unset} "$this accessor254"
trace remove variable ignoreNetworkTag {read write unset} "$this accessor257"
trace remove variable field {read write unset} "$this accessor259"
trace remove variable isDead {read write unset} "$this accessor261"
trace remove variable x {read write unset} "$this accessor264"
trace remove variable y {read write unset} "$this accessor267"
trace remove variable vx {read write unset} "$this accessor270"
trace remove variable vy {read write unset} "$this accessor273"
trace remove variable includeInCollisionDetection {read write unset} "$this accessor276"
trace remove variable classification {read write unset} "$this accessor279"
trace remove variable decorative {read write unset} "$this accessor282"



















}
}


::itcl::class {GameField} {
inherit AObject
public variable fieldClock
 method accessor324 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get323} $this]
               set fieldClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to fieldClock"
             } else { error "Cannot unset C++ variable fieldClock" }
           }

public variable width
 method accessor327 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get325} $this]
               set width $tmp

             } elseif {$op == {write}} {
               return [{c++ set326} $this $width]
             } else { error "Cannot unset C++ variable width" }
           }

public variable height
 method accessor330 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get328} $this]
               set height $tmp

             } elseif {$op == {write}} {
               return [{c++ set329} $this $height]
             } else { error "Cannot unset C++ variable height" }
           }

public variable effects
 method accessor333 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get331} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set332} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable perfectRadar
 method accessor336 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get334} $this]
               set perfectRadar $tmp

             } elseif {$op == {write}} {
               return [{c++ set335} $this $perfectRadar]
             } else { error "Cannot unset C++ variable perfectRadar" }
           }

namespace eval :: {
proc {c++ new GameField default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline337} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline339} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline341} $this ]]
return $retpi
}
method {at} { a0  } {set retpi [uplevel 1 [list {c++ trampoline343} $this $a0 ]]
set ret $retpi
return $ret
}
method {size} {  } {set retpi [uplevel 1 [list {c++ trampoline345} $this ]]
set ret $retpi
return $ret
}
method {add} { a0  } {set retpi [uplevel 1 [list {c++ trampoline347} $this $a0 ]]
return $retpi
}
method {addBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline349} $this $a0 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline351} $this $a0 ]]
return $retpi
}
method {inject} { a0  } {set retpi [uplevel 1 [list {c++ trampoline353} $this $a0 ]]
return $retpi
}
method {clear} {  } {set retpi [uplevel 1 [list {c++ trampoline355} $this ]]
return $retpi
}
method {updateBoundaries} {  } {set retpi [uplevel 1 [list {c++ trampoline357} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set fieldClock {}
            trace add variable fieldClock {read write unset} "$this accessor324"
set width {}
            trace add variable width {read write unset} "$this accessor327"
set height {}
            trace add variable height {read write unset} "$this accessor330"
set effects {}
            trace add variable effects {read write unset} "$this accessor333"
set perfectRadar {}
            trace add variable perfectRadar {read write unset} "$this accessor336"











}
destructor {
trace remove variable fieldClock {read write unset} "$this accessor324"
trace remove variable width {read write unset} "$this accessor327"
trace remove variable height {read write unset} "$this accessor330"
trace remove variable effects {read write unset} "$this accessor333"
trace remove variable perfectRadar {read write unset} "$this accessor336"











}
}

::itcl::class {Blast} {
inherit GameObject
public variable blame
 method accessor361 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get360} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               error "Cannot write to blame"
             } else { error "Cannot unset C++ variable blame" }
           }

namespace eval :: {
proc {c++ new Blast default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline362} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDirect} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline364} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withSize} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline366} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withADC} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline368} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDecor} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline370} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDamage} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12  } {set retpi [uplevel 1 [list {c++ trampoline372} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast nonDamageCopy} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline374} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline376} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline378} $this ]]
return $retpi
}
method {getFalloff} {  } {set retpi [uplevel 1 [list {c++ trampoline380} $this ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline382} $this ]]
set ret $retpi
return $ret
}
method {getStrengthAt} { a0  } {set retpi [uplevel 1 [list {c++ trampoline384} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrengthUpon} { a0  } {set retpi [uplevel 1 [list {c++ trampoline386} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline388} $this ]]
set ret $retpi
return $ret
}
method {isDirect} {  } {set retpi [uplevel 1 [list {c++ trampoline390} $this ]]
set ret $retpi
return $ret
}
method {causesDamage} {  } {set retpi [uplevel 1 [list {c++ trampoline392} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set blame {}
            trace add variable blame {read write unset} "$this accessor361"
















}
destructor {
trace remove variable blame {read write unset} "$this accessor361"
















}
}

::itcl::class {CellFragment} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline395} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline397} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline399} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {PlasmaFire} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline402} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline404} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline406} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {Explosion} {
inherit GameObject
public variable hungry
 method accessor411 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get409} $this]
               set hungry $tmp

             } elseif {$op == {write}} {
               return [{c++ set410} $this $hungry]
             } else { error "Cannot unset C++ variable hungry" }
           }

namespace eval :: {
proc {c++ new Explosion stationary} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline412} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion velocity} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13  } {set retpi [uplevel 1 [list {c++ trampoline414} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion smeared} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15  } {set retpi [uplevel 1 [list {c++ trampoline416} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 $a15 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion by} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline418} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

method {multiExplosion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline420} $this $a0 ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline422} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline424} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline426} $this ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline428} $this ]]
set ret $retpi
return $ret
}
method {getDensity} {  } {set retpi [uplevel 1 [list {c++ trampoline430} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set hungry {}
            trace add variable hungry {read write unset} "$this accessor411"










}
destructor {
trace remove variable hungry {read write unset} "$this accessor411"










}
}


::itcl::class {OldStyleExplosion} {
inherit GameObject
namespace eval :: {
proc {c++ new OldStyleExplosion default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline433} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline435} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline437} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline439} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {LightTrail} {
inherit GameObject
namespace eval :: {
proc {c++ new LightTrail default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14  } {set retpi [uplevel 1 [list {c++ trampoline442} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline444} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline446} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline448} $this ]]
set ret $retpi
return $ret
}
method {setWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline450} $this $a0 ]]
return $retpi
}
method {emit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline452} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}







itcl::class fun<void:Ship*,bool>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<void:Ship*,bool>::fun_t {} {}
      } {}
    }
::itcl::class {fun<void:Ship*,bool>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<void:Ship*,bool> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline460} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
return $retpi
}
proc {call} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline464} $a0 $a1 $a2 ]]
return $retpi
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline466} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

::itcl::class {radar_t} {
inherit AObject
namespace eval :: {
proc {c++ new radar_t default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline469} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Ship} {
inherit GameObject
public variable controller
 method accessor474 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get472} $this]
               set controller $tmp

             } elseif {$op == {write}} {
               return [{c++ set473} $this $controller]
             } else { error "Cannot unset C++ variable controller" }
           }

public variable effects
 method accessor477 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get475} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set476} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable shipExistenceFailure
 method accessor480 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get478} $this]
               set shipExistenceFailure $tmp

             } elseif {$op == {write}} {
               return [{c++ set479} $this $shipExistenceFailure]
             } else { error "Cannot unset C++ variable shipExistenceFailure" }
           }


proc {cellCoord} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline481} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {cellSubCoord} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline483} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}
public variable insignia
 method accessor487 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get485} $this]
               set insignia $tmp

             } elseif {$op == {write}} {
               return [{c++ set486} $this $insignia]
             } else { error "Cannot unset C++ variable insignia" }
           }

public variable blame
 method accessor490 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get488} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               return [{c++ set489} $this $blame]
             } else { error "Cannot unset C++ variable blame" }
           }

public variable score
 method accessor493 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get491} $this]
               set score $tmp

             } elseif {$op == {write}} {
               return [{c++ set492} $this $score]
             } else { error "Cannot unset C++ variable score" }
           }

public variable damageMultiplier
 method accessor496 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get494} $this]
               set damageMultiplier $tmp

             } elseif {$op == {write}} {
               return [{c++ set495} $this $damageMultiplier]
             } else { error "Cannot unset C++ variable damageMultiplier" }
           }

public variable diedSpontaneously
 method accessor498 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get497} $this]
               set diedSpontaneously $tmp

             } elseif {$op == {write}} {
               error "Cannot write to diedSpontaneously"
             } else { error "Cannot unset C++ variable diedSpontaneously" }
           }

public variable typeName
 method accessor500 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get499} $this]
               set typeName $tmp

             } elseif {$op == {write}} {
               error "Cannot write to typeName"
             } else { error "Cannot unset C++ variable typeName" }
           }

namespace eval :: {
proc {c++ new Ship default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline501} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}


method {refreshUpdates} {  } {set retpi [uplevel 1 [list {c++ trampoline503} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline505} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline507} $this ]]
return $retpi
}

method {getVRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline509} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline511} $this ]]
set ret $retpi
return $ret
}
method {glSetColour0} {  } {set retpi [uplevel 1 [list {c++ trampoline513} $this ]]
return $retpi
}
method {glSetColour1} { a0  } {set retpi [uplevel 1 [list {c++ trampoline515} $this $a0 ]]
return $retpi
}
method {glSetColour2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline517} $this $a0 $a1 ]]
return $retpi
}
method {setThrust} { a0  } {set retpi [uplevel 1 [list {c++ trampoline519} $this $a0 ]]
return $retpi
}
method {getThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline521} $this ]]
set ret $retpi
return $ret
}
method {getTrueThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline523} $this ]]
set ret $retpi
return $ret
}
method {setThrustOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline525} $this $a0 ]]
return $retpi
}
method {isThrustOn} {  } {set retpi [uplevel 1 [list {c++ trampoline527} $this ]]
set ret $retpi
return $ret
}
method {setBrakeOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline529} $this $a0 ]]
return $retpi
}
method {isBrakeOn} {  } {set retpi [uplevel 1 [list {c++ trampoline531} $this ]]
set ret $retpi
return $ret
}
method {configureEngines} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline533} $this $a0 $a1 $a2 ]]
return $retpi
}
method {configureEngines2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline535} $this $a0 $a1 ]]
return $retpi
}
method {getAcceleration} {  } {set retpi [uplevel 1 [list {c++ trampoline537} $this ]]
set ret $retpi
return $ret
}
method {getRotationRate} {  } {set retpi [uplevel 1 [list {c++ trampoline539} $this ]]
set ret $retpi
return $ret
}
method {getRotationAccel} {  } {set retpi [uplevel 1 [list {c++ trampoline541} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline543} $this ]]
set ret $retpi
return $ret
}
method {getPowerUsagePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline545} $this ]]
set ret $retpi
return $ret
}
method {getPowerSupply} {  } {set retpi [uplevel 1 [list {c++ trampoline547} $this ]]
set ret $retpi
return $ret
}
method {getPowerDrain} {  } {set retpi [uplevel 1 [list {c++ trampoline549} $this ]]
set ret $retpi
return $ret
}
method {getCurrentCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline551} $this ]]
set ret $retpi
return $ret
}
method {getMaximumCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline553} $this ]]
set ret $retpi
return $ret
}
method {getCapacitancePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline555} $this ]]
set ret $retpi
return $ret
}
method {setColour} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline557} $this $a0 $a1 $a2 ]]
return $retpi
}
method {destroyGraphicsInfo} {  } {set retpi [uplevel 1 [list {c++ trampoline559} $this ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline561} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline563} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline565} $this ]]
set ret $retpi
return $ret
}
method {drawPower} { a0  } {set retpi [uplevel 1 [list {c++ trampoline567} $this $a0 ]]
set ret $retpi
return $ret
}
method {getReinforcement} {  } {set retpi [uplevel 1 [list {c++ trampoline569} $this ]]
set ret $retpi
return $ret
}
method {setReinforcement} { a0  } {set retpi [uplevel 1 [list {c++ trampoline571} $this $a0 ]]
return $retpi
}
method {enableSoundEffects} {  } {set retpi [uplevel 1 [list {c++ trampoline573} $this ]]
return $retpi
}

method {hasPower} {  } {set retpi [uplevel 1 [list {c++ trampoline575} $this ]]
set ret $retpi
return $ret
}
method {spontaneouslyDie} {  } {set retpi [uplevel 1 [list {c++ trampoline577} $this ]]
return $retpi
}
method {getCoolingMult} {  } {set retpi [uplevel 1 [list {c++ trampoline579} $this ]]
set ret $retpi
return $ret
}
method {getCellVelocity} { a0  } {set retpi [uplevel 1 [list {c++ trampoline581} $this $a0 ]]
set ret $retpi
return $ret
}

method {spin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline583} $this $a0 ]]
return $retpi
}
method {startTest} {  } {set retpi [uplevel 1 [list {c++ trampoline585} $this ]]
return $retpi
}
method {endTest} {  } {set retpi [uplevel 1 [list {c++ trampoline587} $this ]]
set ret $retpi
return $ret
}

method {applyCollision} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline589} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {cellCount} {  } {set retpi [uplevel 1 [list {c++ trampoline591} $this ]]
set ret $retpi
return $ret
}
method {getRadar} {  } {set retpi [uplevel 1 [list {c++ trampoline593} $this ]]
set ret $retpi
return $ret
}
method {setRadar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline595} $this $a0 ]]
return $retpi
}
method {getDeathAttributions} {  } {set retpi [uplevel 1 [list {c++ trampoline597} $this ]]
set ret $retpi
return $ret
}
method {categorise} {  } {set retpi [uplevel 1 [list {c++ trampoline599} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set controller {}
            trace add variable controller {read write unset} "$this accessor474"
set effects {}
            trace add variable effects {read write unset} "$this accessor477"
set shipExistenceFailure {}
            trace add variable shipExistenceFailure {read write unset} "$this accessor480"



set insignia {}
            trace add variable insignia {read write unset} "$this accessor487"
set blame {}
            trace add variable blame {read write unset} "$this accessor490"
set score {}
            trace add variable score {read write unset} "$this accessor493"
set damageMultiplier {}
            trace add variable damageMultiplier {read write unset} "$this accessor496"
set diedSpontaneously {}
            trace add variable diedSpontaneously {read write unset} "$this accessor498"
set typeName {}
            trace add variable typeName {read write unset} "$this accessor500"























































}
destructor {
trace remove variable controller {read write unset} "$this accessor474"
trace remove variable effects {read write unset} "$this accessor477"
trace remove variable shipExistenceFailure {read write unset} "$this accessor480"



trace remove variable insignia {read write unset} "$this accessor487"
trace remove variable blame {read write unset} "$this accessor490"
trace remove variable score {read write unset} "$this accessor493"
trace remove variable damageMultiplier {read write unset} "$this accessor496"
trace remove variable diedSpontaneously {read write unset} "$this accessor498"
trace remove variable typeName {read write unset} "$this accessor500"























































}
}

proc {verify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline601} $a0 ]]
set ret $retpi
return $ret
}
proc {loadShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline603} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {saveShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline605} $a0 $a1 ]]
return $retpi
}

::itcl::class {Shield} {
inherit AObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline608} $this $a0 ]]
return $retpi
}
method {updateDist} {  } {set retpi [uplevel 1 [list {c++ trampoline610} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline612} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline614} $this ]]
set ret $retpi
return $ret
}
method {collideWith} { a0  } {set retpi [uplevel 1 [list {c++ trampoline616} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline618} $this ]]
set ret $retpi
return $ret
}
method {getStability} {  } {set retpi [uplevel 1 [list {c++ trampoline620} $this ]]
set ret $retpi
return $ret
}
method {getShip} {  } {set retpi [uplevel 1 [list {c++ trampoline622} $this ]]
set ret $retpi
return $ret
}
method {drawForHUD} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline624} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {









}
destructor {









}
}


proc {insignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline626} $a0 ]]
set ret $retpi
return $ret
}
proc {clear_insignias} {  } {set retpi [uplevel 1 [list {c++ trampoline628} ]]
return $retpi
}

proc {getAlliance} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline630} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {setAlliance} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline632} $a0 $a1 $a2 ]]
return $retpi
}

::itcl::class {EnergyCharge} {
inherit GameObject
namespace eval :: {
proc {c++ new EnergyCharge default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline635} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp638} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline639} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline641} $this ]]
set ret $retpi
return $ret
}
method {getIntensity} {  } {set retpi [uplevel 1 [list {c++ trampoline643} $this ]]
set ret $retpi
return $ret
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline645} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {MagnetoBomb} {
inherit GameObject
namespace eval :: {
proc {c++ new MagnetoBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline648} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp651} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline652} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline654} $this ]]
set ret $retpi
return $ret
}
method {getPower} {  } {set retpi [uplevel 1 [list {c++ trampoline656} $this ]]
set ret $retpi
return $ret
}
method {simulateFailure} {  } {set retpi [uplevel 1 [list {c++ trampoline658} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {SemiguidedBomb} {
inherit MagnetoBomb
namespace eval :: {
proc {c++ new SemiguidedBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline661} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      MagnetoBomb::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {PlasmaBurst} {
inherit GameObject
namespace eval :: {
proc {c++ new PlasmaBurst default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline664} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp667} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline668} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline670} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline672} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {





}
destructor {





}
}

::itcl::class {MonophasicEnergyPulse} {
inherit GameObject
namespace eval :: {
proc {c++ new MonophasicEnergyPulse default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline675} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Missile} {
inherit GameObject
namespace eval :: {
proc {c++ new Missile default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline678} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {EffectsHandler} {
inherit AObject
namespace eval :: {
proc {c++ new EffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline681} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclEffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline683} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {impact} { a0  } {set retpi [uplevel 1 [list {c++ deftramp686} $this $a0 ]]
return $retpi
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ deftramp688} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

 proc accessor690 {ignored ignored op} {
             global nullEffectsHandler
             if {$op == {read}} {
               set tmp [{c++ get689} ]
               set nullEffectsHandler $tmp

             } elseif {$op == {write}} {
               error "Cannot write to nullEffectsHandler"
             } else { error "Cannot unset C++ variable nullEffectsHandler" }
           }

::itcl::class {Background} {
inherit EffectsHandler
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline692} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline694} $this $a0 ]]
return $retpi
}
method {updateReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline696} $this $a0 $a1 ]]
return $retpi
}
method {repopulate} {  } {set retpi [uplevel 1 [list {c++ trampoline698} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {Planet} {
inherit Background
namespace eval :: {
proc {c++ new Planet default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline701} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {StarField} {
inherit Background
namespace eval :: {
proc {c++ new StarField default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline704} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

proc {initStarLists} {  } {set retpi [uplevel 1 [list {c++ trampoline706} ]]
return $retpi
}

::itcl::class {Nebula} {
inherit Background
namespace eval :: {
proc {c++ new Nebula default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline709} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {setFlowEquation} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline711} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {setPressureEquation} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline713} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
method {setPressureResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline715} $this $a0 ]]
return $retpi
}
method {getPressureResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline717} $this ]]
set ret $retpi
return $ret
}
method {setVelocityResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline719} $this $a0 ]]
return $retpi
}
method {getVelocityResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline721} $this ]]
set ret $retpi
return $ret
}
method {setForceMultiplier} { a0  } {set retpi [uplevel 1 [list {c++ trampoline723} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {








}
destructor {








}
}


::itcl::class {Camera} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new TclCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline726} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

protected variable reference
 method accessor730 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get728} $this]
               set reference $tmp

             } elseif {$op == {write}} {
               return [{c++ set729} $this $reference]
             } else { error "Cannot unset C++ variable reference" }
           }

protected method {doSetup} {  } {set retpi [uplevel 1 error "Call to pure-virtual function doSetup"]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp734} $this $a0 ]]
return $retpi
}
method {drawOverlays} {  } {set retpi [uplevel 1 [list {c++ deftramp736} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ deftramp738} $this ]]
return $retpi
}
method {setup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline739} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set reference {}
            trace add variable reference {read write unset} "$this accessor730"





}
destructor {

trace remove variable reference {read write unset} "$this accessor730"





}
}


::itcl::class {DynamicCamera} {
inherit Camera
namespace eval :: {
proc {c++ new DynamicCamera default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline742} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline744} $this $a0 ]]
return $retpi
}
protected method {doSetup} {  } {set retpi [uplevel 1 [list {c++ trampoline746} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ trampoline748} $this ]]
return $retpi
}
method {getZoom} {  } {set retpi [uplevel 1 [list {c++ trampoline750} $this ]]
set ret $retpi
return $ret
}
method {setZoom} { a0  } {set retpi [uplevel 1 [list {c++ trampoline752} $this $a0 ]]
return $retpi
}
method {getRotateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline754} $this ]]
set ret $retpi
return $ret
}
method {setRotateMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline756} $this $a0 ]]
return $retpi
}
method {getLookAhead} {  } {set retpi [uplevel 1 [list {c++ trampoline758} $this ]]
set ret $retpi
return $ret
}
method {setLookAhead} { a0  } {set retpi [uplevel 1 [list {c++ trampoline760} $this $a0 ]]
return $retpi
}
method {getVisualRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline762} $this ]]
set ret $retpi
return $ret
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline764} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {












}
destructor {












}
}


::itcl::class {FixedCamera} {
inherit Camera
namespace eval :: {
proc {c++ new FixedCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline767} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {Controller} {
inherit AObject
public variable ship
 method accessor771 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get770} $this]
               set ship $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ship"
             } else { error "Cannot unset C++ variable ship" }
           }

namespace eval :: {
proc {c++ new TclController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline772} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
return $retpi
}
method {damage} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp777} $this $a0 $a1 $a2 ]]
return $retpi
}
method {otherShipDied} { a0  } {set retpi [uplevel 1 [list {c++ deftramp779} $this $a0 ]]
return $retpi
}
method {notifyScore} { a0  } {set retpi [uplevel 1 [list {c++ deftramp781} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set ship {}
            trace add variable ship {read write unset} "$this accessor771"





}
destructor {
trace remove variable ship {read write unset} "$this accessor771"





}
}


::itcl::class {HumanController} {
inherit Controller
namespace eval :: {
proc {c++ new HumanController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline783} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline785} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline787} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline789} $this $a0 ]]
return $retpi
}
method {button} { a0  } {set retpi [uplevel 1 [list {c++ trampoline791} $this $a0 ]]
return $retpi
}
method {key} { a0  } {set retpi [uplevel 1 [list {c++ trampoline793} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

 proc accessor796 {ignored ignored op} {
             global isCompositionBufferInUse
             if {$op == {read}} {
               set tmp [{c++ get795} ]
               set isCompositionBufferInUse $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isCompositionBufferInUse"
             } else { error "Cannot unset C++ variable isCompositionBufferInUse" }
           }

 proc accessor799 {ignored ignored op} {
             global compositionBufferPrefix
             if {$op == {read}} {
               set tmp [{c++ get797} ]
               set compositionBufferPrefix $tmp

             } elseif {$op == {write}} {
               return [{c++ set798}  $compositionBufferPrefix]
             } else { error "Cannot unset C++ variable compositionBufferPrefix" }
           }


proc {hc_conf_configure} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline800} $a0 $a1 ]]
return $retpi
}
proc {hc_conf_clear} {  } {set retpi [uplevel 1 [list {c++ trampoline802} ]]
return $retpi
}

::itcl::class {AIControl} {
inherit Controller
namespace eval :: {
proc {c++ new AIControl default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline805} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline807} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {GeneticAI} {
inherit Controller
namespace eval :: {
proc {c++ new GeneticAI default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline810} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline812} $this $a0 ]]
return $retpi
}
public variable species
 method accessor815 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get814} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor817 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get816} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

public variable instance
 method accessor819 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get818} $this]
               set instance $tmp

             } elseif {$op == {write}} {
               error "Cannot write to instance"
             } else { error "Cannot unset C++ variable instance" }
           }

public variable failed
 method accessor821 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get820} $this]
               set failed $tmp

             } elseif {$op == {write}} {
               error "Cannot write to failed"
             } else { error "Cannot unset C++ variable failed" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


set species {}
            trace add variable species {read write unset} "$this accessor815"
set generation {}
            trace add variable generation {read write unset} "$this accessor817"
set instance {}
            trace add variable instance {read write unset} "$this accessor819"
set failed {}
            trace add variable failed {read write unset} "$this accessor821"
}
destructor {


trace remove variable species {read write unset} "$this accessor815"
trace remove variable generation {read write unset} "$this accessor817"
trace remove variable instance {read write unset} "$this accessor819"
trace remove variable failed {read write unset} "$this accessor821"
}
}

proc {calculateGeneticAIFunctionCosts} {  } {set retpi [uplevel 1 [list {c++ trampoline822} ]]
return $retpi
}
::itcl::class {GenAI} {
inherit Controller
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline825} $this $a0 ]]
return $retpi
}
public variable species
 method accessor828 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get827} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor830 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get829} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

method {getScores} {  } {set retpi [uplevel 1 [list {c++ trampoline831} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set species {}
            trace add variable species {read write unset} "$this accessor828"
set generation {}
            trace add variable generation {read write unset} "$this accessor830"

}
destructor {

trace remove variable species {read write unset} "$this accessor828"
trace remove variable generation {read write unset} "$this accessor830"

}
}

proc {GenAI_make} { a0  } {set retpi [uplevel 1 [list {c++ trampoline833} $a0 ]]
set ret $retpi
return $ret
}

::itcl::class {CommonKeyboardClient} {
inherit AObject
namespace eval :: {
proc {c++ new CommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline836} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclCommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline838} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {exit} {  } {set retpi [uplevel 1 [list {c++ deftramp841} $this ]]
return $retpi
}
method {slow} {  } {set retpi [uplevel 1 [list {c++ deftramp843} $this ]]
return $retpi
}
method {fast} {  } {set retpi [uplevel 1 [list {c++ deftramp845} $this ]]
return $retpi
}
method {halt} {  } {set retpi [uplevel 1 [list {c++ deftramp847} $this ]]
return $retpi
}
method {frameXframe} {  } {set retpi [uplevel 1 [list {c++ deftramp849} $this ]]
return $retpi
}
method {statsOn} {  } {set retpi [uplevel 1 [list {c++ deftramp851} $this ]]
return $retpi
}
method {statsOff} {  } {set retpi [uplevel 1 [list {c++ deftramp853} $this ]]
return $retpi
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline854} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {










}
destructor {










}
}


::itcl::class {ForwardingEffectsHandler} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new ForwardingEffectsHandler default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline857} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Spectator} {
inherit GameObject
namespace eval :: {
proc {c++ new Spectator default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline860} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator explicit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline862} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator empty} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline864} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {nextReference} {  } {set retpi [uplevel 1 [list {c++ trampoline866} $this ]]
return $retpi
}
method {requireInsignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline868} $this $a0 ]]
return $retpi
}
method {kill} {  } {set retpi [uplevel 1 [list {c++ trampoline870} $this ]]
return $retpi
}
method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline872} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {GameEnv} {
inherit AObject
namespace eval :: {
proc {c++ new GameEnv customCamera} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline875} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new GameEnv default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline877} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline879} $this ]]
set ret $retpi
return $ret
}
method {setReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline881} $this $a0 $a1 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline883} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline885} $this ]]
return $retpi
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline887} $this ]]
set ret $retpi
return $ret
}
public variable cam
 method accessor891 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get889} $this]
               set cam $tmp

             } elseif {$op == {write}} {
               return [{c++ set890} $this $cam]
             } else { error "Cannot unset C++ variable cam" }
           }

public variable stars
 method accessor894 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get892} $this]
               set stars $tmp

             } elseif {$op == {write}} {
               return [{c++ set893} $this $stars]
             } else { error "Cannot unset C++ variable stars" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







set cam {}
            trace add variable cam {read write unset} "$this accessor891"
set stars {}
            trace add variable stars {read write unset} "$this accessor894"
}
destructor {







trace remove variable cam {read write unset} "$this accessor891"
trace remove variable stars {read write unset} "$this accessor894"
}
}


::itcl::class {Manipulator} {
inherit AObject
namespace eval :: {
proc {c++ new Manipulator default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline896} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} {  } {set retpi [uplevel 1 [list {c++ trampoline898} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline900} $this ]]
return $retpi
}
method {primaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline902} $this $a0 $a1 ]]
return $retpi
}
method {primaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline904} $this $a0 $a1 ]]
return $retpi
}
method {secondaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline906} $this $a0 $a1 ]]
return $retpi
}
method {secondaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline908} $this $a0 $a1 ]]
return $retpi
}
method {scrollUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline910} $this $a0 $a1 ]]
return $retpi
}
method {scrollDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline912} $this $a0 $a1 ]]
return $retpi
}
method {motion} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline914} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
method {resetView} {  } {set retpi [uplevel 1 [list {c++ trampoline916} $this ]]
return $retpi
}
method {pushUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline918} $this ]]
return $retpi
}
method {popUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline920} $this ]]
return $retpi
}
method {commitUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline922} $this ]]
return $retpi
}
method {deactivateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline924} $this ]]
return $retpi
}
method {activateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline926} $this ]]
return $retpi
}
method {addToHistory} {  } {set retpi [uplevel 1 [list {c++ trampoline928} $this ]]
return $retpi
}
method {revertToHistory} { a0  } {set retpi [uplevel 1 [list {c++ trampoline930} $this $a0 ]]
return $retpi
}
method {reloadShip} {  } {set retpi [uplevel 1 [list {c++ trampoline932} $this ]]
set ret $retpi
return $ret
}
method {deleteShip} {  } {set retpi [uplevel 1 [list {c++ trampoline934} $this ]]
return $retpi
}
method {copyMounts} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline936} $this $a0 $a1 ]]
return $retpi
}
method {getCellAt} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline938} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






















}
destructor {






















}
}


 proc accessor941 {ignored ignored op} {
             global planetgen_width
             if {$op == {read}} {
               set tmp [{c++ get940} ]
               set planetgen_width $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_width"
             } else { error "Cannot unset C++ variable planetgen_width" }
           }

 proc accessor943 {ignored ignored op} {
             global planetgen_height
             if {$op == {read}} {
               set tmp [{c++ get942} ]
               set planetgen_height $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_height"
             } else { error "Cannot unset C++ variable planetgen_height" }
           }

::itcl::class {PlanetGeneratorParms} {
inherit AObject
namespace eval :: {
proc {c++ new PlanetGeneratorParms default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline945} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable seed
 method accessor949 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get947} $this]
               set seed $tmp

             } elseif {$op == {write}} {
               return [{c++ set948} $this $seed]
             } else { error "Cannot unset C++ variable seed" }
           }

public variable continents
 method accessor952 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get950} $this]
               set continents $tmp

             } elseif {$op == {write}} {
               return [{c++ set951} $this $continents]
             } else { error "Cannot unset C++ variable continents" }
           }

public variable largeIslands
 method accessor955 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get953} $this]
               set largeIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set954} $this $largeIslands]
             } else { error "Cannot unset C++ variable largeIslands" }
           }

public variable smallIslands
 method accessor958 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get956} $this]
               set smallIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set957} $this $smallIslands]
             } else { error "Cannot unset C++ variable smallIslands" }
           }

public variable islandGrouping
 method accessor961 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get959} $this]
               set islandGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set960} $this $islandGrouping]
             } else { error "Cannot unset C++ variable islandGrouping" }
           }

public variable landSlope
 method accessor964 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get962} $this]
               set landSlope $tmp

             } elseif {$op == {write}} {
               return [{c++ set963} $this $landSlope]
             } else { error "Cannot unset C++ variable landSlope" }
           }

public variable oceans
 method accessor967 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get965} $this]
               set oceans $tmp

             } elseif {$op == {write}} {
               return [{c++ set966} $this $oceans]
             } else { error "Cannot unset C++ variable oceans" }
           }

public variable seas
 method accessor970 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get968} $this]
               set seas $tmp

             } elseif {$op == {write}} {
               return [{c++ set969} $this $seas]
             } else { error "Cannot unset C++ variable seas" }
           }

public variable lakes
 method accessor973 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get971} $this]
               set lakes $tmp

             } elseif {$op == {write}} {
               return [{c++ set972} $this $lakes]
             } else { error "Cannot unset C++ variable lakes" }
           }

public variable rivers
 method accessor976 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get974} $this]
               set rivers $tmp

             } elseif {$op == {write}} {
               return [{c++ set975} $this $rivers]
             } else { error "Cannot unset C++ variable rivers" }
           }

public variable mountainRanges
 method accessor979 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get977} $this]
               set mountainRanges $tmp

             } elseif {$op == {write}} {
               return [{c++ set978} $this $mountainRanges]
             } else { error "Cannot unset C++ variable mountainRanges" }
           }

public variable mountainSteepness
 method accessor982 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get980} $this]
               set mountainSteepness $tmp

             } elseif {$op == {write}} {
               return [{c++ set981} $this $mountainSteepness]
             } else { error "Cannot unset C++ variable mountainSteepness" }
           }

public variable enormousMountains
 method accessor985 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get983} $this]
               set enormousMountains $tmp

             } elseif {$op == {write}} {
               return [{c++ set984} $this $enormousMountains]
             } else { error "Cannot unset C++ variable enormousMountains" }
           }

public variable craters
 method accessor988 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get986} $this]
               set craters $tmp

             } elseif {$op == {write}} {
               return [{c++ set987} $this $craters]
             } else { error "Cannot unset C++ variable craters" }
           }

public variable maxCraterSize
 method accessor991 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get989} $this]
               set maxCraterSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set990} $this $maxCraterSize]
             } else { error "Cannot unset C++ variable maxCraterSize" }
           }

public variable equatorTemperature
 method accessor994 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get992} $this]
               set equatorTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set993} $this $equatorTemperature]
             } else { error "Cannot unset C++ variable equatorTemperature" }
           }

public variable solarEquator
 method accessor997 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get995} $this]
               set solarEquator $tmp

             } elseif {$op == {write}} {
               return [{c++ set996} $this $solarEquator]
             } else { error "Cannot unset C++ variable solarEquator" }
           }

public variable polarTemperature
 method accessor1000 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get998} $this]
               set polarTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set999} $this $polarTemperature]
             } else { error "Cannot unset C++ variable polarTemperature" }
           }

public variable altitudeTemperatureDelta
 method accessor1003 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1001} $this]
               set altitudeTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set1002} $this $altitudeTemperatureDelta]
             } else { error "Cannot unset C++ variable altitudeTemperatureDelta" }
           }

public variable waterTemperatureDelta
 method accessor1006 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1004} $this]
               set waterTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set1005} $this $waterTemperatureDelta]
             } else { error "Cannot unset C++ variable waterTemperatureDelta" }
           }

public variable freezingPoint
 method accessor1009 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1007} $this]
               set freezingPoint $tmp

             } elseif {$op == {write}} {
               return [{c++ set1008} $this $freezingPoint]
             } else { error "Cannot unset C++ variable freezingPoint" }
           }

public variable humidity
 method accessor1012 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1010} $this]
               set humidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set1011} $this $humidity]
             } else { error "Cannot unset C++ variable humidity" }
           }

public variable vapourTransport
 method accessor1015 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1013} $this]
               set vapourTransport $tmp

             } elseif {$op == {write}} {
               return [{c++ set1014} $this $vapourTransport]
             } else { error "Cannot unset C++ variable vapourTransport" }
           }

public variable mountainBlockage
 method accessor1018 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1016} $this]
               set mountainBlockage $tmp

             } elseif {$op == {write}} {
               return [{c++ set1017} $this $mountainBlockage]
             } else { error "Cannot unset C++ variable mountainBlockage" }
           }

public variable vegitationHumidity
 method accessor1021 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1019} $this]
               set vegitationHumidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set1020} $this $vegitationHumidity]
             } else { error "Cannot unset C++ variable vegitationHumidity" }
           }

public variable cities
 method accessor1024 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1022} $this]
               set cities $tmp

             } elseif {$op == {write}} {
               return [{c++ set1023} $this $cities]
             } else { error "Cannot unset C++ variable cities" }
           }

public variable maxCitySize
 method accessor1027 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1025} $this]
               set maxCitySize $tmp

             } elseif {$op == {write}} {
               return [{c++ set1026} $this $maxCitySize]
             } else { error "Cannot unset C++ variable maxCitySize" }
           }

public variable cityGrouping
 method accessor1030 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1028} $this]
               set cityGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set1029} $this $cityGrouping]
             } else { error "Cannot unset C++ variable cityGrouping" }
           }

public variable waterColour
 method accessor1033 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1031} $this]
               set waterColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1032} $this $waterColour]
             } else { error "Cannot unset C++ variable waterColour" }
           }

public variable vegitationColour
 method accessor1036 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1034} $this]
               set vegitationColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1035} $this $vegitationColour]
             } else { error "Cannot unset C++ variable vegitationColour" }
           }

public variable lowerPlanetColour
 method accessor1039 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1037} $this]
               set lowerPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1038} $this $lowerPlanetColour]
             } else { error "Cannot unset C++ variable lowerPlanetColour" }
           }

public variable upperPlanetColour
 method accessor1042 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1040} $this]
               set upperPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set1041} $this $upperPlanetColour]
             } else { error "Cannot unset C++ variable upperPlanetColour" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set seed {}
            trace add variable seed {read write unset} "$this accessor949"
set continents {}
            trace add variable continents {read write unset} "$this accessor952"
set largeIslands {}
            trace add variable largeIslands {read write unset} "$this accessor955"
set smallIslands {}
            trace add variable smallIslands {read write unset} "$this accessor958"
set islandGrouping {}
            trace add variable islandGrouping {read write unset} "$this accessor961"
set landSlope {}
            trace add variable landSlope {read write unset} "$this accessor964"
set oceans {}
            trace add variable oceans {read write unset} "$this accessor967"
set seas {}
            trace add variable seas {read write unset} "$this accessor970"
set lakes {}
            trace add variable lakes {read write unset} "$this accessor973"
set rivers {}
            trace add variable rivers {read write unset} "$this accessor976"
set mountainRanges {}
            trace add variable mountainRanges {read write unset} "$this accessor979"
set mountainSteepness {}
            trace add variable mountainSteepness {read write unset} "$this accessor982"
set enormousMountains {}
            trace add variable enormousMountains {read write unset} "$this accessor985"
set craters {}
            trace add variable craters {read write unset} "$this accessor988"
set maxCraterSize {}
            trace add variable maxCraterSize {read write unset} "$this accessor991"
set equatorTemperature {}
            trace add variable equatorTemperature {read write unset} "$this accessor994"
set solarEquator {}
            trace add variable solarEquator {read write unset} "$this accessor997"
set polarTemperature {}
            trace add variable polarTemperature {read write unset} "$this accessor1000"
set altitudeTemperatureDelta {}
            trace add variable altitudeTemperatureDelta {read write unset} "$this accessor1003"
set waterTemperatureDelta {}
            trace add variable waterTemperatureDelta {read write unset} "$this accessor1006"
set freezingPoint {}
            trace add variable freezingPoint {read write unset} "$this accessor1009"
set humidity {}
            trace add variable humidity {read write unset} "$this accessor1012"
set vapourTransport {}
            trace add variable vapourTransport {read write unset} "$this accessor1015"
set mountainBlockage {}
            trace add variable mountainBlockage {read write unset} "$this accessor1018"
set vegitationHumidity {}
            trace add variable vegitationHumidity {read write unset} "$this accessor1021"
set cities {}
            trace add variable cities {read write unset} "$this accessor1024"
set maxCitySize {}
            trace add variable maxCitySize {read write unset} "$this accessor1027"
set cityGrouping {}
            trace add variable cityGrouping {read write unset} "$this accessor1030"
set waterColour {}
            trace add variable waterColour {read write unset} "$this accessor1033"
set vegitationColour {}
            trace add variable vegitationColour {read write unset} "$this accessor1036"
set lowerPlanetColour {}
            trace add variable lowerPlanetColour {read write unset} "$this accessor1039"
set upperPlanetColour {}
            trace add variable upperPlanetColour {read write unset} "$this accessor1042"
}
destructor {

trace remove variable seed {read write unset} "$this accessor949"
trace remove variable continents {read write unset} "$this accessor952"
trace remove variable largeIslands {read write unset} "$this accessor955"
trace remove variable smallIslands {read write unset} "$this accessor958"
trace remove variable islandGrouping {read write unset} "$this accessor961"
trace remove variable landSlope {read write unset} "$this accessor964"
trace remove variable oceans {read write unset} "$this accessor967"
trace remove variable seas {read write unset} "$this accessor970"
trace remove variable lakes {read write unset} "$this accessor973"
trace remove variable rivers {read write unset} "$this accessor976"
trace remove variable mountainRanges {read write unset} "$this accessor979"
trace remove variable mountainSteepness {read write unset} "$this accessor982"
trace remove variable enormousMountains {read write unset} "$this accessor985"
trace remove variable craters {read write unset} "$this accessor988"
trace remove variable maxCraterSize {read write unset} "$this accessor991"
trace remove variable equatorTemperature {read write unset} "$this accessor994"
trace remove variable solarEquator {read write unset} "$this accessor997"
trace remove variable polarTemperature {read write unset} "$this accessor1000"
trace remove variable altitudeTemperatureDelta {read write unset} "$this accessor1003"
trace remove variable waterTemperatureDelta {read write unset} "$this accessor1006"
trace remove variable freezingPoint {read write unset} "$this accessor1009"
trace remove variable humidity {read write unset} "$this accessor1012"
trace remove variable vapourTransport {read write unset} "$this accessor1015"
trace remove variable mountainBlockage {read write unset} "$this accessor1018"
trace remove variable vegitationHumidity {read write unset} "$this accessor1021"
trace remove variable cities {read write unset} "$this accessor1024"
trace remove variable maxCitySize {read write unset} "$this accessor1027"
trace remove variable cityGrouping {read write unset} "$this accessor1030"
trace remove variable waterColour {read write unset} "$this accessor1033"
trace remove variable vegitationColour {read write unset} "$this accessor1036"
trace remove variable lowerPlanetColour {read write unset} "$this accessor1039"
trace remove variable upperPlanetColour {read write unset} "$this accessor1042"
}
}

proc {planetgen_begin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1043} $a0 ]]
return $retpi
}
proc {planetgen_what} {  } {set retpi [uplevel 1 [list {c++ trampoline1045} ]]
set ret $retpi
return $ret
}
proc {planetgen_progress} {  } {set retpi [uplevel 1 [list {c++ trampoline1047} ]]
set ret $retpi
return $ret
}
proc {planetgen_done} {  } {set retpi [uplevel 1 [list {c++ trampoline1049} ]]
set ret $retpi
return $ret
}
proc {planetgen_kill} {  } {set retpi [uplevel 1 [list {c++ trampoline1051} ]]
return $retpi
}
proc {planetgen_save} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1053} $a0 $a1 ]]
return $retpi
}

proc {set_hud_message} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1055} $a0 $a1 ]]
return $retpi
}
proc {global_chat_post} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1057} $a0 ]]
return $retpi
}
proc {global_chat_post_local} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1059} $a0 ]]
return $retpi
}
proc {global_chat_post_remote} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1061} $a0 ]]
return $retpi
}
 proc accessor1065 {ignored ignored op} {
             global state
             if {$op == {read}} {
               set tmp [{c++ get1063} ]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set1064}  $state]
             } else { error "Cannot unset C++ variable state" }
           }


 proc accessor1067 {ignored ignored op} {
             global PLATFORM
             if {$op == {read}} {
               set tmp [{c++ get1066} ]
               set PLATFORM $tmp

             } elseif {$op == {write}} {
               error "Cannot write to PLATFORM"
             } else { error "Cannot unset C++ variable PLATFORM" }
           }

 proc accessor1069 {ignored ignored op} {
             global screenW
             if {$op == {read}} {
               set tmp [{c++ get1068} ]
               set screenW $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenW"
             } else { error "Cannot unset C++ variable screenW" }
           }

 proc accessor1071 {ignored ignored op} {
             global screenH
             if {$op == {read}} {
               set tmp [{c++ get1070} ]
               set screenH $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenH"
             } else { error "Cannot unset C++ variable screenH" }
           }

 proc accessor1073 {ignored ignored op} {
             global vheight
             if {$op == {read}} {
               set tmp [{c++ get1072} ]
               set vheight $tmp

             } elseif {$op == {write}} {
               error "Cannot write to vheight"
             } else { error "Cannot unset C++ variable vheight" }
           }

 proc accessor1076 {ignored ignored op} {
             global generalAlphaBlending
             if {$op == {read}} {
               set tmp [{c++ get1074} ]
               set generalAlphaBlending $tmp

             } elseif {$op == {write}} {
               return [{c++ set1075}  $generalAlphaBlending]
             } else { error "Cannot unset C++ variable generalAlphaBlending" }
           }

 proc accessor1079 {ignored ignored op} {
             global alphaBlendingEnabled
             if {$op == {read}} {
               set tmp [{c++ get1077} ]
               set alphaBlendingEnabled $tmp

             } elseif {$op == {write}} {
               return [{c++ set1078}  $alphaBlendingEnabled]
             } else { error "Cannot unset C++ variable alphaBlendingEnabled" }
           }

 proc accessor1082 {ignored ignored op} {
             global smoothScaling
             if {$op == {read}} {
               set tmp [{c++ get1080} ]
               set smoothScaling $tmp

             } elseif {$op == {write}} {
               return [{c++ set1081}  $smoothScaling]
             } else { error "Cannot unset C++ variable smoothScaling" }
           }

 proc accessor1085 {ignored ignored op} {
             global highQuality
             if {$op == {read}} {
               set tmp [{c++ get1083} ]
               set highQuality $tmp

             } elseif {$op == {write}} {
               return [{c++ set1084}  $highQuality]
             } else { error "Cannot unset C++ variable highQuality" }
           }

 proc accessor1088 {ignored ignored op} {
             global antialiasing
             if {$op == {read}} {
               set tmp [{c++ get1086} ]
               set antialiasing $tmp

             } elseif {$op == {write}} {
               return [{c++ set1087}  $antialiasing]
             } else { error "Cannot unset C++ variable antialiasing" }
           }


 proc accessor1090 {ignored ignored op} {
             global headless
             if {$op == {read}} {
               set tmp [{c++ get1089} ]
               set headless $tmp

             } elseif {$op == {write}} {
               error "Cannot write to headless"
             } else { error "Cannot unset C++ variable headless" }
           }

 proc accessor1093 {ignored ignored op} {
             global cameraX1
             if {$op == {read}} {
               set tmp [{c++ get1091} ]
               set cameraX1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1092}  $cameraX1]
             } else { error "Cannot unset C++ variable cameraX1" }
           }

 proc accessor1096 {ignored ignored op} {
             global cameraX2
             if {$op == {read}} {
               set tmp [{c++ get1094} ]
               set cameraX2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1095}  $cameraX2]
             } else { error "Cannot unset C++ variable cameraX2" }
           }

 proc accessor1099 {ignored ignored op} {
             global cameraY1
             if {$op == {read}} {
               set tmp [{c++ get1097} ]
               set cameraY1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1098}  $cameraY1]
             } else { error "Cannot unset C++ variable cameraY1" }
           }

 proc accessor1102 {ignored ignored op} {
             global cameraY2
             if {$op == {read}} {
               set tmp [{c++ get1100} ]
               set cameraY2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1101}  $cameraY2]
             } else { error "Cannot unset C++ variable cameraY2" }
           }

 proc accessor1105 {ignored ignored op} {
             global cameraCX
             if {$op == {read}} {
               set tmp [{c++ get1103} ]
               set cameraCX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1104}  $cameraCX]
             } else { error "Cannot unset C++ variable cameraCX" }
           }

 proc accessor1108 {ignored ignored op} {
             global cameraCY
             if {$op == {read}} {
               set tmp [{c++ get1106} ]
               set cameraCY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1107}  $cameraCY]
             } else { error "Cannot unset C++ variable cameraCY" }
           }

 proc accessor1111 {ignored ignored op} {
             global cameraZoom
             if {$op == {read}} {
               set tmp [{c++ get1109} ]
               set cameraZoom $tmp

             } elseif {$op == {write}} {
               return [{c++ set1110}  $cameraZoom]
             } else { error "Cannot unset C++ variable cameraZoom" }
           }

 proc accessor1114 {ignored ignored op} {
             global cursorX
             if {$op == {read}} {
               set tmp [{c++ get1112} ]
               set cursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1113}  $cursorX]
             } else { error "Cannot unset C++ variable cursorX" }
           }

 proc accessor1117 {ignored ignored op} {
             global cursorY
             if {$op == {read}} {
               set tmp [{c++ get1115} ]
               set cursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1116}  $cursorY]
             } else { error "Cannot unset C++ variable cursorY" }
           }

 proc accessor1120 {ignored ignored op} {
             global oldCursorX
             if {$op == {read}} {
               set tmp [{c++ get1118} ]
               set oldCursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1119}  $oldCursorX]
             } else { error "Cannot unset C++ variable oldCursorX" }
           }

 proc accessor1123 {ignored ignored op} {
             global oldCursorY
             if {$op == {read}} {
               set tmp [{c++ get1121} ]
               set oldCursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1122}  $oldCursorY]
             } else { error "Cannot unset C++ variable oldCursorY" }
           }


 proc accessor1125 {ignored ignored op} {
             global currentFrameTime
             if {$op == {read}} {
               set tmp [{c++ get1124} ]
               set currentFrameTime $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTime"
             } else { error "Cannot unset C++ variable currentFrameTime" }
           }

 proc accessor1127 {ignored ignored op} {
             global currentFrameTimeLeft
             if {$op == {read}} {
               set tmp [{c++ get1126} ]
               set currentFrameTimeLeft $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTimeLeft"
             } else { error "Cannot unset C++ variable currentFrameTimeLeft" }
           }

 proc accessor1129 {ignored ignored op} {
             global currentVFrameLast
             if {$op == {read}} {
               set tmp [{c++ get1128} ]
               set currentVFrameLast $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentVFrameLast"
             } else { error "Cannot unset C++ variable currentVFrameLast" }
           }

 proc accessor1131 {ignored ignored op} {
             global frameRate
             if {$op == {read}} {
               set tmp [{c++ get1130} ]
               set frameRate $tmp

             } elseif {$op == {write}} {
               error "Cannot write to frameRate"
             } else { error "Cannot unset C++ variable frameRate" }
           }

 proc accessor1133 {ignored ignored op} {
             global sparkCountMultiplier
             if {$op == {read}} {
               set tmp [{c++ get1132} ]
               set sparkCountMultiplier $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sparkCountMultiplier"
             } else { error "Cannot unset C++ variable sparkCountMultiplier" }
           }

 proc accessor1135 {ignored ignored op} {
             global gameClock
             if {$op == {read}} {
               set tmp [{c++ get1134} ]
               set gameClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to gameClock"
             } else { error "Cannot unset C++ variable gameClock" }
           }

 proc accessor1137 {ignored ignored op} {
             global STD_CELL_SZ
             if {$op == {read}} {
               set tmp [{c++ get1136} ]
               set STD_CELL_SZ $tmp

             } elseif {$op == {write}} {
               error "Cannot write to STD_CELL_SZ"
             } else { error "Cannot unset C++ variable STD_CELL_SZ" }
           }

::itcl::class {SquareIcon} {
inherit AObject
namespace eval :: {
proc {c++ new SquareIcon default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1139} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {load} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1141} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {unload} {  } {set retpi [uplevel 1 [list {c++ trampoline1143} $this ]]
return $retpi
}
method {isLoaded} {  } {set retpi [uplevel 1 [list {c++ trampoline1145} $this ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline1147} $this ]]
return $retpi
}
method {save} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1149} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}




::itcl::class {Antenna} {
inherit AObject
namespace eval :: {
proc {c++ new Antenna default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1154} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable tuner
 method accessor1158 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1156} $this]
               set tuner $tmp

             } elseif {$op == {write}} {
               return [{c++ set1157} $this $tuner]
             } else { error "Cannot unset C++ variable tuner" }
           }

method {setInternetInformation4} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline1159} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {setInternetInformation6} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline1161} $this $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
return $retpi
}
method {getGlobalID4} {  } {set retpi [uplevel 1 [list {c++ trampoline1163} $this ]]
set ret $retpi
return $ret
}
method {getGlobalID6} {  } {set retpi [uplevel 1 [list {c++ trampoline1165} $this ]]
set ret $retpi
return $ret
}
method {hasV4} {  } {set retpi [uplevel 1 [list {c++ trampoline1167} $this ]]
set ret $retpi
return $ret
}
method {hasV6} {  } {set retpi [uplevel 1 [list {c++ trampoline1169} $this ]]
set ret $retpi
return $ret
}
method {processIncomming} {  } {set retpi [uplevel 1 [list {c++ trampoline1171} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set tuner {}
            trace add variable tuner {read write unset} "$this accessor1158"







}
destructor {

trace remove variable tuner {read write unset} "$this accessor1158"







}
}

 proc accessor1174 {ignored ignored op} {
             global antenna
             if {$op == {read}} {
               set tmp [{c++ get1173} ]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

 proc accessor1177 {ignored ignored op} {
             global packetDropMask
             if {$op == {read}} {
               set tmp [{c++ get1175} ]
               set packetDropMask $tmp

             } elseif {$op == {write}} {
               return [{c++ set1176}  $packetDropMask]
             } else { error "Cannot unset C++ variable packetDropMask" }
           }


::itcl::class {Tuner} {
inherit AObject
namespace eval :: {
proc {c++ new Tuner default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1179} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {GlobalID} {
inherit AObject
namespace eval :: {
proc {c++ new GlobalID default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1182} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {toString} {  } {set retpi [uplevel 1 [list {c++ trampoline1184} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {PacketProcessor} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}



::itcl::class {NetworkAssembly} {
inherit AObject
public variable field
 method accessor1190 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1189} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable antenna
 method accessor1192 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1191} $this]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

namespace eval :: {
proc {c++ new NetworkAssembly default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1193} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getTuner} {  } {set retpi [uplevel 1 [list {c++ trampoline1195} $this ]]
set ret $retpi
return $ret
}
method {numConnections} {  } {set retpi [uplevel 1 [list {c++ trampoline1197} $this ]]
set ret $retpi
return $ret
}
method {getConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1199} $this $a0 ]]
set ret $retpi
return $ret
}
method {addConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1201} $this $a0 ]]
return $retpi
}
method {removeConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1203} $this $a0 ]]
return $retpi
}
method {addPacketProcessor} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1205} $this $a0 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1207} $this $a0 ]]
return $retpi
}
method {setFieldSize} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1209} $this $a0 $a1 ]]
return $retpi
}
method {changeField} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1211} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set field {}
            trace add variable field {read write unset} "$this accessor1190"
set antenna {}
            trace add variable antenna {read write unset} "$this accessor1192"










}
destructor {
trace remove variable field {read write unset} "$this accessor1190"
trace remove variable antenna {read write unset} "$this accessor1192"










}
}



::itcl::class {NetworkConnection} {
inherit PacketProcessor
public variable parent
 method accessor1216 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1215} $this]
               set parent $tmp

             } elseif {$op == {write}} {
               error "Cannot write to parent"
             } else { error "Cannot unset C++ variable parent" }
           }

public variable scg
 method accessor1218 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1217} $this]
               set scg $tmp

             } elseif {$op == {write}} {
               error "Cannot write to scg"
             } else { error "Cannot unset C++ variable scg" }
           }

public variable blameMask
 method accessor1221 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1219} $this]
               set blameMask $tmp

             } elseif {$op == {write}} {
               return [{c++ set1220} $this $blameMask]
             } else { error "Cannot unset C++ variable blameMask" }
           }

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1222} $this $a0 ]]
return $retpi
}
method {getStatus} {  } {set retpi [uplevel 1 [list {c++ trampoline1224} $this ]]
set ret $retpi
return $ret
}
method {getDisconnectReason} {  } {set retpi [uplevel 1 [list {c++ trampoline1226} $this ]]
set ret $retpi
return $ret
}
method {setFieldSize} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1228} $this $a0 $a1 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set parent {}
            trace add variable parent {read write unset} "$this accessor1216"
set scg {}
            trace add variable scg {read write unset} "$this accessor1218"
set blameMask {}
            trace add variable blameMask {read write unset} "$this accessor1221"




}
destructor {
trace remove variable parent {read write unset} "$this accessor1216"
trace remove variable scg {read write unset} "$this accessor1218"
trace remove variable blameMask {read write unset} "$this accessor1221"




}
}


::itcl::class {ConnectionListener} {
inherit PacketProcessor
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}


::itcl::class {InputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

::itcl::class {OutputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

itcl::class fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {} {}
      } {}
    }
::itcl::class {fun<InputNetworkGeraet*:NetworkConnection*>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<InputNetworkGeraet*:NetworkConnection*> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1234} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
set ret $retpi
return $ret
}
proc {call} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1238} $a0 $a1 ]]
set ret $retpi
return $ret
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline1240} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {SynchronousControlGeraet} {
inherit AObject
method {openChannel} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1243} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


::itcl::class {GameAdvertiser} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameAdvertiser default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline1246} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {setOverseerId} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1248} $this $a0 ]]
return $retpi
}
method {setPeerCount} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1250} $this $a0 ]]
return $retpi
}
method {setGameMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1252} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {GameDiscoverer} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameDiscoverer default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1255} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {start} {  } {set retpi [uplevel 1 [list {c++ trampoline1257} $this ]]
return $retpi
}
method {poll} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1259} $this $a0 ]]
return $retpi
}
method {progress} {  } {set retpi [uplevel 1 [list {c++ trampoline1261} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}




::itcl::class {SeqTextOutputGeraet} {
inherit OutputNetworkGeraet
namespace eval :: {
proc {c++ new SeqTextOutputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1265} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {send} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1267} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      OutputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

::itcl::class {SeqTextInputGeraet} {
inherit InputNetworkGeraet
namespace eval :: {
proc {c++ new TclSeqTextInputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1270} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {receiveText} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveText"]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      InputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}


::itcl::class {Peer} {
inherit AObject
public variable gid
 method accessor1276 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1275} $this]
               set gid $tmp

             } elseif {$op == {write}} {
               error "Cannot write to gid"
             } else { error "Cannot unset C++ variable gid" }
           }

public variable nid
 method accessor1278 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1277} $this]
               set nid $tmp

             } elseif {$op == {write}} {
               error "Cannot write to nid"
             } else { error "Cannot unset C++ variable nid" }
           }

public variable overseerReady
 method accessor1280 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1279} $this]
               set overseerReady $tmp

             } elseif {$op == {write}} {
               error "Cannot write to overseerReady"
             } else { error "Cannot unset C++ variable overseerReady" }
           }

public variable connectionAttempts
 method accessor1282 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1281} $this]
               set connectionAttempts $tmp

             } elseif {$op == {write}} {
               error "Cannot write to connectionAttempts"
             } else { error "Cannot unset C++ variable connectionAttempts" }
           }

public variable cxn
 method accessor1284 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1283} $this]
               set cxn $tmp

             } elseif {$op == {write}} {
               error "Cannot write to cxn"
             } else { error "Cannot unset C++ variable cxn" }
           }

public variable screenName
 method accessor1286 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1285} $this]
               set screenName $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenName"
             } else { error "Cannot unset C++ variable screenName" }
           }

public variable receivedStx
 method accessor1288 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1287} $this]
               set receivedStx $tmp

             } elseif {$op == {write}} {
               error "Cannot write to receivedStx"
             } else { error "Cannot unset C++ variable receivedStx" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set gid {}
            trace add variable gid {read write unset} "$this accessor1276"
set nid {}
            trace add variable nid {read write unset} "$this accessor1278"
set overseerReady {}
            trace add variable overseerReady {read write unset} "$this accessor1280"
set connectionAttempts {}
            trace add variable connectionAttempts {read write unset} "$this accessor1282"
set cxn {}
            trace add variable cxn {read write unset} "$this accessor1284"
set screenName {}
            trace add variable screenName {read write unset} "$this accessor1286"
set receivedStx {}
            trace add variable receivedStx {read write unset} "$this accessor1288"
}
destructor {
trace remove variable gid {read write unset} "$this accessor1276"
trace remove variable nid {read write unset} "$this accessor1278"
trace remove variable overseerReady {read write unset} "$this accessor1280"
trace remove variable connectionAttempts {read write unset} "$this accessor1282"
trace remove variable cxn {read write unset} "$this accessor1284"
trace remove variable screenName {read write unset} "$this accessor1286"
trace remove variable receivedStx {read write unset} "$this accessor1288"
}
}

::itcl::class {NetIface} {
inherit AObject
namespace eval :: {
proc {c++ new TclNetIface default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1290} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {addPeer} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function addPeer"]
return $retpi
}
method {delPeer} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function delPeer"]
return $retpi
}
method {setOverseer} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function setOverseer"]
return $retpi
}
method {receiveBroadcast} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveBroadcast"]
return $retpi
}
method {receiveOverseer} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveOverseer"]
return $retpi
}
method {receiveUnicast} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveUnicast"]
return $retpi
}
method {alterDatp} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function alterDatp"]
set ret $retpi
return $ret
}
method {alterDats} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function alterDats"]
set ret $retpi
return $ret
}
method {setGameMode} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function setGameMode"]
return $retpi
}
method {getGameMode} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getGameMode"]
set ret $retpi
return $ret
}
method {connectionLost} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function connectionLost"]
return $retpi
}
method {getFullDats} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getFullDats"]
set ret $retpi
return $ret
}
method {receiveShip} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveShip"]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {














}
destructor {














}
}

::itcl::class {NetworkGame} {
inherit AObject
namespace eval :: {
proc {c++ new NetworkGame default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1319} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {getLocalPeer} {  } {set retpi [uplevel 1 [list {c++ trampoline1321} $this ]]
set ret $retpi
return $ret
}
method {getOverseer} {  } {set retpi [uplevel 1 [list {c++ trampoline1323} $this ]]
set ret $retpi
return $ret
}
method {getPeerByConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1325} $this $a0 ]]
set ret $retpi
return $ret
}
method {getDisconnectReason} {  } {set retpi [uplevel 1 [list {c++ trampoline1327} $this ]]
set ret $retpi
return $ret
}
method {setNetIface} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1329} $this $a0 ]]
return $retpi
}
method {setAdvertising} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1331} $this $a0 ]]
return $retpi
}
method {stopAdvertising} {  } {set retpi [uplevel 1 [list {c++ trampoline1333} $this ]]
return $retpi
}
method {startDiscoveryScan} {  } {set retpi [uplevel 1 [list {c++ trampoline1335} $this ]]
return $retpi
}
method {discoveryScanProgress} {  } {set retpi [uplevel 1 [list {c++ trampoline1337} $this ]]
set ret $retpi
return $ret
}
method {discoveryScanDone} {  } {set retpi [uplevel 1 [list {c++ trampoline1339} $this ]]
set ret $retpi
return $ret
}
method {getDiscoveryResults} {  } {set retpi [uplevel 1 [list {c++ trampoline1341} $this ]]
set ret $retpi
return $ret
}
method {setLocalPeerName} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1343} $this $a0 ]]
return $retpi
}
method {setLocalPeerNID} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1345} $this $a0 ]]
return $retpi
}
method {setLocalPeerNIDAuto} {  } {set retpi [uplevel 1 [list {c++ trampoline1347} $this ]]
return $retpi
}
method {connectToNothing} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1349} $this $a0 $a1 ]]
return $retpi
}
method {connectToDiscovery} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1351} $this $a0 ]]
return $retpi
}
method {connectToLan} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1353} $this $a0 $a1 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1355} $this $a0 ]]
return $retpi
}
method {updateFieldSize} {  } {set retpi [uplevel 1 [list {c++ trampoline1357} $this ]]
return $retpi
}
method {changeField} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1359} $this $a0 ]]
return $retpi
}
method {alterDats} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1361} $this $a0 $a1 ]]
return $retpi
}
method {alterDatp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1363} $this $a0 $a1 ]]
return $retpi
}
method {sendUnicast} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1365} $this $a0 $a1 ]]
return $retpi
}
method {sendOverseer} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1367} $this $a0 $a1 ]]
return $retpi
}
method {sendBroadcast} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1369} $this $a0 ]]
return $retpi
}
method {sendGameMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1371} $this $a0 ]]
return $retpi
}
method {setBlameMask} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1373} $this $a0 $a1 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




























}
destructor {




























}
}


::itcl::class {ConfReg} {
inherit AObject
method {open} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1376} $this $a0 $a1 ]]
return $retpi
}
method {create} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1378} $this $a0 $a1 ]]
return $retpi
}
method {close} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1380} $this $a0 ]]
return $retpi
}
method {closeAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1382} $this ]]
return $retpi
}
method {modify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1384} $this $a0 ]]
return $retpi
}
method {unmodify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1386} $this $a0 ]]
return $retpi
}
method {sync} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1388} $this $a0 ]]
return $retpi
}
method {syncAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1390} $this ]]
return $retpi
}
method {revert} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1392} $this $a0 ]]
return $retpi
}
method {revertAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1394} $this ]]
return $retpi
}
method {addToWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1396} $this $a0 ]]
return $retpi
}
method {removeFromWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1398} $this $a0 ]]
return $retpi
}
method {clearWhitelist} {  } {set retpi [uplevel 1 [list {c++ trampoline1400} $this ]]
return $retpi
}
method {setWhitelistOnly} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1402} $this $a0 ]]
return $retpi
}
method {renameFile} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1404} $this $a0 $a1 ]]
return $retpi
}

method {exists} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1406} $this $a0 ]]
set ret $retpi
return $ret
}
method {bool} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1408} $this $a0 ]]
set ret $retpi
return $ret
}
method {int} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1410} $this $a0 ]]
set ret $retpi
return $ret
}
method {float} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1412} $this $a0 ]]
set ret $retpi
return $ret
}
method {str} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1414} $this $a0 ]]
set ret $retpi
return $ret
}
method {setb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1416} $this $a0 $a1 ]]
return $retpi
}
method {seti} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1418} $this $a0 $a1 ]]
return $retpi
}
method {setf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1420} $this $a0 $a1 ]]
return $retpi
}
method {sets} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1422} $this $a0 $a1 ]]
return $retpi
}
method {add} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1424} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addb} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1426} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addi} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1428} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addf} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1430} $this $a0 $a1 $a2 ]]
return $retpi
}
method {adds} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1432} $this $a0 $a1 $a2 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1434} $this $a0 ]]
return $retpi
}
method {append} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1436} $this $a0 $a1 ]]
return $retpi
}
method {appendb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1438} $this $a0 $a1 ]]
return $retpi
}
method {appendi} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1440} $this $a0 $a1 ]]
return $retpi
}
method {appendf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1442} $this $a0 $a1 ]]
return $retpi
}
method {appends} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1444} $this $a0 $a1 ]]
return $retpi
}
method {remix} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1446} $this $a0 $a1 ]]
return $retpi
}
method {name} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1448} $this $a0 ]]
set ret $retpi
return $ret
}
method {copy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1450} $this $a0 $a1 ]]
return $retpi
}
method {getType} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1452} $this $a0 ]]
set ret $retpi
return $ret
}
method {length} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1454} $this $a0 ]]
set ret $retpi
return $ret
}
method {isGroup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1456} $this $a0 ]]
set ret $retpi
return $ret
}
method {isArray} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1458} $this $a0 ]]
set ret $retpi
return $ret
}
method {isList} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1460} $this $a0 ]]
set ret $retpi
return $ret
}
method {isAggregate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1462} $this $a0 ]]
set ret $retpi
return $ret
}
method {isScalar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1464} $this $a0 ]]
set ret $retpi
return $ret
}
method {isNumber} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1466} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSourceLine} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1468} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
















































}
destructor {
















































}
}

 proc accessor1471 {ignored ignored op} {
             global globalConf
             if {$op == {read}} {
               set tmp [{c++ get1470} ]
               set globalConf $tmp

             } elseif {$op == {write}} {
               error "Cannot write to globalConf"
             } else { error "Cannot unset C++ variable globalConf" }
           }

proc {confcpy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1472} $a0 $a1 ]]
return $retpi
}
proc {l10n_acceptLanguage} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1474} $a0 ]]
return $retpi
}
proc {l10n_loadCatalogue} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1476} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {l10n_purgeCatalogue} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1478} $a0 ]]
return $retpi
}

proc {_} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1480} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
proc {namegenAny} {  } {set retpi [uplevel 1 [list {c++ trampoline1482} ]]
set ret $retpi
return $ret
}
proc {namegenGet} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1484} $a0 ]]
set ret $retpi
return $ret
}
proc {newInterpreter} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1486} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {delInterpreter} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1488} $a0 ]]
return $retpi
}

proc {safe_source} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1490} $a0 ]]
return $retpi
}
proc {bkg_start} {  } {set retpi [uplevel 1 [list {c++ trampoline1492} ]]
return $retpi
}
proc {bkg_req} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1494} $a0 ]]
return $retpi
}
proc {bkg_ans} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1496} $a0 ]]
return $retpi
}
proc {bkg_req2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1498} $a0 $a1 ]]
return $retpi
}
proc {bkg_ans2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1500} $a0 $a1 ]]
return $retpi
}
proc {bkg_rcv} {  } {set retpi [uplevel 1 [list {c++ trampoline1502} ]]
set ret $retpi
return $ret
}
proc {bkg_get} {  } {set retpi [uplevel 1 [list {c++ trampoline1504} ]]
set ret $retpi
return $ret
}
proc {bkg_wait} {  } {set retpi [uplevel 1 [list {c++ trampoline1506} ]]
return $retpi
}

proc {crypto_init} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1508} $a0 ]]
return $retpi
}
proc {crypto_rand} {  } {set retpi [uplevel 1 [list {c++ trampoline1510} ]]
set ret $retpi
return $ret
}
proc {crypto_powm} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1512} $a0 $a1 ]]
set ret $retpi
return $ret
}

proc {performValidation} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1514} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {getValidationResultA} {  } {set retpi [uplevel 1 [list {c++ trampoline1516} ]]
set ret $retpi
return $ret
}
proc {getValidationResultB} {  } {set retpi [uplevel 1 [list {c++ trampoline1518} ]]
set ret $retpi
return $ret
}

::itcl::class {NetworkTest} {
inherit TestState
namespace eval :: {
proc {c++ new NetworkTest default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1521} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      TestState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


proc {ship_mixer_init} {  } {set retpi [uplevel 1 [list {c++ trampoline1523} ]]
return $retpi
}
proc {ship_mixer_end} {  } {set retpi [uplevel 1 [list {c++ trampoline1525} ]]
return $retpi
}

proc {joystick_count} {  } {set retpi [uplevel 1 [list {c++ trampoline1527} ]]
set ret $retpi
return $ret
}
proc {joystick_name} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1529} $a0 ]]
set ret $retpi
return $ret
}
proc {joystick_axisCount} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1531} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {joystick_buttonCount} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1533} $a0 $a1 ]]
set ret $retpi
return $ret
}

proc {debugTclExports} {  } {set retpi [uplevel 1 [list {c++ trampoline1535} ]]
return $retpi
}































set SDLK_LAST {}
trace add variable SDLK_LAST {read write unset} accessor60

set none {}
trace add variable none {read write unset} accessor64
set lshift {}
trace add variable lshift {read write unset} accessor66
set rshift {}
trace add variable rshift {read write unset} accessor68
set lctrl {}
trace add variable lctrl {read write unset} accessor70
set rctrl {}
trace add variable rctrl {read write unset} accessor72
set lalt {}
trace add variable lalt {read write unset} accessor74
set ralt {}
trace add variable ralt {read write unset} accessor76
set lmeta {}
trace add variable lmeta {read write unset} accessor78
set rmeta {}
trace add variable rmeta {read write unset} accessor80
set num {}
trace add variable num {read write unset} accessor82
set caps {}
trace add variable caps {read write unset} accessor84
set mode {}
trace add variable mode {read write unset} accessor86
set reserved {}
trace add variable reserved {read write unset} accessor88
set glueClass(SDL_keysym) yes





set glueClass(SDL_KeyboardEvent) yes




set SDL_BUTTON_1 {}
trace add variable SDL_BUTTON_1 {read write unset} accessor113
set SDL_BUTTON_2 {}
trace add variable SDL_BUTTON_2 {read write unset} accessor115
set SDL_BUTTON_3 {}
trace add variable SDL_BUTTON_3 {read write unset} accessor117
set SDL_BUTTON_4 {}
trace add variable SDL_BUTTON_4 {read write unset} accessor119
set SDL_BUTTON_5 {}
trace add variable SDL_BUTTON_5 {read write unset} accessor121

set SDL_DEFAULT_REPEAT_INTERVAL {}
trace add variable SDL_DEFAULT_REPEAT_INTERVAL {read write unset} accessor125
set SDL_DEFAULT_REPEAT_DELAY {}
trace add variable SDL_DEFAULT_REPEAT_DELAY {read write unset} accessor127


set glueClass(SDL_MouseMotionEvent) yes







set glueClass(SDL_MouseButtonEvent) yes











set preliminaryRunMode {}
trace add variable preliminaryRunMode {read write unset} accessor175
set THIS_GL_TYPE {}
trace add variable THIS_GL_TYPE {read write unset} accessor177
set recommendedGLType {}
trace add variable recommendedGLType {read write unset} accessor180


set glueClass(Font) yes












set sysfont {}
trace add variable sysfont {read write unset} accessor205
set sysfontStipple {}
trace add variable sysfontStipple {read write unset} accessor207
set glueClass(GameState) yes








set glueClass(InitState) yes



set gameClass {}
trace add variable gameClass {read write unset} accessor228
set humanShip {}
trace add variable humanShip {read write unset} accessor231
set testStateMode {}
trace add variable testStateMode {read write unset} accessor234
set testStateSize {}
trace add variable testStateSize {read write unset} accessor237
set glueClass(TestState) yes






set glueClass(GameObject) yes


































set glueClass(GameField) yes

















set glueClass(Blast) yes


















set glueClass(CellFragment) yes




set glueClass(PlasmaFire) yes




set glueClass(Explosion) yes













set glueClass(OldStyleExplosion) yes






set glueClass(LightTrail) yes














set glueClass(fun<void:Ship*,bool>) yes





set glueClass(radar_t) yes


set glueClass(Ship) yes








































































set glueClass(Shield) yes

















set glueClass(EnergyCharge) yes







set glueClass(MagnetoBomb) yes







set glueClass(SemiguidedBomb) yes


set glueClass(PlasmaBurst) yes






set glueClass(MonophasicEnergyPulse) yes


set glueClass(Missile) yes


set glueClass(EffectsHandler) yes





set nullEffectsHandler {}
trace add variable nullEffectsHandler {read write unset} accessor690
set glueClass(Background) yes






set glueClass(Planet) yes



set glueClass(StarField) yes




set glueClass(Nebula) yes










set glueClass(Camera) yes









set glueClass(DynamicCamera) yes














set glueClass(FixedCamera) yes



set glueClass(Controller) yes








set glueClass(HumanController) yes







set isCompositionBufferInUse {}
trace add variable isCompositionBufferInUse {read write unset} accessor796
set compositionBufferPrefix {}
trace add variable compositionBufferPrefix {read write unset} accessor799




set glueClass(AIControl) yes




set glueClass(GeneticAI) yes








set glueClass(GenAI) yes







set glueClass(CommonKeyboardClient) yes












set glueClass(ForwardingEffectsHandler) yes


set glueClass(Spectator) yes








set glueClass(GameEnv) yes











set glueClass(Manipulator) yes
























set planetgen_width {}
trace add variable planetgen_width {read write unset} accessor941
set planetgen_height {}
trace add variable planetgen_height {read write unset} accessor943
set glueClass(PlanetGeneratorParms) yes













































set state {}
trace add variable state {read write unset} accessor1065

set PLATFORM {}
trace add variable PLATFORM {read write unset} accessor1067
set screenW {}
trace add variable screenW {read write unset} accessor1069
set screenH {}
trace add variable screenH {read write unset} accessor1071
set vheight {}
trace add variable vheight {read write unset} accessor1073
set generalAlphaBlending {}
trace add variable generalAlphaBlending {read write unset} accessor1076
set alphaBlendingEnabled {}
trace add variable alphaBlendingEnabled {read write unset} accessor1079
set smoothScaling {}
trace add variable smoothScaling {read write unset} accessor1082
set highQuality {}
trace add variable highQuality {read write unset} accessor1085
set antialiasing {}
trace add variable antialiasing {read write unset} accessor1088

set headless {}
trace add variable headless {read write unset} accessor1090
set cameraX1 {}
trace add variable cameraX1 {read write unset} accessor1093
set cameraX2 {}
trace add variable cameraX2 {read write unset} accessor1096
set cameraY1 {}
trace add variable cameraY1 {read write unset} accessor1099
set cameraY2 {}
trace add variable cameraY2 {read write unset} accessor1102
set cameraCX {}
trace add variable cameraCX {read write unset} accessor1105
set cameraCY {}
trace add variable cameraCY {read write unset} accessor1108
set cameraZoom {}
trace add variable cameraZoom {read write unset} accessor1111
set cursorX {}
trace add variable cursorX {read write unset} accessor1114
set cursorY {}
trace add variable cursorY {read write unset} accessor1117
set oldCursorX {}
trace add variable oldCursorX {read write unset} accessor1120
set oldCursorY {}
trace add variable oldCursorY {read write unset} accessor1123

set currentFrameTime {}
trace add variable currentFrameTime {read write unset} accessor1125
set currentFrameTimeLeft {}
trace add variable currentFrameTimeLeft {read write unset} accessor1127
set currentVFrameLast {}
trace add variable currentVFrameLast {read write unset} accessor1129
set frameRate {}
trace add variable frameRate {read write unset} accessor1131
set sparkCountMultiplier {}
trace add variable sparkCountMultiplier {read write unset} accessor1133
set gameClock {}
trace add variable gameClock {read write unset} accessor1135
set STD_CELL_SZ {}
trace add variable STD_CELL_SZ {read write unset} accessor1137
set glueClass(SquareIcon) yes










set glueClass(Antenna) yes










set antenna {}
trace add variable antenna {read write unset} accessor1174
set packetDropMask {}
trace add variable packetDropMask {read write unset} accessor1177

set glueClass(Tuner) yes



set glueClass(GlobalID) yes




set glueClass(PacketProcessor) yes



set glueClass(NetworkAssembly) yes















set glueClass(NetworkConnection) yes









set glueClass(ConnectionListener) yes


set glueClass(InputNetworkGeraet) yes

set glueClass(OutputNetworkGeraet) yes


set glueClass(fun<InputNetworkGeraet*:NetworkConnection*>) yes






set glueClass(SynchronousControlGeraet) yes



set glueClass(GameAdvertiser) yes






set glueClass(GameDiscoverer) yes








set glueClass(SeqTextOutputGeraet) yes



set glueClass(SeqTextInputGeraet) yes




set glueClass(Peer) yes








set glueClass(NetIface) yes















set glueClass(NetworkGame) yes






























set glueClass(ConfReg) yes

















































set globalConf {}
trace add variable globalConf {read write unset} accessor1471





























set glueClass(NetworkTest) yes













safe_source tcl/autosource.tcl
