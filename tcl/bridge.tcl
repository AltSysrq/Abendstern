
  package require Itcl

  # AUTOGENERATED BY generate.tcl. DO NOT EDIT DIRECTLY.
  # See readme.txt.

  #Our base Tcl glue code (eval'd to hardwire the magic cookie)
  eval [format {
    itcl::class AObject {
      # Ensure all code uses the fully-qualified name for C++ to recognize it
      method fqn {} {::return $this}

      protected constructor {cppClass constname cppArgs} {
        if {[::string length $constname]} {
          # Intercept errors so we don't leak the magic number
          if {[catch {
            "::c++ new $cppClass $constname" $this %s {*}$cppArgs
          } err]} {
            error "Bad constructor call: $cppClass $constname: $err"
          }
        }
      }
      destructor {
        {::c++ delete} $this %s
      }

      method super {sup cname {args {}}} {
        ${sup}::constructor $sup $cname $args
      }

      # Prevent access to the magic cookie by redirecting
      # all info requests to the global one
      method info {args} {
        ::namespace eval :: ::info {*}$args
      }
    }
  } ${ABENDSTERN-MAGIC-COOKIE-1} ${ABENDSTERN-MAGIC-COOKIE-1}]
  unset ABENDSTERN-MAGIC-COOKIE-1

  # Have rename commit suicide
  # rename rename {}

  set glueClass(AObject) yes

  proc new {clazz args} {
    global glueClass
    if {[info exists glueClass($clazz)]} {
      [$clazz #auto $clazz [lindex $args 0] [lrange $args 1 [llength $args]]] fqn
    } else {
      [$clazz #auto {*}$args] fqn
    }
  }

proc {c++ delete} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1} $a0 $a1 ]]
return $retpi
}
proc {glBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline3} $a0 ]]
return $retpi
}
proc {glEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline5} ]]
return $retpi
}
proc {glVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline7} $a0 $a1 ]]
return $retpi
}
proc {glColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline9} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {glPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline11} ]]
return $retpi
}
proc {glPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline13} ]]
return $retpi
}
proc {glLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline15} ]]
return $retpi
}
proc {glTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline17} $a0 $a1 ]]
return $retpi
}
proc {glRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline19} $a0 ]]
return $retpi
}
proc {glScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline21} $a0 $a1 ]]
return $retpi
}
proc {glUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline23} $a0 ]]
return $retpi
}
proc {glReset} {  } {set retpi [uplevel 1 [list {c++ trampoline25} ]]
return $retpi
}

proc {acsgi_begin} {  } {set retpi [uplevel 1 [list {c++ trampoline27} ]]
return $retpi
}
proc {acsgi_end} {  } {set retpi [uplevel 1 [list {c++ trampoline29} ]]
return $retpi
}
proc {acsgi_draw} {  } {set retpi [uplevel 1 [list {c++ trampoline31} ]]
return $retpi
}
proc {acsgi_textNormal} { a0  } {set retpi [uplevel 1 [list {c++ trampoline33} $a0 ]]
return $retpi
}
proc {cglBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline35} $a0 ]]
return $retpi
}
proc {cglEnd} {  } {set retpi [uplevel 1 [list {c++ trampoline37} ]]
return $retpi
}
proc {cglVertex} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline39} $a0 $a1 ]]
return $retpi
}
proc {cglColour} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline41} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {cglPushMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline43} ]]
return $retpi
}
proc {cglPopMatrix} {  } {set retpi [uplevel 1 [list {c++ trampoline45} ]]
return $retpi
}
proc {cglLoadIdentity} {  } {set retpi [uplevel 1 [list {c++ trampoline47} ]]
return $retpi
}
proc {cglTranslate} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline49} $a0 $a1 ]]
return $retpi
}
proc {cglRotate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline51} $a0 ]]
return $retpi
}
proc {cglScale} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline53} $a0 $a1 ]]
return $retpi
}
proc {cglUScale} { a0  } {set retpi [uplevel 1 [list {c++ trampoline55} $a0 ]]
return $retpi
}
proc {cglText} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline57} $a0 $a1 $a2 ]]
return $retpi
}
 proc accessor60 {ignored ignored op} {
             global none
             if {$op == {read}} {
               set tmp [{c++ get59} ]
               set none $tmp

             } elseif {$op == {write}} {
               error "Cannot write to none"
             } else { error "Cannot unset C++ variable none" }
           }

 proc accessor62 {ignored ignored op} {
             global lshift
             if {$op == {read}} {
               set tmp [{c++ get61} ]
               set lshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lshift"
             } else { error "Cannot unset C++ variable lshift" }
           }

 proc accessor64 {ignored ignored op} {
             global rshift
             if {$op == {read}} {
               set tmp [{c++ get63} ]
               set rshift $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rshift"
             } else { error "Cannot unset C++ variable rshift" }
           }

 proc accessor66 {ignored ignored op} {
             global lctrl
             if {$op == {read}} {
               set tmp [{c++ get65} ]
               set lctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lctrl"
             } else { error "Cannot unset C++ variable lctrl" }
           }

 proc accessor68 {ignored ignored op} {
             global rctrl
             if {$op == {read}} {
               set tmp [{c++ get67} ]
               set rctrl $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rctrl"
             } else { error "Cannot unset C++ variable rctrl" }
           }

 proc accessor70 {ignored ignored op} {
             global lalt
             if {$op == {read}} {
               set tmp [{c++ get69} ]
               set lalt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lalt"
             } else { error "Cannot unset C++ variable lalt" }
           }

 proc accessor72 {ignored ignored op} {
             global ralt
             if {$op == {read}} {
               set tmp [{c++ get71} ]
               set ralt $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ralt"
             } else { error "Cannot unset C++ variable ralt" }
           }

 proc accessor74 {ignored ignored op} {
             global lmeta
             if {$op == {read}} {
               set tmp [{c++ get73} ]
               set lmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lmeta"
             } else { error "Cannot unset C++ variable lmeta" }
           }

 proc accessor76 {ignored ignored op} {
             global rmeta
             if {$op == {read}} {
               set tmp [{c++ get75} ]
               set rmeta $tmp

             } elseif {$op == {write}} {
               error "Cannot write to rmeta"
             } else { error "Cannot unset C++ variable rmeta" }
           }

 proc accessor78 {ignored ignored op} {
             global num
             if {$op == {read}} {
               set tmp [{c++ get77} ]
               set num $tmp

             } elseif {$op == {write}} {
               error "Cannot write to num"
             } else { error "Cannot unset C++ variable num" }
           }

 proc accessor80 {ignored ignored op} {
             global caps
             if {$op == {read}} {
               set tmp [{c++ get79} ]
               set caps $tmp

             } elseif {$op == {write}} {
               error "Cannot write to caps"
             } else { error "Cannot unset C++ variable caps" }
           }

 proc accessor82 {ignored ignored op} {
             global mode
             if {$op == {read}} {
               set tmp [{c++ get81} ]
               set mode $tmp

             } elseif {$op == {write}} {
               error "Cannot write to mode"
             } else { error "Cannot unset C++ variable mode" }
           }

 proc accessor84 {ignored ignored op} {
             global reserved
             if {$op == {read}} {
               set tmp [{c++ get83} ]
               set reserved $tmp

             } elseif {$op == {write}} {
               error "Cannot write to reserved"
             } else { error "Cannot unset C++ variable reserved" }
           }

::itcl::class {SDL_keysym} {
inherit AObject
public variable scancode
 method accessor87 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get85} $this]
               set scancode $tmp

             } elseif {$op == {write}} {
               return [{c++ set86} $this $scancode]
             } else { error "Cannot unset C++ variable scancode" }
           }

public variable sym
 method accessor90 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get88} $this]
               set sym $tmp

             } elseif {$op == {write}} {
               return [{c++ set89} $this $sym]
             } else { error "Cannot unset C++ variable sym" }
           }

public variable mod
 method accessor93 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get91} $this]
               set mod $tmp

             } elseif {$op == {write}} {
               return [{c++ set92} $this $mod]
             } else { error "Cannot unset C++ variable mod" }
           }

public variable unicode
 method accessor96 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get94} $this]
               set unicode $tmp

             } elseif {$op == {write}} {
               return [{c++ set95} $this $unicode]
             } else { error "Cannot unset C++ variable unicode" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set scancode {}
            trace add variable scancode {read write unset} "$this accessor87"
set sym {}
            trace add variable sym {read write unset} "$this accessor90"
set mod {}
            trace add variable mod {read write unset} "$this accessor93"
set unicode {}
            trace add variable unicode {read write unset} "$this accessor96"
}
destructor {
trace remove variable scancode {read write unset} "$this accessor87"
trace remove variable sym {read write unset} "$this accessor90"
trace remove variable mod {read write unset} "$this accessor93"
trace remove variable unicode {read write unset} "$this accessor96"
}
}

::itcl::class {SDL_KeyboardEvent} {
inherit AObject
public variable type
 method accessor99 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get97} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set98} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor102 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get100} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set101} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable keysym
 method accessor105 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get103} $this]
               set keysym $tmp

             } elseif {$op == {write}} {
               return [{c++ set104} $this $keysym]
             } else { error "Cannot unset C++ variable keysym" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor99"
set state {}
            trace add variable state {read write unset} "$this accessor102"
set keysym {}
            trace add variable keysym {read write unset} "$this accessor105"
}
destructor {
trace remove variable type {read write unset} "$this accessor99"
trace remove variable state {read write unset} "$this accessor102"
trace remove variable keysym {read write unset} "$this accessor105"
}
}

 proc accessor107 {ignored ignored op} {
             global SDL_BUTTON_1
             if {$op == {read}} {
               set tmp [{c++ get106} ]
               set SDL_BUTTON_1 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_1"
             } else { error "Cannot unset C++ variable SDL_BUTTON_1" }
           }

 proc accessor109 {ignored ignored op} {
             global SDL_BUTTON_2
             if {$op == {read}} {
               set tmp [{c++ get108} ]
               set SDL_BUTTON_2 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_2"
             } else { error "Cannot unset C++ variable SDL_BUTTON_2" }
           }

 proc accessor111 {ignored ignored op} {
             global SDL_BUTTON_3
             if {$op == {read}} {
               set tmp [{c++ get110} ]
               set SDL_BUTTON_3 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_3"
             } else { error "Cannot unset C++ variable SDL_BUTTON_3" }
           }

 proc accessor113 {ignored ignored op} {
             global SDL_BUTTON_4
             if {$op == {read}} {
               set tmp [{c++ get112} ]
               set SDL_BUTTON_4 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_4"
             } else { error "Cannot unset C++ variable SDL_BUTTON_4" }
           }

 proc accessor115 {ignored ignored op} {
             global SDL_BUTTON_5
             if {$op == {read}} {
               set tmp [{c++ get114} ]
               set SDL_BUTTON_5 $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_BUTTON_5"
             } else { error "Cannot unset C++ variable SDL_BUTTON_5" }
           }

proc {SDL_GetModState} {  } {set retpi [uplevel 1 [list {c++ trampoline116} ]]
set ret $retpi
return $ret
}
 proc accessor119 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_INTERVAL
             if {$op == {read}} {
               set tmp [{c++ get118} ]
               set SDL_DEFAULT_REPEAT_INTERVAL $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_INTERVAL"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_INTERVAL" }
           }

 proc accessor121 {ignored ignored op} {
             global SDL_DEFAULT_REPEAT_DELAY
             if {$op == {read}} {
               set tmp [{c++ get120} ]
               set SDL_DEFAULT_REPEAT_DELAY $tmp

             } elseif {$op == {write}} {
               error "Cannot write to SDL_DEFAULT_REPEAT_DELAY"
             } else { error "Cannot unset C++ variable SDL_DEFAULT_REPEAT_DELAY" }
           }

proc {SDL_EnableKeyRepeat} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline122} $a0 $a1 ]]
return $retpi
}

::itcl::class {SDL_MouseMotionEvent} {
inherit AObject
public variable type
 method accessor126 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get124} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set125} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable state
 method accessor129 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get127} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set128} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor132 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get130} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set131} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor135 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get133} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set134} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

public variable xrel
 method accessor138 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get136} $this]
               set xrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set137} $this $xrel]
             } else { error "Cannot unset C++ variable xrel" }
           }

public variable yrel
 method accessor141 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get139} $this]
               set yrel $tmp

             } elseif {$op == {write}} {
               return [{c++ set140} $this $yrel]
             } else { error "Cannot unset C++ variable yrel" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor126"
set state {}
            trace add variable state {read write unset} "$this accessor129"
set x {}
            trace add variable x {read write unset} "$this accessor132"
set y {}
            trace add variable y {read write unset} "$this accessor135"
set xrel {}
            trace add variable xrel {read write unset} "$this accessor138"
set yrel {}
            trace add variable yrel {read write unset} "$this accessor141"
}
destructor {
trace remove variable type {read write unset} "$this accessor126"
trace remove variable state {read write unset} "$this accessor129"
trace remove variable x {read write unset} "$this accessor132"
trace remove variable y {read write unset} "$this accessor135"
trace remove variable xrel {read write unset} "$this accessor138"
trace remove variable yrel {read write unset} "$this accessor141"
}
}

::itcl::class {SDL_MouseButtonEvent} {
inherit AObject
public variable type
 method accessor144 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get142} $this]
               set type $tmp

             } elseif {$op == {write}} {
               return [{c++ set143} $this $type]
             } else { error "Cannot unset C++ variable type" }
           }

public variable which
 method accessor147 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get145} $this]
               set which $tmp

             } elseif {$op == {write}} {
               return [{c++ set146} $this $which]
             } else { error "Cannot unset C++ variable which" }
           }

public variable button
 method accessor150 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get148} $this]
               set button $tmp

             } elseif {$op == {write}} {
               return [{c++ set149} $this $button]
             } else { error "Cannot unset C++ variable button" }
           }

public variable state
 method accessor153 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get151} $this]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set152} $this $state]
             } else { error "Cannot unset C++ variable state" }
           }

public variable x
 method accessor156 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get154} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set155} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

public variable y
 method accessor159 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get157} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set158} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set type {}
            trace add variable type {read write unset} "$this accessor144"
set which {}
            trace add variable which {read write unset} "$this accessor147"
set button {}
            trace add variable button {read write unset} "$this accessor150"
set state {}
            trace add variable state {read write unset} "$this accessor153"
set x {}
            trace add variable x {read write unset} "$this accessor156"
set y {}
            trace add variable y {read write unset} "$this accessor159"
}
destructor {
trace remove variable type {read write unset} "$this accessor144"
trace remove variable which {read write unset} "$this accessor147"
trace remove variable button {read write unset} "$this accessor150"
trace remove variable state {read write unset} "$this accessor153"
trace remove variable x {read write unset} "$this accessor156"
trace remove variable y {read write unset} "$this accessor159"
}
}

proc {SDL_WarpMouse} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline160} $a0 $a1 ]]
return $retpi
}
proc {SDL_GetTicks} {  } {set retpi [uplevel 1 [list {c++ trampoline162} ]]
set ret $retpi
return $ret
}

::itcl::class {Font} {
inherit AObject
namespace eval :: {
proc {c++ new Font default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline164} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}


method {charWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline166} $this $a0 ]]
set ret $retpi
return $ret
}
method {width} { a0  } {set retpi [uplevel 1 [list {c++ trampoline168} $this $a0 ]]
set ret $retpi
return $ret
}
method {getHeight} {  } {set retpi [uplevel 1 [list {c++ trampoline170} $this ]]
set ret $retpi
return $ret
}
method {getRise} {  } {set retpi [uplevel 1 [list {c++ trampoline172} $this ]]
set ret $retpi
return $ret
}
method {getDip} {  } {set retpi [uplevel 1 [list {c++ trampoline174} $this ]]
set ret $retpi
return $ret
}
method {preDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline176} $this ]]
return $retpi
}
method {postDraw} {  } {set retpi [uplevel 1 [list {c++ trampoline178} $this ]]
return $retpi
}
method {drawCh} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline180} $this $a0 $a1 $a2 ]]
return $retpi
}
method {drawStr} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline182} $this $a0 $a1 $a2 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {











}
destructor {











}
}

 proc accessor185 {ignored ignored op} {
             global sysfont
             if {$op == {read}} {
               set tmp [{c++ get184} ]
               set sysfont $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfont"
             } else { error "Cannot unset C++ variable sysfont" }
           }

 proc accessor187 {ignored ignored op} {
             global sysfontStipple
             if {$op == {read}} {
               set tmp [{c++ get186} ]
               set sysfontStipple $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sysfontStipple"
             } else { error "Cannot unset C++ variable sysfontStipple" }
           }

::itcl::class {GameState} {
inherit AObject
namespace eval :: {
proc {c++ new TclGameState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline188} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {configureGL} {  } {set retpi [uplevel 1 [list {c++ deftramp195} $this ]]
return $retpi
}
method {keyboard} { a0  } {set retpi [uplevel 1 [list {c++ deftramp197} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ deftramp199} $this $a0 ]]
return $retpi
}
method {mouseButton} { a0  } {set retpi [uplevel 1 [list {c++ deftramp201} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {InitState} {
inherit GameState
namespace eval :: {
proc {c++ new InitState default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline202} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}


 proc accessor206 {ignored ignored op} {
             global gameClass
             if {$op == {read}} {
               set tmp [{c++ get204} ]
               set gameClass $tmp

             } elseif {$op == {write}} {
               return [{c++ set205}  $gameClass]
             } else { error "Cannot unset C++ variable gameClass" }
           }

 proc accessor209 {ignored ignored op} {
             global humanShip
             if {$op == {read}} {
               set tmp [{c++ get207} ]
               set humanShip $tmp

             } elseif {$op == {write}} {
               return [{c++ set208}  $humanShip]
             } else { error "Cannot unset C++ variable humanShip" }
           }

 proc accessor212 {ignored ignored op} {
             global testStateMode
             if {$op == {read}} {
               set tmp [{c++ get210} ]
               set testStateMode $tmp

             } elseif {$op == {write}} {
               return [{c++ set211}  $testStateMode]
             } else { error "Cannot unset C++ variable testStateMode" }
           }

 proc accessor215 {ignored ignored op} {
             global testStateSize
             if {$op == {read}} {
               set tmp [{c++ get213} ]
               set testStateSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set214}  $testStateSize]
             } else { error "Cannot unset C++ variable testStateSize" }
           }

::itcl::class {TestState} {
inherit GameState
namespace eval :: {
proc {c++ new TestState default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline216} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline218} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline220} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameState::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}



::itcl::class {GameObject} {
inherit AObject
public variable isRemote
 method accessor223 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get222} $this]
               set isRemote $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isRemote"
             } else { error "Cannot unset C++ variable isRemote" }
           }

public variable isExportable
 method accessor226 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get224} $this]
               set isExportable $tmp

             } elseif {$op == {write}} {
               return [{c++ set225} $this $isExportable]
             } else { error "Cannot unset C++ variable isExportable" }
           }

public variable isTransient
 method accessor229 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get227} $this]
               set isTransient $tmp

             } elseif {$op == {write}} {
               return [{c++ set228} $this $isTransient]
             } else { error "Cannot unset C++ variable isTransient" }
           }

public variable generatesUpdates
 method accessor232 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get230} $this]
               set generatesUpdates $tmp

             } elseif {$op == {write}} {
               return [{c++ set231} $this $generatesUpdates]
             } else { error "Cannot unset C++ variable generatesUpdates" }
           }

public variable tag
 method accessor235 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get233} $this]
               set tag $tmp

             } elseif {$op == {write}} {
               return [{c++ set234} $this $tag]
             } else { error "Cannot unset C++ variable tag" }
           }

public variable ignoreNetworkTag
 method accessor238 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get236} $this]
               set ignoreNetworkTag $tmp

             } elseif {$op == {write}} {
               return [{c++ set237} $this $ignoreNetworkTag]
             } else { error "Cannot unset C++ variable ignoreNetworkTag" }
           }

public variable lastRemoteUpdateSeq
 method accessor240 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get239} $this]
               set lastRemoteUpdateSeq $tmp

             } elseif {$op == {write}} {
               error "Cannot write to lastRemoteUpdateSeq"
             } else { error "Cannot unset C++ variable lastRemoteUpdateSeq" }
           }

protected variable field
 method accessor242 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get241} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable isDead
 method accessor244 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get243} $this]
               set isDead $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isDead"
             } else { error "Cannot unset C++ variable isDead" }
           }

protected variable x
 method accessor247 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get245} $this]
               set x $tmp

             } elseif {$op == {write}} {
               return [{c++ set246} $this $x]
             } else { error "Cannot unset C++ variable x" }
           }

protected variable y
 method accessor250 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get248} $this]
               set y $tmp

             } elseif {$op == {write}} {
               return [{c++ set249} $this $y]
             } else { error "Cannot unset C++ variable y" }
           }

protected variable vx
 method accessor253 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get251} $this]
               set vx $tmp

             } elseif {$op == {write}} {
               return [{c++ set252} $this $vx]
             } else { error "Cannot unset C++ variable vx" }
           }

protected variable vy
 method accessor256 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get254} $this]
               set vy $tmp

             } elseif {$op == {write}} {
               return [{c++ set255} $this $vy]
             } else { error "Cannot unset C++ variable vy" }
           }

protected variable includeInCollisionDetection
 method accessor259 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get257} $this]
               set includeInCollisionDetection $tmp

             } elseif {$op == {write}} {
               return [{c++ set258} $this $includeInCollisionDetection]
             } else { error "Cannot unset C++ variable includeInCollisionDetection" }
           }

protected variable classification
 method accessor262 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get260} $this]
               set classification $tmp

             } elseif {$op == {write}} {
               return [{c++ set261} $this $classification]
             } else { error "Cannot unset C++ variable classification" }
           }

protected variable decorative
 method accessor265 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get263} $this]
               set decorative $tmp

             } elseif {$op == {write}} {
               return [{c++ set264} $this $decorative]
             } else { error "Cannot unset C++ variable decorative" }
           }

namespace eval :: {
proc {c++ new TclGameObject default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline266} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject position} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline268} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclGameObject velocity} { a0 a1 a2 a3 a4 a5 a6  } {set retpi [uplevel 1 [list {c++ trampoline270} $a0 $a1 $a2 $a3 $a4 $a5 $a6 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 error "Call to pure-virtual function draw"]
return $retpi
}
method {getX} {  } {set retpi [uplevel 1 [list {c++ trampoline276} $this ]]
set ret $retpi
return $ret
}
method {getY} {  } {set retpi [uplevel 1 [list {c++ trampoline278} $this ]]
set ret $retpi
return $ret
}
method {getVX} {  } {set retpi [uplevel 1 [list {c++ trampoline280} $this ]]
set ret $retpi
return $ret
}
method {getVY} {  } {set retpi [uplevel 1 [list {c++ trampoline282} $this ]]
set ret $retpi
return $ret
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline284} $this ]]
set ret $retpi
return $ret
}
method {isDecorative} {  } {set retpi [uplevel 1 [list {c++ trampoline286} $this ]]
set ret $retpi
return $ret
}
method {getClassification} {  } {set retpi [uplevel 1 [list {c++ trampoline288} $this ]]
set ret $retpi
return $ret
}
method {okToDecorate} {  } {set retpi [uplevel 1 [list {c++ trampoline290} $this ]]
return $retpi
}
method {teleport} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp293} $this $a0 $a1 $a2 ]]
return $retpi
}
method {getRotation} {  } {set retpi [uplevel 1 [list {c++ deftramp295} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 error "Call to pure-virtual function getRadius"]
set ret $retpi
return $ret
}
method {isCollideable} {  } {set retpi [uplevel 1 [list {c++ deftramp299} $this ]]
set ret $retpi
return $ret
}
method {checkCollision} { a0  } {set retpi [uplevel 1 [list {c++ deftramp301} $this $a0 ]]
set ret $retpi
return $ret
}
method {del} {  } {set retpi [uplevel 1 [list {c++ trampoline302} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set isRemote {}
            trace add variable isRemote {read write unset} "$this accessor223"
set isExportable {}
            trace add variable isExportable {read write unset} "$this accessor226"
set isTransient {}
            trace add variable isTransient {read write unset} "$this accessor229"
set generatesUpdates {}
            trace add variable generatesUpdates {read write unset} "$this accessor232"
set tag {}
            trace add variable tag {read write unset} "$this accessor235"
set ignoreNetworkTag {}
            trace add variable ignoreNetworkTag {read write unset} "$this accessor238"
set lastRemoteUpdateSeq {}
            trace add variable lastRemoteUpdateSeq {read write unset} "$this accessor240"
set field {}
            trace add variable field {read write unset} "$this accessor242"
set isDead {}
            trace add variable isDead {read write unset} "$this accessor244"
set x {}
            trace add variable x {read write unset} "$this accessor247"
set y {}
            trace add variable y {read write unset} "$this accessor250"
set vx {}
            trace add variable vx {read write unset} "$this accessor253"
set vy {}
            trace add variable vy {read write unset} "$this accessor256"
set includeInCollisionDetection {}
            trace add variable includeInCollisionDetection {read write unset} "$this accessor259"
set classification {}
            trace add variable classification {read write unset} "$this accessor262"
set decorative {}
            trace add variable decorative {read write unset} "$this accessor265"



















}
destructor {
trace remove variable isRemote {read write unset} "$this accessor223"
trace remove variable isExportable {read write unset} "$this accessor226"
trace remove variable isTransient {read write unset} "$this accessor229"
trace remove variable generatesUpdates {read write unset} "$this accessor232"
trace remove variable tag {read write unset} "$this accessor235"
trace remove variable ignoreNetworkTag {read write unset} "$this accessor238"
trace remove variable lastRemoteUpdateSeq {read write unset} "$this accessor240"
trace remove variable field {read write unset} "$this accessor242"
trace remove variable isDead {read write unset} "$this accessor244"
trace remove variable x {read write unset} "$this accessor247"
trace remove variable y {read write unset} "$this accessor250"
trace remove variable vx {read write unset} "$this accessor253"
trace remove variable vy {read write unset} "$this accessor256"
trace remove variable includeInCollisionDetection {read write unset} "$this accessor259"
trace remove variable classification {read write unset} "$this accessor262"
trace remove variable decorative {read write unset} "$this accessor265"



















}
}


::itcl::class {GameField} {
inherit AObject
public variable fieldClock
 method accessor305 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get304} $this]
               set fieldClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to fieldClock"
             } else { error "Cannot unset C++ variable fieldClock" }
           }

public variable width
 method accessor307 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get306} $this]
               set width $tmp

             } elseif {$op == {write}} {
               error "Cannot write to width"
             } else { error "Cannot unset C++ variable width" }
           }

public variable height
 method accessor309 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get308} $this]
               set height $tmp

             } elseif {$op == {write}} {
               error "Cannot write to height"
             } else { error "Cannot unset C++ variable height" }
           }

public variable effects
 method accessor312 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get310} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set311} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable perfectRadar
 method accessor315 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get313} $this]
               set perfectRadar $tmp

             } elseif {$op == {write}} {
               return [{c++ set314} $this $perfectRadar]
             } else { error "Cannot unset C++ variable perfectRadar" }
           }

namespace eval :: {
proc {c++ new GameField default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline316} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline318} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline320} $this ]]
return $retpi
}
method {at} { a0  } {set retpi [uplevel 1 [list {c++ trampoline322} $this $a0 ]]
set ret $retpi
return $ret
}
method {size} {  } {set retpi [uplevel 1 [list {c++ trampoline324} $this ]]
set ret $retpi
return $ret
}
method {add} { a0  } {set retpi [uplevel 1 [list {c++ trampoline326} $this $a0 ]]
return $retpi
}
method {addBegin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline328} $this $a0 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline330} $this $a0 ]]
return $retpi
}
method {inject} { a0  } {set retpi [uplevel 1 [list {c++ trampoline332} $this $a0 ]]
return $retpi
}
method {clear} {  } {set retpi [uplevel 1 [list {c++ trampoline334} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set fieldClock {}
            trace add variable fieldClock {read write unset} "$this accessor305"
set width {}
            trace add variable width {read write unset} "$this accessor307"
set height {}
            trace add variable height {read write unset} "$this accessor309"
set effects {}
            trace add variable effects {read write unset} "$this accessor312"
set perfectRadar {}
            trace add variable perfectRadar {read write unset} "$this accessor315"










}
destructor {
trace remove variable fieldClock {read write unset} "$this accessor305"
trace remove variable width {read write unset} "$this accessor307"
trace remove variable height {read write unset} "$this accessor309"
trace remove variable effects {read write unset} "$this accessor312"
trace remove variable perfectRadar {read write unset} "$this accessor315"










}
}

::itcl::class {Blast} {
inherit GameObject
public variable blame
 method accessor337 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get336} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               error "Cannot write to blame"
             } else { error "Cannot unset C++ variable blame" }
           }

namespace eval :: {
proc {c++ new Blast default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline338} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDirect} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline340} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withSize} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline342} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withADC} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline344} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDecor} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline346} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast withDamage} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12  } {set retpi [uplevel 1 [list {c++ trampoline348} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Blast nonDamageCopy} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline350} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline352} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline354} $this ]]
return $retpi
}
method {getFalloff} {  } {set retpi [uplevel 1 [list {c++ trampoline356} $this ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline358} $this ]]
set ret $retpi
return $ret
}
method {getStrengthAt} { a0  } {set retpi [uplevel 1 [list {c++ trampoline360} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrengthUpon} { a0  } {set retpi [uplevel 1 [list {c++ trampoline362} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline364} $this ]]
set ret $retpi
return $ret
}
method {isDirect} {  } {set retpi [uplevel 1 [list {c++ trampoline366} $this ]]
set ret $retpi
return $ret
}
method {causesDamage} {  } {set retpi [uplevel 1 [list {c++ trampoline368} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set blame {}
            trace add variable blame {read write unset} "$this accessor337"
















}
destructor {
trace remove variable blame {read write unset} "$this accessor337"
















}
}

::itcl::class {CellFragment} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline370} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline372} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline374} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {PlasmaFire} {
inherit GameObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline376} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline378} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline380} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {



}
destructor {



}
}

::itcl::class {Explosion} {
inherit GameObject
public variable hungry
 method accessor384 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get382} $this]
               set hungry $tmp

             } elseif {$op == {write}} {
               return [{c++ set383} $this $hungry]
             } else { error "Cannot unset C++ variable hungry" }
           }

namespace eval :: {
proc {c++ new Explosion stationary} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11  } {set retpi [uplevel 1 [list {c++ trampoline385} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion velocity} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13  } {set retpi [uplevel 1 [list {c++ trampoline387} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion smeared} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15  } {set retpi [uplevel 1 [list {c++ trampoline389} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 $a15 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Explosion by} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10  } {set retpi [uplevel 1 [list {c++ trampoline391} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 ]]
set ret $retpi
return $ret
}}

method {multiExplosion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline393} $this $a0 ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline395} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline397} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline399} $this ]]
set ret $retpi
return $ret
}
method {getSize} {  } {set retpi [uplevel 1 [list {c++ trampoline401} $this ]]
set ret $retpi
return $ret
}
method {getDensity} {  } {set retpi [uplevel 1 [list {c++ trampoline403} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set hungry {}
            trace add variable hungry {read write unset} "$this accessor384"










}
destructor {
trace remove variable hungry {read write unset} "$this accessor384"










}
}

::itcl::class {OldStyleExplosion} {
inherit GameObject
namespace eval :: {
proc {c++ new OldStyleExplosion default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline405} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline407} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline409} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline411} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

::itcl::class {LightTrail} {
inherit GameObject
namespace eval :: {
proc {c++ new LightTrail default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14  } {set retpi [uplevel 1 [list {c++ trampoline413} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 $a10 $a11 $a12 $a13 $a14 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline415} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline417} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline419} $this ]]
set ret $retpi
return $ret
}
method {setWidth} { a0  } {set retpi [uplevel 1 [list {c++ trampoline421} $this $a0 ]]
return $retpi
}
method {emit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline423} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}







itcl::class fun<void:Ship*,bool>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<void:Ship*,bool>::fun_t {} {}
      } {}
    }
::itcl::class {fun<void:Ship*,bool>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<void:Ship*,bool> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline425} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0 a1  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
return $retpi
}
proc {call} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline429} $a0 $a1 $a2 ]]
return $retpi
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline431} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

::itcl::class {radar_t} {
inherit AObject
namespace eval :: {
proc {c++ new radar_t default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline433} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Ship} {
inherit GameObject
public variable controller
 method accessor437 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get435} $this]
               set controller $tmp

             } elseif {$op == {write}} {
               return [{c++ set436} $this $controller]
             } else { error "Cannot unset C++ variable controller" }
           }

public variable effects
 method accessor440 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get438} $this]
               set effects $tmp

             } elseif {$op == {write}} {
               return [{c++ set439} $this $effects]
             } else { error "Cannot unset C++ variable effects" }
           }

public variable shipExistenceFailure
 method accessor443 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get441} $this]
               set shipExistenceFailure $tmp

             } elseif {$op == {write}} {
               return [{c++ set442} $this $shipExistenceFailure]
             } else { error "Cannot unset C++ variable shipExistenceFailure" }
           }


proc {cellCoord} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline444} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {cellSubCoord} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline446} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}
public variable insignia
 method accessor450 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get448} $this]
               set insignia $tmp

             } elseif {$op == {write}} {
               return [{c++ set449} $this $insignia]
             } else { error "Cannot unset C++ variable insignia" }
           }

public variable blame
 method accessor453 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get451} $this]
               set blame $tmp

             } elseif {$op == {write}} {
               return [{c++ set452} $this $blame]
             } else { error "Cannot unset C++ variable blame" }
           }

public variable score
 method accessor456 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get454} $this]
               set score $tmp

             } elseif {$op == {write}} {
               return [{c++ set455} $this $score]
             } else { error "Cannot unset C++ variable score" }
           }

public variable damageMultiplier
 method accessor459 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get457} $this]
               set damageMultiplier $tmp

             } elseif {$op == {write}} {
               return [{c++ set458} $this $damageMultiplier]
             } else { error "Cannot unset C++ variable damageMultiplier" }
           }

public variable diedSpontaneously
 method accessor461 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get460} $this]
               set diedSpontaneously $tmp

             } elseif {$op == {write}} {
               error "Cannot write to diedSpontaneously"
             } else { error "Cannot unset C++ variable diedSpontaneously" }
           }

public variable typeName
 method accessor463 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get462} $this]
               set typeName $tmp

             } elseif {$op == {write}} {
               error "Cannot write to typeName"
             } else { error "Cannot unset C++ variable typeName" }
           }

namespace eval :: {
proc {c++ new Ship default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline464} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}


method {refreshUpdates} {  } {set retpi [uplevel 1 [list {c++ trampoline466} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline468} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline470} $this ]]
return $retpi
}

method {getVRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline472} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline474} $this ]]
set ret $retpi
return $ret
}
method {glSetColour0} {  } {set retpi [uplevel 1 [list {c++ trampoline476} $this ]]
return $retpi
}
method {glSetColour1} { a0  } {set retpi [uplevel 1 [list {c++ trampoline478} $this $a0 ]]
return $retpi
}
method {glSetColour2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline480} $this $a0 $a1 ]]
return $retpi
}
method {setThrust} { a0  } {set retpi [uplevel 1 [list {c++ trampoline482} $this $a0 ]]
return $retpi
}
method {getThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline484} $this ]]
set ret $retpi
return $ret
}
method {getTrueThrust} {  } {set retpi [uplevel 1 [list {c++ trampoline486} $this ]]
set ret $retpi
return $ret
}
method {setThrustOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline488} $this $a0 ]]
return $retpi
}
method {isThrustOn} {  } {set retpi [uplevel 1 [list {c++ trampoline490} $this ]]
set ret $retpi
return $ret
}
method {setBrakeOn} { a0  } {set retpi [uplevel 1 [list {c++ trampoline492} $this $a0 ]]
return $retpi
}
method {isBrakeOn} {  } {set retpi [uplevel 1 [list {c++ trampoline494} $this ]]
set ret $retpi
return $ret
}
method {configureEngines} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline496} $this $a0 $a1 $a2 ]]
return $retpi
}
method {configureEngines2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline498} $this $a0 $a1 ]]
return $retpi
}
method {getAcceleration} {  } {set retpi [uplevel 1 [list {c++ trampoline500} $this ]]
set ret $retpi
return $ret
}
method {getRotationRate} {  } {set retpi [uplevel 1 [list {c++ trampoline502} $this ]]
set ret $retpi
return $ret
}
method {getRotationAccel} {  } {set retpi [uplevel 1 [list {c++ trampoline504} $this ]]
set ret $retpi
return $ret
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline506} $this ]]
set ret $retpi
return $ret
}
method {getPowerUsagePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline508} $this ]]
set ret $retpi
return $ret
}
method {getPowerSupply} {  } {set retpi [uplevel 1 [list {c++ trampoline510} $this ]]
set ret $retpi
return $ret
}
method {getPowerDrain} {  } {set retpi [uplevel 1 [list {c++ trampoline512} $this ]]
set ret $retpi
return $ret
}
method {getCurrentCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline514} $this ]]
set ret $retpi
return $ret
}
method {getMaximumCapacitance} {  } {set retpi [uplevel 1 [list {c++ trampoline516} $this ]]
set ret $retpi
return $ret
}
method {getCapacitancePercent} {  } {set retpi [uplevel 1 [list {c++ trampoline518} $this ]]
set ret $retpi
return $ret
}
method {setColour} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline520} $this $a0 $a1 $a2 ]]
return $retpi
}
method {destroyGraphicsInfo} {  } {set retpi [uplevel 1 [list {c++ trampoline522} $this ]]
return $retpi
}
method {getColourR} {  } {set retpi [uplevel 1 [list {c++ trampoline524} $this ]]
set ret $retpi
return $ret
}
method {getColourG} {  } {set retpi [uplevel 1 [list {c++ trampoline526} $this ]]
set ret $retpi
return $ret
}
method {getColourB} {  } {set retpi [uplevel 1 [list {c++ trampoline528} $this ]]
set ret $retpi
return $ret
}
method {drawPower} { a0  } {set retpi [uplevel 1 [list {c++ trampoline530} $this $a0 ]]
set ret $retpi
return $ret
}
method {getReinforcement} {  } {set retpi [uplevel 1 [list {c++ trampoline532} $this ]]
set ret $retpi
return $ret
}
method {setReinforcement} { a0  } {set retpi [uplevel 1 [list {c++ trampoline534} $this $a0 ]]
return $retpi
}
method {enableSoundEffects} {  } {set retpi [uplevel 1 [list {c++ trampoline536} $this ]]
return $retpi
}

method {hasPower} {  } {set retpi [uplevel 1 [list {c++ trampoline538} $this ]]
set ret $retpi
return $ret
}
method {spontaneouslyDie} {  } {set retpi [uplevel 1 [list {c++ trampoline540} $this ]]
return $retpi
}
method {getCoolingMult} {  } {set retpi [uplevel 1 [list {c++ trampoline542} $this ]]
set ret $retpi
return $ret
}
method {getCellVelocity} { a0  } {set retpi [uplevel 1 [list {c++ trampoline544} $this $a0 ]]
set ret $retpi
return $ret
}

method {spin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline546} $this $a0 ]]
return $retpi
}
method {startTest} {  } {set retpi [uplevel 1 [list {c++ trampoline548} $this ]]
return $retpi
}
method {endTest} {  } {set retpi [uplevel 1 [list {c++ trampoline550} $this ]]
set ret $retpi
return $ret
}

method {applyCollision} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline552} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {cellCount} {  } {set retpi [uplevel 1 [list {c++ trampoline554} $this ]]
set ret $retpi
return $ret
}
method {getRadar} {  } {set retpi [uplevel 1 [list {c++ trampoline556} $this ]]
set ret $retpi
return $ret
}
method {setRadar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline558} $this $a0 ]]
return $retpi
}
method {getDeathAttributions} {  } {set retpi [uplevel 1 [list {c++ trampoline560} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set controller {}
            trace add variable controller {read write unset} "$this accessor437"
set effects {}
            trace add variable effects {read write unset} "$this accessor440"
set shipExistenceFailure {}
            trace add variable shipExistenceFailure {read write unset} "$this accessor443"



set insignia {}
            trace add variable insignia {read write unset} "$this accessor450"
set blame {}
            trace add variable blame {read write unset} "$this accessor453"
set score {}
            trace add variable score {read write unset} "$this accessor456"
set damageMultiplier {}
            trace add variable damageMultiplier {read write unset} "$this accessor459"
set diedSpontaneously {}
            trace add variable diedSpontaneously {read write unset} "$this accessor461"
set typeName {}
            trace add variable typeName {read write unset} "$this accessor463"






















































}
destructor {
trace remove variable controller {read write unset} "$this accessor437"
trace remove variable effects {read write unset} "$this accessor440"
trace remove variable shipExistenceFailure {read write unset} "$this accessor443"



trace remove variable insignia {read write unset} "$this accessor450"
trace remove variable blame {read write unset} "$this accessor453"
trace remove variable score {read write unset} "$this accessor456"
trace remove variable damageMultiplier {read write unset} "$this accessor459"
trace remove variable diedSpontaneously {read write unset} "$this accessor461"
trace remove variable typeName {read write unset} "$this accessor463"






















































}
}

proc {verify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline562} $a0 ]]
set ret $retpi
return $ret
}
proc {loadShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline564} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {saveShip} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline566} $a0 $a1 ]]
return $retpi
}

::itcl::class {Shield} {
inherit AObject
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline568} $this $a0 ]]
return $retpi
}
method {updateDist} {  } {set retpi [uplevel 1 [list {c++ trampoline570} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline572} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline574} $this ]]
set ret $retpi
return $ret
}
method {collideWith} { a0  } {set retpi [uplevel 1 [list {c++ trampoline576} $this $a0 ]]
set ret $retpi
return $ret
}
method {getStrength} {  } {set retpi [uplevel 1 [list {c++ trampoline578} $this ]]
set ret $retpi
return $ret
}
method {getStability} {  } {set retpi [uplevel 1 [list {c++ trampoline580} $this ]]
set ret $retpi
return $ret
}
method {getShip} {  } {set retpi [uplevel 1 [list {c++ trampoline582} $this ]]
set ret $retpi
return $ret
}
method {drawForHUD} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline584} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {









}
destructor {









}
}


proc {insignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline586} $a0 ]]
set ret $retpi
return $ret
}
proc {clear_insignias} {  } {set retpi [uplevel 1 [list {c++ trampoline588} ]]
return $retpi
}

proc {getAlliance} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline590} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {setAlliance} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline592} $a0 $a1 $a2 ]]
return $retpi
}

::itcl::class {EnergyCharge} {
inherit GameObject
namespace eval :: {
proc {c++ new EnergyCharge default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline594} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp597} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline598} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline600} $this ]]
set ret $retpi
return $ret
}
method {getIntensity} {  } {set retpi [uplevel 1 [list {c++ trampoline602} $this ]]
set ret $retpi
return $ret
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline604} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {MagnetoBomb} {
inherit GameObject
namespace eval :: {
proc {c++ new MagnetoBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline606} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp609} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline610} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline612} $this ]]
set ret $retpi
return $ret
}
method {getPower} {  } {set retpi [uplevel 1 [list {c++ trampoline614} $this ]]
set ret $retpi
return $ret
}
method {simulateFailure} {  } {set retpi [uplevel 1 [list {c++ trampoline616} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

::itcl::class {SemiguidedBomb} {
inherit MagnetoBomb
namespace eval :: {
proc {c++ new SemiguidedBomb default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline618} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      MagnetoBomb::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {PlasmaBurst} {
inherit GameObject
namespace eval :: {
proc {c++ new PlasmaBurst default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline620} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp623} $this $a0 ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline624} $this ]]
return $retpi
}
method {getRadius} {  } {set retpi [uplevel 1 [list {c++ trampoline626} $this ]]
set ret $retpi
return $ret
}
method {getMass} {  } {set retpi [uplevel 1 [list {c++ trampoline628} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {





}
destructor {





}
}

::itcl::class {MonophasicEnergyPulse} {
inherit GameObject
namespace eval :: {
proc {c++ new MonophasicEnergyPulse default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline630} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Missile} {
inherit GameObject
namespace eval :: {
proc {c++ new Missile default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline632} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {EffectsHandler} {
inherit AObject
namespace eval :: {
proc {c++ new EffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline634} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclEffectsHandler default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline636} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {impact} { a0  } {set retpi [uplevel 1 [list {c++ deftramp639} $this $a0 ]]
return $retpi
}
method {explode} { a0  } {set retpi [uplevel 1 [list {c++ deftramp641} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

 proc accessor643 {ignored ignored op} {
             global nullEffectsHandler
             if {$op == {read}} {
               set tmp [{c++ get642} ]
               set nullEffectsHandler $tmp

             } elseif {$op == {write}} {
               error "Cannot write to nullEffectsHandler"
             } else { error "Cannot unset C++ variable nullEffectsHandler" }
           }

::itcl::class {Background} {
inherit EffectsHandler
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline644} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline646} $this $a0 ]]
return $retpi
}
method {updateReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline648} $this $a0 $a1 ]]
return $retpi
}
method {repopulate} {  } {set retpi [uplevel 1 [list {c++ trampoline650} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

::itcl::class {Planet} {
inherit Background
namespace eval :: {
proc {c++ new Planet default} { a0 a1 a2 a3 a4 a5 a6 a7 a8 a9  } {set retpi [uplevel 1 [list {c++ trampoline652} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 $a9 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {StarField} {
inherit Background
namespace eval :: {
proc {c++ new StarField default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline654} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Nebula} {
inherit Background
namespace eval :: {
proc {c++ new Nebula default} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline656} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
set ret $retpi
return $ret
}}

method {setFlowEquation} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline658} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {setPressureEquation} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline660} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
method {setPressureResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline662} $this $a0 ]]
return $retpi
}
method {getPressureResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline664} $this ]]
set ret $retpi
return $ret
}
method {setVelocityResetTime} { a0  } {set retpi [uplevel 1 [list {c++ trampoline666} $this $a0 ]]
return $retpi
}
method {getVelocityResetTime} {  } {set retpi [uplevel 1 [list {c++ trampoline668} $this ]]
set ret $retpi
return $ret
}
method {setForceMultiplier} { a0  } {set retpi [uplevel 1 [list {c++ trampoline670} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Background::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {








}
destructor {








}
}

proc {initStarLists} {  } {set retpi [uplevel 1 [list {c++ trampoline672} ]]
return $retpi
}

::itcl::class {Camera} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new TclCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline674} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

protected variable reference
 method accessor678 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get676} $this]
               set reference $tmp

             } elseif {$op == {write}} {
               return [{c++ set677} $this $reference]
             } else { error "Cannot unset C++ variable reference" }
           }

protected method {doSetup} {  } {set retpi [uplevel 1 error "Call to pure-virtual function doSetup"]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ deftramp682} $this $a0 ]]
return $retpi
}
method {drawOverlays} {  } {set retpi [uplevel 1 [list {c++ deftramp684} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ deftramp686} $this ]]
return $retpi
}
method {setup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline687} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set reference {}
            trace add variable reference {read write unset} "$this accessor678"





}
destructor {

trace remove variable reference {read write unset} "$this accessor678"





}
}

::itcl::class {DynamicCamera} {
inherit Camera
namespace eval :: {
proc {c++ new DynamicCamera default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline689} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline691} $this $a0 ]]
return $retpi
}
protected method {doSetup} {  } {set retpi [uplevel 1 [list {c++ trampoline693} $this ]]
return $retpi
}
method {reset} {  } {set retpi [uplevel 1 [list {c++ trampoline695} $this ]]
return $retpi
}
method {getZoom} {  } {set retpi [uplevel 1 [list {c++ trampoline697} $this ]]
set ret $retpi
return $ret
}
method {setZoom} { a0  } {set retpi [uplevel 1 [list {c++ trampoline699} $this $a0 ]]
return $retpi
}
method {getRotateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline701} $this ]]
set ret $retpi
return $ret
}
method {setRotateMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline703} $this $a0 ]]
return $retpi
}
method {getLookAhead} {  } {set retpi [uplevel 1 [list {c++ trampoline705} $this ]]
set ret $retpi
return $ret
}
method {setLookAhead} { a0  } {set retpi [uplevel 1 [list {c++ trampoline707} $this $a0 ]]
return $retpi
}
method {getVisualRotation} {  } {set retpi [uplevel 1 [list {c++ trampoline709} $this ]]
set ret $retpi
return $ret
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline711} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {












}
destructor {












}
}

::itcl::class {FixedCamera} {
inherit Camera
namespace eval :: {
proc {c++ new FixedCamera default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline713} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Camera::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Controller} {
inherit AObject
public variable ship
 method accessor716 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get715} $this]
               set ship $tmp

             } elseif {$op == {write}} {
               error "Cannot write to ship"
             } else { error "Cannot unset C++ variable ship" }
           }

namespace eval :: {
proc {c++ new TclController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline717} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function update"]
return $retpi
}
method {damage} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ deftramp722} $this $a0 $a1 $a2 ]]
return $retpi
}
method {otherShipDied} { a0  } {set retpi [uplevel 1 [list {c++ deftramp724} $this $a0 ]]
return $retpi
}
method {notifyScore} { a0  } {set retpi [uplevel 1 [list {c++ deftramp726} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set ship {}
            trace add variable ship {read write unset} "$this accessor716"





}
destructor {
trace remove variable ship {read write unset} "$this accessor716"





}
}

::itcl::class {HumanController} {
inherit Controller
namespace eval :: {
proc {c++ new HumanController default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline727} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline729} $this ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline731} $this $a0 ]]
return $retpi
}
method {motion} { a0  } {set retpi [uplevel 1 [list {c++ trampoline733} $this $a0 ]]
return $retpi
}
method {button} { a0  } {set retpi [uplevel 1 [list {c++ trampoline735} $this $a0 ]]
return $retpi
}
method {key} { a0  } {set retpi [uplevel 1 [list {c++ trampoline737} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}

 proc accessor740 {ignored ignored op} {
             global isCompositionBufferInUse
             if {$op == {read}} {
               set tmp [{c++ get739} ]
               set isCompositionBufferInUse $tmp

             } elseif {$op == {write}} {
               error "Cannot write to isCompositionBufferInUse"
             } else { error "Cannot unset C++ variable isCompositionBufferInUse" }
           }

::itcl::class {AIControl} {
inherit Controller
namespace eval :: {
proc {c++ new AIControl default} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline741} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline743} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

::itcl::class {GeneticAI} {
inherit Controller
namespace eval :: {
proc {c++ new GeneticAI default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline745} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline747} $this $a0 ]]
return $retpi
}
public variable species
 method accessor750 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get749} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor752 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get751} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

public variable instance
 method accessor754 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get753} $this]
               set instance $tmp

             } elseif {$op == {write}} {
               error "Cannot write to instance"
             } else { error "Cannot unset C++ variable instance" }
           }

public variable failed
 method accessor756 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get755} $this]
               set failed $tmp

             } elseif {$op == {write}} {
               error "Cannot write to failed"
             } else { error "Cannot unset C++ variable failed" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


set species {}
            trace add variable species {read write unset} "$this accessor750"
set generation {}
            trace add variable generation {read write unset} "$this accessor752"
set instance {}
            trace add variable instance {read write unset} "$this accessor754"
set failed {}
            trace add variable failed {read write unset} "$this accessor756"
}
destructor {


trace remove variable species {read write unset} "$this accessor750"
trace remove variable generation {read write unset} "$this accessor752"
trace remove variable instance {read write unset} "$this accessor754"
trace remove variable failed {read write unset} "$this accessor756"
}
}

proc {calculateGeneticAIFunctionCosts} {  } {set retpi [uplevel 1 [list {c++ trampoline757} ]]
return $retpi
}
::itcl::class {GenAI} {
inherit Controller
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline759} $this $a0 ]]
return $retpi
}
public variable species
 method accessor762 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get761} $this]
               set species $tmp

             } elseif {$op == {write}} {
               error "Cannot write to species"
             } else { error "Cannot unset C++ variable species" }
           }

public variable generation
 method accessor764 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get763} $this]
               set generation $tmp

             } elseif {$op == {write}} {
               error "Cannot write to generation"
             } else { error "Cannot unset C++ variable generation" }
           }

method {getScores} {  } {set retpi [uplevel 1 [list {c++ trampoline765} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      Controller::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set species {}
            trace add variable species {read write unset} "$this accessor762"
set generation {}
            trace add variable generation {read write unset} "$this accessor764"

}
destructor {

trace remove variable species {read write unset} "$this accessor762"
trace remove variable generation {read write unset} "$this accessor764"

}
}

proc {GenAI_make} { a0  } {set retpi [uplevel 1 [list {c++ trampoline767} $a0 ]]
set ret $retpi
return $ret
}
::itcl::class {CommonKeyboardClient} {
inherit AObject
namespace eval :: {
proc {c++ new CommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline769} $a0 $a1 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new TclCommonKeyboardClient default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline771} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {exit} {  } {set retpi [uplevel 1 [list {c++ deftramp774} $this ]]
return $retpi
}
method {slow} {  } {set retpi [uplevel 1 [list {c++ deftramp776} $this ]]
return $retpi
}
method {fast} {  } {set retpi [uplevel 1 [list {c++ deftramp778} $this ]]
return $retpi
}
method {halt} {  } {set retpi [uplevel 1 [list {c++ deftramp780} $this ]]
return $retpi
}
method {frameXframe} {  } {set retpi [uplevel 1 [list {c++ deftramp782} $this ]]
return $retpi
}
method {statsOn} {  } {set retpi [uplevel 1 [list {c++ deftramp784} $this ]]
return $retpi
}
method {statsOff} {  } {set retpi [uplevel 1 [list {c++ deftramp786} $this ]]
return $retpi
}
method {hc_conf_bind} {  } {set retpi [uplevel 1 [list {c++ trampoline787} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {










}
destructor {










}
}

proc {hc_conf_configure} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline789} $a0 $a1 ]]
return $retpi
}
proc {hc_conf_clear} {  } {set retpi [uplevel 1 [list {c++ trampoline791} ]]
return $retpi
}

::itcl::class {ForwardingEffectsHandler} {
inherit EffectsHandler
namespace eval :: {
proc {c++ new ForwardingEffectsHandler default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline793} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      EffectsHandler::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {Spectator} {
inherit GameObject
namespace eval :: {
proc {c++ new Spectator default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline795} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator explicit} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline797} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new Spectator empty} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline799} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {nextReference} {  } {set retpi [uplevel 1 [list {c++ trampoline801} $this ]]
return $retpi
}
method {requireInsignia} { a0  } {set retpi [uplevel 1 [list {c++ trampoline803} $this $a0 ]]
return $retpi
}
method {kill} {  } {set retpi [uplevel 1 [list {c++ trampoline805} $this ]]
return $retpi
}
method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline807} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      GameObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







}
destructor {







}
}

::itcl::class {GameEnv} {
inherit AObject
namespace eval :: {
proc {c++ new GameEnv customCamera} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline809} $a0 $a1 $a2 $a3 $a4 ]]
set ret $retpi
return $ret
}}

namespace eval :: {
proc {c++ new GameEnv default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline811} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getReference} {  } {set retpi [uplevel 1 [list {c++ trampoline813} $this ]]
set ret $retpi
return $ret
}
method {setReference} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline815} $this $a0 $a1 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline817} $this $a0 ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline819} $this ]]
return $retpi
}
method {getField} {  } {set retpi [uplevel 1 [list {c++ trampoline821} $this ]]
set ret $retpi
return $ret
}
public variable cam
 method accessor825 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get823} $this]
               set cam $tmp

             } elseif {$op == {write}} {
               return [{c++ set824} $this $cam]
             } else { error "Cannot unset C++ variable cam" }
           }

public variable stars
 method accessor828 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get826} $this]
               set stars $tmp

             } elseif {$op == {write}} {
               return [{c++ set827} $this $stars]
             } else { error "Cannot unset C++ variable stars" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {







set cam {}
            trace add variable cam {read write unset} "$this accessor825"
set stars {}
            trace add variable stars {read write unset} "$this accessor828"
}
destructor {







trace remove variable cam {read write unset} "$this accessor825"
trace remove variable stars {read write unset} "$this accessor828"
}
}

::itcl::class {Manipulator} {
inherit AObject
namespace eval :: {
proc {c++ new Manipulator default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline829} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {update} {  } {set retpi [uplevel 1 [list {c++ trampoline831} $this ]]
return $retpi
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline833} $this ]]
return $retpi
}
method {primaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline835} $this $a0 $a1 ]]
return $retpi
}
method {primaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline837} $this $a0 $a1 ]]
return $retpi
}
method {secondaryDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline839} $this $a0 $a1 ]]
return $retpi
}
method {secondaryUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline841} $this $a0 $a1 ]]
return $retpi
}
method {scrollUp} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline843} $this $a0 $a1 ]]
return $retpi
}
method {scrollDown} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline845} $this $a0 $a1 ]]
return $retpi
}
method {motion} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline847} $this $a0 $a1 $a2 $a3 ]]
return $retpi
}
method {resetView} {  } {set retpi [uplevel 1 [list {c++ trampoline849} $this ]]
return $retpi
}
method {pushUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline851} $this ]]
return $retpi
}
method {popUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline853} $this ]]
return $retpi
}
method {commitUndo} {  } {set retpi [uplevel 1 [list {c++ trampoline855} $this ]]
return $retpi
}
method {deactivateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline857} $this ]]
return $retpi
}
method {activateMode} {  } {set retpi [uplevel 1 [list {c++ trampoline859} $this ]]
return $retpi
}
method {addToHistory} {  } {set retpi [uplevel 1 [list {c++ trampoline861} $this ]]
return $retpi
}
method {revertToHistory} { a0  } {set retpi [uplevel 1 [list {c++ trampoline863} $this $a0 ]]
return $retpi
}
method {reloadShip} {  } {set retpi [uplevel 1 [list {c++ trampoline865} $this ]]
set ret $retpi
return $ret
}
method {deleteShip} {  } {set retpi [uplevel 1 [list {c++ trampoline867} $this ]]
return $retpi
}
method {copyMounts} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline869} $this $a0 $a1 ]]
return $retpi
}
method {getCellAt} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline871} $this $a0 $a1 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






















}
destructor {






















}
}


 proc accessor874 {ignored ignored op} {
             global planetgen_width
             if {$op == {read}} {
               set tmp [{c++ get873} ]
               set planetgen_width $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_width"
             } else { error "Cannot unset C++ variable planetgen_width" }
           }

 proc accessor876 {ignored ignored op} {
             global planetgen_height
             if {$op == {read}} {
               set tmp [{c++ get875} ]
               set planetgen_height $tmp

             } elseif {$op == {write}} {
               error "Cannot write to planetgen_height"
             } else { error "Cannot unset C++ variable planetgen_height" }
           }

::itcl::class {PlanetGeneratorParms} {
inherit AObject
namespace eval :: {
proc {c++ new PlanetGeneratorParms default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline877} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable seed
 method accessor881 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get879} $this]
               set seed $tmp

             } elseif {$op == {write}} {
               return [{c++ set880} $this $seed]
             } else { error "Cannot unset C++ variable seed" }
           }

public variable continents
 method accessor884 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get882} $this]
               set continents $tmp

             } elseif {$op == {write}} {
               return [{c++ set883} $this $continents]
             } else { error "Cannot unset C++ variable continents" }
           }

public variable largeIslands
 method accessor887 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get885} $this]
               set largeIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set886} $this $largeIslands]
             } else { error "Cannot unset C++ variable largeIslands" }
           }

public variable smallIslands
 method accessor890 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get888} $this]
               set smallIslands $tmp

             } elseif {$op == {write}} {
               return [{c++ set889} $this $smallIslands]
             } else { error "Cannot unset C++ variable smallIslands" }
           }

public variable islandGrouping
 method accessor893 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get891} $this]
               set islandGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set892} $this $islandGrouping]
             } else { error "Cannot unset C++ variable islandGrouping" }
           }

public variable landSlope
 method accessor896 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get894} $this]
               set landSlope $tmp

             } elseif {$op == {write}} {
               return [{c++ set895} $this $landSlope]
             } else { error "Cannot unset C++ variable landSlope" }
           }

public variable oceans
 method accessor899 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get897} $this]
               set oceans $tmp

             } elseif {$op == {write}} {
               return [{c++ set898} $this $oceans]
             } else { error "Cannot unset C++ variable oceans" }
           }

public variable seas
 method accessor902 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get900} $this]
               set seas $tmp

             } elseif {$op == {write}} {
               return [{c++ set901} $this $seas]
             } else { error "Cannot unset C++ variable seas" }
           }

public variable lakes
 method accessor905 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get903} $this]
               set lakes $tmp

             } elseif {$op == {write}} {
               return [{c++ set904} $this $lakes]
             } else { error "Cannot unset C++ variable lakes" }
           }

public variable rivers
 method accessor908 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get906} $this]
               set rivers $tmp

             } elseif {$op == {write}} {
               return [{c++ set907} $this $rivers]
             } else { error "Cannot unset C++ variable rivers" }
           }

public variable mountainRanges
 method accessor911 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get909} $this]
               set mountainRanges $tmp

             } elseif {$op == {write}} {
               return [{c++ set910} $this $mountainRanges]
             } else { error "Cannot unset C++ variable mountainRanges" }
           }

public variable mountainSteepness
 method accessor914 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get912} $this]
               set mountainSteepness $tmp

             } elseif {$op == {write}} {
               return [{c++ set913} $this $mountainSteepness]
             } else { error "Cannot unset C++ variable mountainSteepness" }
           }

public variable enormousMountains
 method accessor917 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get915} $this]
               set enormousMountains $tmp

             } elseif {$op == {write}} {
               return [{c++ set916} $this $enormousMountains]
             } else { error "Cannot unset C++ variable enormousMountains" }
           }

public variable craters
 method accessor920 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get918} $this]
               set craters $tmp

             } elseif {$op == {write}} {
               return [{c++ set919} $this $craters]
             } else { error "Cannot unset C++ variable craters" }
           }

public variable maxCraterSize
 method accessor923 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get921} $this]
               set maxCraterSize $tmp

             } elseif {$op == {write}} {
               return [{c++ set922} $this $maxCraterSize]
             } else { error "Cannot unset C++ variable maxCraterSize" }
           }

public variable equatorTemperature
 method accessor926 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get924} $this]
               set equatorTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set925} $this $equatorTemperature]
             } else { error "Cannot unset C++ variable equatorTemperature" }
           }

public variable solarEquator
 method accessor929 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get927} $this]
               set solarEquator $tmp

             } elseif {$op == {write}} {
               return [{c++ set928} $this $solarEquator]
             } else { error "Cannot unset C++ variable solarEquator" }
           }

public variable polarTemperature
 method accessor932 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get930} $this]
               set polarTemperature $tmp

             } elseif {$op == {write}} {
               return [{c++ set931} $this $polarTemperature]
             } else { error "Cannot unset C++ variable polarTemperature" }
           }

public variable altitudeTemperatureDelta
 method accessor935 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get933} $this]
               set altitudeTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set934} $this $altitudeTemperatureDelta]
             } else { error "Cannot unset C++ variable altitudeTemperatureDelta" }
           }

public variable waterTemperatureDelta
 method accessor938 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get936} $this]
               set waterTemperatureDelta $tmp

             } elseif {$op == {write}} {
               return [{c++ set937} $this $waterTemperatureDelta]
             } else { error "Cannot unset C++ variable waterTemperatureDelta" }
           }

public variable freezingPoint
 method accessor941 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get939} $this]
               set freezingPoint $tmp

             } elseif {$op == {write}} {
               return [{c++ set940} $this $freezingPoint]
             } else { error "Cannot unset C++ variable freezingPoint" }
           }

public variable humidity
 method accessor944 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get942} $this]
               set humidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set943} $this $humidity]
             } else { error "Cannot unset C++ variable humidity" }
           }

public variable vapourTransport
 method accessor947 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get945} $this]
               set vapourTransport $tmp

             } elseif {$op == {write}} {
               return [{c++ set946} $this $vapourTransport]
             } else { error "Cannot unset C++ variable vapourTransport" }
           }

public variable mountainBlockage
 method accessor950 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get948} $this]
               set mountainBlockage $tmp

             } elseif {$op == {write}} {
               return [{c++ set949} $this $mountainBlockage]
             } else { error "Cannot unset C++ variable mountainBlockage" }
           }

public variable vegitationHumidity
 method accessor953 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get951} $this]
               set vegitationHumidity $tmp

             } elseif {$op == {write}} {
               return [{c++ set952} $this $vegitationHumidity]
             } else { error "Cannot unset C++ variable vegitationHumidity" }
           }

public variable cities
 method accessor956 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get954} $this]
               set cities $tmp

             } elseif {$op == {write}} {
               return [{c++ set955} $this $cities]
             } else { error "Cannot unset C++ variable cities" }
           }

public variable maxCitySize
 method accessor959 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get957} $this]
               set maxCitySize $tmp

             } elseif {$op == {write}} {
               return [{c++ set958} $this $maxCitySize]
             } else { error "Cannot unset C++ variable maxCitySize" }
           }

public variable cityGrouping
 method accessor962 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get960} $this]
               set cityGrouping $tmp

             } elseif {$op == {write}} {
               return [{c++ set961} $this $cityGrouping]
             } else { error "Cannot unset C++ variable cityGrouping" }
           }

public variable waterColour
 method accessor965 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get963} $this]
               set waterColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set964} $this $waterColour]
             } else { error "Cannot unset C++ variable waterColour" }
           }

public variable vegitationColour
 method accessor968 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get966} $this]
               set vegitationColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set967} $this $vegitationColour]
             } else { error "Cannot unset C++ variable vegitationColour" }
           }

public variable lowerPlanetColour
 method accessor971 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get969} $this]
               set lowerPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set970} $this $lowerPlanetColour]
             } else { error "Cannot unset C++ variable lowerPlanetColour" }
           }

public variable upperPlanetColour
 method accessor974 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get972} $this]
               set upperPlanetColour $tmp

             } elseif {$op == {write}} {
               return [{c++ set973} $this $upperPlanetColour]
             } else { error "Cannot unset C++ variable upperPlanetColour" }
           }

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set seed {}
            trace add variable seed {read write unset} "$this accessor881"
set continents {}
            trace add variable continents {read write unset} "$this accessor884"
set largeIslands {}
            trace add variable largeIslands {read write unset} "$this accessor887"
set smallIslands {}
            trace add variable smallIslands {read write unset} "$this accessor890"
set islandGrouping {}
            trace add variable islandGrouping {read write unset} "$this accessor893"
set landSlope {}
            trace add variable landSlope {read write unset} "$this accessor896"
set oceans {}
            trace add variable oceans {read write unset} "$this accessor899"
set seas {}
            trace add variable seas {read write unset} "$this accessor902"
set lakes {}
            trace add variable lakes {read write unset} "$this accessor905"
set rivers {}
            trace add variable rivers {read write unset} "$this accessor908"
set mountainRanges {}
            trace add variable mountainRanges {read write unset} "$this accessor911"
set mountainSteepness {}
            trace add variable mountainSteepness {read write unset} "$this accessor914"
set enormousMountains {}
            trace add variable enormousMountains {read write unset} "$this accessor917"
set craters {}
            trace add variable craters {read write unset} "$this accessor920"
set maxCraterSize {}
            trace add variable maxCraterSize {read write unset} "$this accessor923"
set equatorTemperature {}
            trace add variable equatorTemperature {read write unset} "$this accessor926"
set solarEquator {}
            trace add variable solarEquator {read write unset} "$this accessor929"
set polarTemperature {}
            trace add variable polarTemperature {read write unset} "$this accessor932"
set altitudeTemperatureDelta {}
            trace add variable altitudeTemperatureDelta {read write unset} "$this accessor935"
set waterTemperatureDelta {}
            trace add variable waterTemperatureDelta {read write unset} "$this accessor938"
set freezingPoint {}
            trace add variable freezingPoint {read write unset} "$this accessor941"
set humidity {}
            trace add variable humidity {read write unset} "$this accessor944"
set vapourTransport {}
            trace add variable vapourTransport {read write unset} "$this accessor947"
set mountainBlockage {}
            trace add variable mountainBlockage {read write unset} "$this accessor950"
set vegitationHumidity {}
            trace add variable vegitationHumidity {read write unset} "$this accessor953"
set cities {}
            trace add variable cities {read write unset} "$this accessor956"
set maxCitySize {}
            trace add variable maxCitySize {read write unset} "$this accessor959"
set cityGrouping {}
            trace add variable cityGrouping {read write unset} "$this accessor962"
set waterColour {}
            trace add variable waterColour {read write unset} "$this accessor965"
set vegitationColour {}
            trace add variable vegitationColour {read write unset} "$this accessor968"
set lowerPlanetColour {}
            trace add variable lowerPlanetColour {read write unset} "$this accessor971"
set upperPlanetColour {}
            trace add variable upperPlanetColour {read write unset} "$this accessor974"
}
destructor {

trace remove variable seed {read write unset} "$this accessor881"
trace remove variable continents {read write unset} "$this accessor884"
trace remove variable largeIslands {read write unset} "$this accessor887"
trace remove variable smallIslands {read write unset} "$this accessor890"
trace remove variable islandGrouping {read write unset} "$this accessor893"
trace remove variable landSlope {read write unset} "$this accessor896"
trace remove variable oceans {read write unset} "$this accessor899"
trace remove variable seas {read write unset} "$this accessor902"
trace remove variable lakes {read write unset} "$this accessor905"
trace remove variable rivers {read write unset} "$this accessor908"
trace remove variable mountainRanges {read write unset} "$this accessor911"
trace remove variable mountainSteepness {read write unset} "$this accessor914"
trace remove variable enormousMountains {read write unset} "$this accessor917"
trace remove variable craters {read write unset} "$this accessor920"
trace remove variable maxCraterSize {read write unset} "$this accessor923"
trace remove variable equatorTemperature {read write unset} "$this accessor926"
trace remove variable solarEquator {read write unset} "$this accessor929"
trace remove variable polarTemperature {read write unset} "$this accessor932"
trace remove variable altitudeTemperatureDelta {read write unset} "$this accessor935"
trace remove variable waterTemperatureDelta {read write unset} "$this accessor938"
trace remove variable freezingPoint {read write unset} "$this accessor941"
trace remove variable humidity {read write unset} "$this accessor944"
trace remove variable vapourTransport {read write unset} "$this accessor947"
trace remove variable mountainBlockage {read write unset} "$this accessor950"
trace remove variable vegitationHumidity {read write unset} "$this accessor953"
trace remove variable cities {read write unset} "$this accessor956"
trace remove variable maxCitySize {read write unset} "$this accessor959"
trace remove variable cityGrouping {read write unset} "$this accessor962"
trace remove variable waterColour {read write unset} "$this accessor965"
trace remove variable vegitationColour {read write unset} "$this accessor968"
trace remove variable lowerPlanetColour {read write unset} "$this accessor971"
trace remove variable upperPlanetColour {read write unset} "$this accessor974"
}
}

proc {planetgen_begin} { a0  } {set retpi [uplevel 1 [list {c++ trampoline975} $a0 ]]
return $retpi
}
proc {planetgen_what} {  } {set retpi [uplevel 1 [list {c++ trampoline977} ]]
set ret $retpi
return $ret
}
proc {planetgen_progress} {  } {set retpi [uplevel 1 [list {c++ trampoline979} ]]
set ret $retpi
return $ret
}
proc {planetgen_done} {  } {set retpi [uplevel 1 [list {c++ trampoline981} ]]
set ret $retpi
return $ret
}
proc {planetgen_kill} {  } {set retpi [uplevel 1 [list {c++ trampoline983} ]]
return $retpi
}
proc {planetgen_save} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline985} $a0 $a1 ]]
return $retpi
}

proc {set_hud_message} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline987} $a0 $a1 ]]
return $retpi
}
proc {global_chat_post} { a0  } {set retpi [uplevel 1 [list {c++ trampoline989} $a0 ]]
return $retpi
}
proc {global_chat_post_local} { a0  } {set retpi [uplevel 1 [list {c++ trampoline991} $a0 ]]
return $retpi
}
 proc accessor995 {ignored ignored op} {
             global state
             if {$op == {read}} {
               set tmp [{c++ get993} ]
               set state $tmp

             } elseif {$op == {write}} {
               return [{c++ set994}  $state]
             } else { error "Cannot unset C++ variable state" }
           }


 proc accessor997 {ignored ignored op} {
             global PLATFORM
             if {$op == {read}} {
               set tmp [{c++ get996} ]
               set PLATFORM $tmp

             } elseif {$op == {write}} {
               error "Cannot write to PLATFORM"
             } else { error "Cannot unset C++ variable PLATFORM" }
           }

 proc accessor999 {ignored ignored op} {
             global screenW
             if {$op == {read}} {
               set tmp [{c++ get998} ]
               set screenW $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenW"
             } else { error "Cannot unset C++ variable screenW" }
           }

 proc accessor1001 {ignored ignored op} {
             global screenH
             if {$op == {read}} {
               set tmp [{c++ get1000} ]
               set screenH $tmp

             } elseif {$op == {write}} {
               error "Cannot write to screenH"
             } else { error "Cannot unset C++ variable screenH" }
           }

 proc accessor1003 {ignored ignored op} {
             global vheight
             if {$op == {read}} {
               set tmp [{c++ get1002} ]
               set vheight $tmp

             } elseif {$op == {write}} {
               error "Cannot write to vheight"
             } else { error "Cannot unset C++ variable vheight" }
           }

 proc accessor1006 {ignored ignored op} {
             global generalAlphaBlending
             if {$op == {read}} {
               set tmp [{c++ get1004} ]
               set generalAlphaBlending $tmp

             } elseif {$op == {write}} {
               return [{c++ set1005}  $generalAlphaBlending]
             } else { error "Cannot unset C++ variable generalAlphaBlending" }
           }

 proc accessor1009 {ignored ignored op} {
             global alphaBlendingEnabled
             if {$op == {read}} {
               set tmp [{c++ get1007} ]
               set alphaBlendingEnabled $tmp

             } elseif {$op == {write}} {
               return [{c++ set1008}  $alphaBlendingEnabled]
             } else { error "Cannot unset C++ variable alphaBlendingEnabled" }
           }

 proc accessor1012 {ignored ignored op} {
             global smoothScaling
             if {$op == {read}} {
               set tmp [{c++ get1010} ]
               set smoothScaling $tmp

             } elseif {$op == {write}} {
               return [{c++ set1011}  $smoothScaling]
             } else { error "Cannot unset C++ variable smoothScaling" }
           }

 proc accessor1015 {ignored ignored op} {
             global highQuality
             if {$op == {read}} {
               set tmp [{c++ get1013} ]
               set highQuality $tmp

             } elseif {$op == {write}} {
               return [{c++ set1014}  $highQuality]
             } else { error "Cannot unset C++ variable highQuality" }
           }

 proc accessor1018 {ignored ignored op} {
             global antialiasing
             if {$op == {read}} {
               set tmp [{c++ get1016} ]
               set antialiasing $tmp

             } elseif {$op == {write}} {
               return [{c++ set1017}  $antialiasing]
             } else { error "Cannot unset C++ variable antialiasing" }
           }


 proc accessor1020 {ignored ignored op} {
             global headless
             if {$op == {read}} {
               set tmp [{c++ get1019} ]
               set headless $tmp

             } elseif {$op == {write}} {
               error "Cannot write to headless"
             } else { error "Cannot unset C++ variable headless" }
           }

 proc accessor1023 {ignored ignored op} {
             global cameraX1
             if {$op == {read}} {
               set tmp [{c++ get1021} ]
               set cameraX1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1022}  $cameraX1]
             } else { error "Cannot unset C++ variable cameraX1" }
           }

 proc accessor1026 {ignored ignored op} {
             global cameraX2
             if {$op == {read}} {
               set tmp [{c++ get1024} ]
               set cameraX2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1025}  $cameraX2]
             } else { error "Cannot unset C++ variable cameraX2" }
           }

 proc accessor1029 {ignored ignored op} {
             global cameraY1
             if {$op == {read}} {
               set tmp [{c++ get1027} ]
               set cameraY1 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1028}  $cameraY1]
             } else { error "Cannot unset C++ variable cameraY1" }
           }

 proc accessor1032 {ignored ignored op} {
             global cameraY2
             if {$op == {read}} {
               set tmp [{c++ get1030} ]
               set cameraY2 $tmp

             } elseif {$op == {write}} {
               return [{c++ set1031}  $cameraY2]
             } else { error "Cannot unset C++ variable cameraY2" }
           }

 proc accessor1035 {ignored ignored op} {
             global cameraCX
             if {$op == {read}} {
               set tmp [{c++ get1033} ]
               set cameraCX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1034}  $cameraCX]
             } else { error "Cannot unset C++ variable cameraCX" }
           }

 proc accessor1038 {ignored ignored op} {
             global cameraCY
             if {$op == {read}} {
               set tmp [{c++ get1036} ]
               set cameraCY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1037}  $cameraCY]
             } else { error "Cannot unset C++ variable cameraCY" }
           }

 proc accessor1041 {ignored ignored op} {
             global cameraZoom
             if {$op == {read}} {
               set tmp [{c++ get1039} ]
               set cameraZoom $tmp

             } elseif {$op == {write}} {
               return [{c++ set1040}  $cameraZoom]
             } else { error "Cannot unset C++ variable cameraZoom" }
           }

 proc accessor1044 {ignored ignored op} {
             global cursorX
             if {$op == {read}} {
               set tmp [{c++ get1042} ]
               set cursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1043}  $cursorX]
             } else { error "Cannot unset C++ variable cursorX" }
           }

 proc accessor1047 {ignored ignored op} {
             global cursorY
             if {$op == {read}} {
               set tmp [{c++ get1045} ]
               set cursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1046}  $cursorY]
             } else { error "Cannot unset C++ variable cursorY" }
           }

 proc accessor1050 {ignored ignored op} {
             global oldCursorX
             if {$op == {read}} {
               set tmp [{c++ get1048} ]
               set oldCursorX $tmp

             } elseif {$op == {write}} {
               return [{c++ set1049}  $oldCursorX]
             } else { error "Cannot unset C++ variable oldCursorX" }
           }

 proc accessor1053 {ignored ignored op} {
             global oldCursorY
             if {$op == {read}} {
               set tmp [{c++ get1051} ]
               set oldCursorY $tmp

             } elseif {$op == {write}} {
               return [{c++ set1052}  $oldCursorY]
             } else { error "Cannot unset C++ variable oldCursorY" }
           }


 proc accessor1055 {ignored ignored op} {
             global currentFrameTime
             if {$op == {read}} {
               set tmp [{c++ get1054} ]
               set currentFrameTime $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTime"
             } else { error "Cannot unset C++ variable currentFrameTime" }
           }

 proc accessor1057 {ignored ignored op} {
             global currentFrameTimeLeft
             if {$op == {read}} {
               set tmp [{c++ get1056} ]
               set currentFrameTimeLeft $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentFrameTimeLeft"
             } else { error "Cannot unset C++ variable currentFrameTimeLeft" }
           }

 proc accessor1059 {ignored ignored op} {
             global currentVFrameLast
             if {$op == {read}} {
               set tmp [{c++ get1058} ]
               set currentVFrameLast $tmp

             } elseif {$op == {write}} {
               error "Cannot write to currentVFrameLast"
             } else { error "Cannot unset C++ variable currentVFrameLast" }
           }

 proc accessor1061 {ignored ignored op} {
             global sparkCountMultiplier
             if {$op == {read}} {
               set tmp [{c++ get1060} ]
               set sparkCountMultiplier $tmp

             } elseif {$op == {write}} {
               error "Cannot write to sparkCountMultiplier"
             } else { error "Cannot unset C++ variable sparkCountMultiplier" }
           }

 proc accessor1063 {ignored ignored op} {
             global gameClock
             if {$op == {read}} {
               set tmp [{c++ get1062} ]
               set gameClock $tmp

             } elseif {$op == {write}} {
               error "Cannot write to gameClock"
             } else { error "Cannot unset C++ variable gameClock" }
           }

 proc accessor1065 {ignored ignored op} {
             global STD_CELL_SZ
             if {$op == {read}} {
               set tmp [{c++ get1064} ]
               set STD_CELL_SZ $tmp

             } elseif {$op == {write}} {
               error "Cannot write to STD_CELL_SZ"
             } else { error "Cannot unset C++ variable STD_CELL_SZ" }
           }

::itcl::class {SquareIcon} {
inherit AObject
namespace eval :: {
proc {c++ new SquareIcon default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1066} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {load} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1068} $this $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
method {unload} {  } {set retpi [uplevel 1 [list {c++ trampoline1070} $this ]]
return $retpi
}
method {isLoaded} {  } {set retpi [uplevel 1 [list {c++ trampoline1072} $this ]]
set ret $retpi
return $ret
}
method {draw} {  } {set retpi [uplevel 1 [list {c++ trampoline1074} $this ]]
return $retpi
}
method {save} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1076} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {






}
destructor {






}
}




::itcl::class {Antenna} {
inherit AObject
namespace eval :: {
proc {c++ new Antenna default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1078} $a0 $a1 ]]
set ret $retpi
return $ret
}}

public variable tuner
 method accessor1082 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1080} $this]
               set tuner $tmp

             } elseif {$op == {write}} {
               return [{c++ set1081} $this $tuner]
             } else { error "Cannot unset C++ variable tuner" }
           }

method {setInternetInformation4} { a0 a1 a2 a3 a4  } {set retpi [uplevel 1 [list {c++ trampoline1083} $this $a0 $a1 $a2 $a3 $a4 ]]
return $retpi
}
method {setInternetInformation6} { a0 a1 a2 a3 a4 a5 a6 a7 a8  } {set retpi [uplevel 1 [list {c++ trampoline1085} $this $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 $a8 ]]
return $retpi
}
method {getGlobalID4} {  } {set retpi [uplevel 1 [list {c++ trampoline1087} $this ]]
set ret $retpi
return $ret
}
method {getGlobalID6} {  } {set retpi [uplevel 1 [list {c++ trampoline1089} $this ]]
set ret $retpi
return $ret
}
method {hasV4} {  } {set retpi [uplevel 1 [list {c++ trampoline1091} $this ]]
set ret $retpi
return $ret
}
method {hasV6} {  } {set retpi [uplevel 1 [list {c++ trampoline1093} $this ]]
set ret $retpi
return $ret
}
method {processIncomming} {  } {set retpi [uplevel 1 [list {c++ trampoline1095} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

set tuner {}
            trace add variable tuner {read write unset} "$this accessor1082"







}
destructor {

trace remove variable tuner {read write unset} "$this accessor1082"







}
}

 proc accessor1098 {ignored ignored op} {
             global antenna
             if {$op == {read}} {
               set tmp [{c++ get1097} ]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

::itcl::class {Tuner} {
inherit AObject
namespace eval :: {
proc {c++ new Tuner default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1099} $a0 $a1 ]]
set ret $retpi
return $ret
}}

constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {

}
destructor {

}
}

::itcl::class {GlobalID} {
inherit AObject
namespace eval :: {
proc {c++ new GlobalID default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1101} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {toString} {  } {set retpi [uplevel 1 [list {c++ trampoline1103} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

::itcl::class {PacketProcessor} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}


::itcl::class {NetworkAssembly} {
inherit AObject
public variable field
 method accessor1106 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1105} $this]
               set field $tmp

             } elseif {$op == {write}} {
               error "Cannot write to field"
             } else { error "Cannot unset C++ variable field" }
           }

public variable antenna
 method accessor1108 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1107} $this]
               set antenna $tmp

             } elseif {$op == {write}} {
               error "Cannot write to antenna"
             } else { error "Cannot unset C++ variable antenna" }
           }

namespace eval :: {
proc {c++ new NetworkAssembly default} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1109} $a0 $a1 $a2 $a3 ]]
set ret $retpi
return $ret
}}

method {getTuner} {  } {set retpi [uplevel 1 [list {c++ trampoline1111} $this ]]
set ret $retpi
return $ret
}
method {numConnections} {  } {set retpi [uplevel 1 [list {c++ trampoline1113} $this ]]
set ret $retpi
return $ret
}
method {getConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1115} $this $a0 ]]
set ret $retpi
return $ret
}
method {addConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1117} $this $a0 ]]
return $retpi
}
method {removeConnection} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1119} $this $a0 ]]
return $retpi
}
method {addPacketProcessor} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1121} $this $a0 ]]
return $retpi
}
method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1123} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set field {}
            trace add variable field {read write unset} "$this accessor1106"
set antenna {}
            trace add variable antenna {read write unset} "$this accessor1108"








}
destructor {
trace remove variable field {read write unset} "$this accessor1106"
trace remove variable antenna {read write unset} "$this accessor1108"








}
}

::itcl::class {NetworkConnection} {
inherit PacketProcessor
public variable parent
 method accessor1126 {ignored ignored op} {
             
             if {$op == {read}} {
               set tmp [{c++ get1125} $this]
               set parent $tmp

             } elseif {$op == {write}} {
               error "Cannot write to parent"
             } else { error "Cannot unset C++ variable parent" }
           }

method {update} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1127} $this $a0 ]]
return $retpi
}
method {getStatus} {  } {set retpi [uplevel 1 [list {c++ trampoline1129} $this ]]
set ret $retpi
return $ret
}
method {getDisconnectReason} {  } {set retpi [uplevel 1 [list {c++ trampoline1131} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
set parent {}
            trace add variable parent {read write unset} "$this accessor1126"



}
destructor {
trace remove variable parent {read write unset} "$this accessor1126"



}
}

::itcl::class {ConnectionListener} {
inherit PacketProcessor
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

::itcl::class {GameAdvertiser} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameAdvertiser default} { a0 a1 a2 a3 a4 a5 a6 a7  } {set retpi [uplevel 1 [list {c++ trampoline1133} $a0 $a1 $a2 $a3 $a4 $a5 $a6 $a7 ]]
set ret $retpi
return $ret
}}

method {setOverseerId} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1135} $this $a0 ]]
return $retpi
}
method {setPeerCount} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1137} $this $a0 ]]
return $retpi
}
method {setGameMode} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1139} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}

::itcl::class {GameDiscoverer} {
inherit PacketProcessor
namespace eval :: {
proc {c++ new GameDiscoverer default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1141} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {start} {  } {set retpi [uplevel 1 [list {c++ trampoline1143} $this ]]
return $retpi
}
method {poll} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1145} $this $a0 ]]
return $retpi
}
method {progress} {  } {set retpi [uplevel 1 [list {c++ trampoline1147} $this ]]
set ret $retpi
return $ret
}
method {dumpResults} {  } {set retpi [uplevel 1 [list {c++ trampoline1149} $this ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      PacketProcessor::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {





}
destructor {





}
}

::itcl::class {InputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}

::itcl::class {OutputNetworkGeraet} {
inherit AObject
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
}
destructor {
}
}


::itcl::class {SeqTextOutputGeraet} {
inherit OutputNetworkGeraet
namespace eval :: {
proc {c++ new SeqTextOutputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1151} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {send} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1153} $this $a0 ]]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      OutputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

::itcl::class {SeqTextInputGeraet} {
inherit InputNetworkGeraet
namespace eval :: {
proc {c++ new TclSeqTextInputGeraet default} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1155} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}}

method {receiveText} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function receiveText"]
return $retpi
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      InputNetworkGeraet::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {


}
destructor {


}
}

itcl::class fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {
      inherit AObject
      constructor {args} {
        AObject::constructor fun<InputNetworkGeraet*:NetworkConnection*>::fun_t {} {}
      } {}
    }
::itcl::class {fun<InputNetworkGeraet*:NetworkConnection*>} {
inherit AObject
namespace eval :: {
proc {c++ new Tclfun<InputNetworkGeraet*:NetworkConnection*> default} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1159} $a0 $a1 ]]
set ret $retpi
return $ret
}}

method {invoke} { a0  } {set retpi [uplevel 1 error "Call to pure-virtual function invoke"]
set ret $retpi
return $ret
}
proc {call} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1163} $a0 $a1 ]]
set ret $retpi
return $ret
}
method {get} {  } {set retpi [uplevel 1 [list {c++ trampoline1165} $this ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {




}
destructor {




}
}


::itcl::class {ConfReg} {
inherit AObject
method {open} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1167} $this $a0 $a1 ]]
return $retpi
}
method {create} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1169} $this $a0 $a1 ]]
return $retpi
}
method {close} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1171} $this $a0 ]]
return $retpi
}
method {closeAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1173} $this ]]
return $retpi
}
method {modify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1175} $this $a0 ]]
return $retpi
}
method {unmodify} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1177} $this $a0 ]]
return $retpi
}
method {sync} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1179} $this $a0 ]]
return $retpi
}
method {syncAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1181} $this ]]
return $retpi
}
method {revert} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1183} $this $a0 ]]
return $retpi
}
method {revertAll} {  } {set retpi [uplevel 1 [list {c++ trampoline1185} $this ]]
return $retpi
}
method {addToWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1187} $this $a0 ]]
return $retpi
}
method {removeFromWhitelist} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1189} $this $a0 ]]
return $retpi
}
method {clearWhitelist} {  } {set retpi [uplevel 1 [list {c++ trampoline1191} $this ]]
return $retpi
}
method {setWhitelistOnly} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1193} $this $a0 ]]
return $retpi
}
method {renameFile} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1195} $this $a0 $a1 ]]
return $retpi
}

method {exists} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1197} $this $a0 ]]
set ret $retpi
return $ret
}
method {bool} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1199} $this $a0 ]]
set ret $retpi
return $ret
}
method {int} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1201} $this $a0 ]]
set ret $retpi
return $ret
}
method {float} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1203} $this $a0 ]]
set ret $retpi
return $ret
}
method {str} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1205} $this $a0 ]]
set ret $retpi
return $ret
}
method {setb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1207} $this $a0 $a1 ]]
return $retpi
}
method {seti} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1209} $this $a0 $a1 ]]
return $retpi
}
method {setf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1211} $this $a0 $a1 ]]
return $retpi
}
method {sets} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1213} $this $a0 $a1 ]]
return $retpi
}
method {add} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1215} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addb} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1217} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addi} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1219} $this $a0 $a1 $a2 ]]
return $retpi
}
method {addf} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1221} $this $a0 $a1 $a2 ]]
return $retpi
}
method {adds} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1223} $this $a0 $a1 $a2 ]]
return $retpi
}
method {remove} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1225} $this $a0 ]]
return $retpi
}
method {append} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1227} $this $a0 $a1 ]]
return $retpi
}
method {appendb} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1229} $this $a0 $a1 ]]
return $retpi
}
method {appendi} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1231} $this $a0 $a1 ]]
return $retpi
}
method {appendf} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1233} $this $a0 $a1 ]]
return $retpi
}
method {appends} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1235} $this $a0 $a1 ]]
return $retpi
}
method {remix} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1237} $this $a0 $a1 ]]
return $retpi
}
method {name} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1239} $this $a0 ]]
set ret $retpi
return $ret
}
method {copy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1241} $this $a0 $a1 ]]
return $retpi
}
method {getType} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1243} $this $a0 ]]
set ret $retpi
return $ret
}
method {length} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1245} $this $a0 ]]
set ret $retpi
return $ret
}
method {isGroup} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1247} $this $a0 ]]
set ret $retpi
return $ret
}
method {isArray} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1249} $this $a0 ]]
set ret $retpi
return $ret
}
method {isList} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1251} $this $a0 ]]
set ret $retpi
return $ret
}
method {isAggregate} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1253} $this $a0 ]]
set ret $retpi
return $ret
}
method {isScalar} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1255} $this $a0 ]]
set ret $retpi
return $ret
}
method {isNumber} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1257} $this $a0 ]]
set ret $retpi
return $ret
}
method {getSourceLine} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1259} $this $a0 ]]
set ret $retpi
return $ret
}
constructor {clazz cname arguments} {
      # Every class we extend (if it isn't just AObject) has
      # exactly one purpose in its constructor: Call the parent
      # constructor until we reach AObject. Therefore, to avoid
      # multiple instantiation, only call the first super
      AObject::constructor [expr {[string length $cname] && {*}==[string index $cname 0]?
                 "Tcl$clazz" : $clazz}] [expr {[string length $cname] && {*}==[string index $cname 0]?
                 [string range $cname 1 [string length $cname]] : $cname}] $arguments} {
















































}
destructor {
















































}
}

 proc accessor1262 {ignored ignored op} {
             global globalConf
             if {$op == {read}} {
               set tmp [{c++ get1261} ]
               set globalConf $tmp

             } elseif {$op == {write}} {
               error "Cannot write to globalConf"
             } else { error "Cannot unset C++ variable globalConf" }
           }

proc {confcpy} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1263} $a0 $a1 ]]
return $retpi
}
proc {l10n_acceptLanguage} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1265} $a0 ]]
return $retpi
}
proc {l10n_loadCatalogue} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1267} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {l10n_purgeCatalogue} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1269} $a0 ]]
return $retpi
}

proc {_} { a0 a1 a2  } {set retpi [uplevel 1 [list {c++ trampoline1271} $a0 $a1 $a2 ]]
set ret $retpi
return $ret
}
proc {namegenAny} {  } {set retpi [uplevel 1 [list {c++ trampoline1273} ]]
set ret $retpi
return $ret
}
proc {namegenGet} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1275} $a0 ]]
set ret $retpi
return $ret
}
proc {newInterpreter} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1277} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {delInterpreter} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1279} $a0 ]]
return $retpi
}

proc {safe_source} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1281} $a0 ]]
return $retpi
}
proc {bkg_start} {  } {set retpi [uplevel 1 [list {c++ trampoline1283} ]]
return $retpi
}
proc {bkg_req} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1285} $a0 ]]
return $retpi
}
proc {bkg_ans} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1287} $a0 ]]
return $retpi
}
proc {bkg_req2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1289} $a0 $a1 ]]
return $retpi
}
proc {bkg_ans2} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1291} $a0 $a1 ]]
return $retpi
}
proc {bkg_rcv} {  } {set retpi [uplevel 1 [list {c++ trampoline1293} ]]
set ret $retpi
return $ret
}
proc {bkg_get} {  } {set retpi [uplevel 1 [list {c++ trampoline1295} ]]
set ret $retpi
return $ret
}
proc {bkg_wait} {  } {set retpi [uplevel 1 [list {c++ trampoline1297} ]]
return $retpi
}
proc {crypto_init} { a0  } {set retpi [uplevel 1 [list {c++ trampoline1299} $a0 ]]
return $retpi
}
proc {crypto_rand} {  } {set retpi [uplevel 1 [list {c++ trampoline1301} ]]
set ret $retpi
return $ret
}
proc {crypto_powm} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1303} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {performValidation} { a0 a1 a2 a3  } {set retpi [uplevel 1 [list {c++ trampoline1305} $a0 $a1 $a2 $a3 ]]
return $retpi
}
proc {getValidationResultA} {  } {set retpi [uplevel 1 [list {c++ trampoline1307} ]]
set ret $retpi
return $ret
}
proc {getValidationResultB} {  } {set retpi [uplevel 1 [list {c++ trampoline1309} ]]
set ret $retpi
return $ret
}
proc {networkTestListen} {  } {set retpi [uplevel 1 [list {c++ trampoline1311} ]]
return $retpi
}
proc {networkTestRun} { a0 a1  } {set retpi [uplevel 1 [list {c++ trampoline1313} $a0 $a1 ]]
set ret $retpi
return $ret
}
proc {ship_mixer_init} {  } {set retpi [uplevel 1 [list {c++ trampoline1315} ]]
return $retpi
}
proc {ship_mixer_end} {  } {set retpi [uplevel 1 [list {c++ trampoline1317} ]]
return $retpi
}
proc {debugTclExports} {  } {set retpi [uplevel 1 [list {c++ trampoline1319} ]]
return $retpi
}































set none {}
trace add variable none {read write unset} accessor60
set lshift {}
trace add variable lshift {read write unset} accessor62
set rshift {}
trace add variable rshift {read write unset} accessor64
set lctrl {}
trace add variable lctrl {read write unset} accessor66
set rctrl {}
trace add variable rctrl {read write unset} accessor68
set lalt {}
trace add variable lalt {read write unset} accessor70
set ralt {}
trace add variable ralt {read write unset} accessor72
set lmeta {}
trace add variable lmeta {read write unset} accessor74
set rmeta {}
trace add variable rmeta {read write unset} accessor76
set num {}
trace add variable num {read write unset} accessor78
set caps {}
trace add variable caps {read write unset} accessor80
set mode {}
trace add variable mode {read write unset} accessor82
set reserved {}
trace add variable reserved {read write unset} accessor84
set glueClass(SDL_keysym) yes





set glueClass(SDL_KeyboardEvent) yes




set SDL_BUTTON_1 {}
trace add variable SDL_BUTTON_1 {read write unset} accessor107
set SDL_BUTTON_2 {}
trace add variable SDL_BUTTON_2 {read write unset} accessor109
set SDL_BUTTON_3 {}
trace add variable SDL_BUTTON_3 {read write unset} accessor111
set SDL_BUTTON_4 {}
trace add variable SDL_BUTTON_4 {read write unset} accessor113
set SDL_BUTTON_5 {}
trace add variable SDL_BUTTON_5 {read write unset} accessor115

set SDL_DEFAULT_REPEAT_INTERVAL {}
trace add variable SDL_DEFAULT_REPEAT_INTERVAL {read write unset} accessor119
set SDL_DEFAULT_REPEAT_DELAY {}
trace add variable SDL_DEFAULT_REPEAT_DELAY {read write unset} accessor121


set glueClass(SDL_MouseMotionEvent) yes







set glueClass(SDL_MouseButtonEvent) yes










set glueClass(Font) yes












set sysfont {}
trace add variable sysfont {read write unset} accessor185
set sysfontStipple {}
trace add variable sysfontStipple {read write unset} accessor187
set glueClass(GameState) yes








set glueClass(InitState) yes



set gameClass {}
trace add variable gameClass {read write unset} accessor206
set humanShip {}
trace add variable humanShip {read write unset} accessor209
set testStateMode {}
trace add variable testStateMode {read write unset} accessor212
set testStateSize {}
trace add variable testStateSize {read write unset} accessor215
set glueClass(TestState) yes






set glueClass(GameObject) yes





































set glueClass(GameField) yes
















set glueClass(Blast) yes


















set glueClass(CellFragment) yes




set glueClass(PlasmaFire) yes




set glueClass(Explosion) yes












set glueClass(OldStyleExplosion) yes





set glueClass(LightTrail) yes














set glueClass(fun<void:Ship*,bool>) yes





set glueClass(radar_t) yes


set glueClass(Ship) yes







































































set glueClass(Shield) yes

















set glueClass(EnergyCharge) yes







set glueClass(MagnetoBomb) yes







set glueClass(SemiguidedBomb) yes


set glueClass(PlasmaBurst) yes






set glueClass(MonophasicEnergyPulse) yes


set glueClass(Missile) yes


set glueClass(EffectsHandler) yes





set nullEffectsHandler {}
trace add variable nullEffectsHandler {read write unset} accessor643
set glueClass(Background) yes





set glueClass(Planet) yes


set glueClass(StarField) yes


set glueClass(Nebula) yes











set glueClass(Camera) yes








set glueClass(DynamicCamera) yes













set glueClass(FixedCamera) yes


set glueClass(Controller) yes







set glueClass(HumanController) yes







set isCompositionBufferInUse {}
trace add variable isCompositionBufferInUse {read write unset} accessor740
set glueClass(AIControl) yes



set glueClass(GeneticAI) yes








set glueClass(GenAI) yes






set glueClass(CommonKeyboardClient) yes














set glueClass(ForwardingEffectsHandler) yes


set glueClass(Spectator) yes








set glueClass(GameEnv) yes










set glueClass(Manipulator) yes
























set planetgen_width {}
trace add variable planetgen_width {read write unset} accessor874
set planetgen_height {}
trace add variable planetgen_height {read write unset} accessor876
set glueClass(PlanetGeneratorParms) yes












































set state {}
trace add variable state {read write unset} accessor995

set PLATFORM {}
trace add variable PLATFORM {read write unset} accessor997
set screenW {}
trace add variable screenW {read write unset} accessor999
set screenH {}
trace add variable screenH {read write unset} accessor1001
set vheight {}
trace add variable vheight {read write unset} accessor1003
set generalAlphaBlending {}
trace add variable generalAlphaBlending {read write unset} accessor1006
set alphaBlendingEnabled {}
trace add variable alphaBlendingEnabled {read write unset} accessor1009
set smoothScaling {}
trace add variable smoothScaling {read write unset} accessor1012
set highQuality {}
trace add variable highQuality {read write unset} accessor1015
set antialiasing {}
trace add variable antialiasing {read write unset} accessor1018

set headless {}
trace add variable headless {read write unset} accessor1020
set cameraX1 {}
trace add variable cameraX1 {read write unset} accessor1023
set cameraX2 {}
trace add variable cameraX2 {read write unset} accessor1026
set cameraY1 {}
trace add variable cameraY1 {read write unset} accessor1029
set cameraY2 {}
trace add variable cameraY2 {read write unset} accessor1032
set cameraCX {}
trace add variable cameraCX {read write unset} accessor1035
set cameraCY {}
trace add variable cameraCY {read write unset} accessor1038
set cameraZoom {}
trace add variable cameraZoom {read write unset} accessor1041
set cursorX {}
trace add variable cursorX {read write unset} accessor1044
set cursorY {}
trace add variable cursorY {read write unset} accessor1047
set oldCursorX {}
trace add variable oldCursorX {read write unset} accessor1050
set oldCursorY {}
trace add variable oldCursorY {read write unset} accessor1053

set currentFrameTime {}
trace add variable currentFrameTime {read write unset} accessor1055
set currentFrameTimeLeft {}
trace add variable currentFrameTimeLeft {read write unset} accessor1057
set currentVFrameLast {}
trace add variable currentVFrameLast {read write unset} accessor1059
set sparkCountMultiplier {}
trace add variable sparkCountMultiplier {read write unset} accessor1061
set gameClock {}
trace add variable gameClock {read write unset} accessor1063
set STD_CELL_SZ {}
trace add variable STD_CELL_SZ {read write unset} accessor1065
set glueClass(SquareIcon) yes










set glueClass(Antenna) yes










set antenna {}
trace add variable antenna {read write unset} accessor1098
set glueClass(Tuner) yes


set glueClass(GlobalID) yes



set glueClass(PacketProcessor) yes


set glueClass(NetworkAssembly) yes











set glueClass(NetworkConnection) yes





set glueClass(ConnectionListener) yes

set glueClass(GameAdvertiser) yes





set glueClass(GameDiscoverer) yes






set glueClass(InputNetworkGeraet) yes

set glueClass(OutputNetworkGeraet) yes


set glueClass(SeqTextOutputGeraet) yes



set glueClass(SeqTextInputGeraet) yes




set glueClass(fun<InputNetworkGeraet*:NetworkConnection*>) yes






set glueClass(ConfReg) yes

















































set globalConf {}
trace add variable globalConf {read write unset} accessor1262
































safe_source tcl/autosource.tcl
